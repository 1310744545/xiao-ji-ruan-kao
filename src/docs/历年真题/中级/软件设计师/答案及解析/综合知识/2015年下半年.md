---  
title: 2015年下半年  
# icon: gears  
order: 987  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

**正确答案：D. 一个总线周期**  
本题考查计算机组成基础知识。  
DMA控制器在需要的时候代替CPU作为总线主设备，在不受CPU干预的情况下，控制I/O设备与系统主存之间的直接数据传输。DMA操作占用的资源是系统总线，而CPU并非在整个指令执行期间即指令周期内都会使用总线，故DMA请求的检测点设置在每个机器周期也即总线周期结束时执行，这样使得总线利用率最高。  


## 第2题 ##

**正确答案：A. 主存-辅存**  
本题考查计算机组成基础知识。  
计算机中不同容量、不同速度、不同访问形式、不同用途的各种存储器形成的是一种层次结构的存储系统。所有的存储器设备按照一定的层次逻辑关系通过软硬件连接起来，并进行有效的管理，就形成了存储体系。不同层次上的存储器发挥着不同的作用。-般计算机系统中主要有两种存储体系：Cache存储体系由Cache和主存储器构成，主要目的是提高存储器速度，对系统程序员以上均透明；虚拟存储体系由主存储器和在线磁盘存储器等辅存构成，主要目的是扩大存储器容量，对应用程序员透明。  


## 第3题 ##

**正确答案：B. 阶码**  
本题考查计算机组成基础知识。  
在计算机中使用了类似于十进制科学计数法的方法来表示二进制实数，因其表示不同的数时小数点位置的浮动不固定而取名浮点数表示法。浮点数编码由两部分组成：阶码(即指数，为带符号定点整数，常用移码表示，也有用补码的)和尾数(是定点纯小数，常用补码表示，或原码表示)。因此可以知道，浮点数的精度由尾数的位数决定，表示范围的大小则主要由阶码的位数决定。  


## 第4题 ##

**正确答案：C. 立即寻址**  
本题考查计算机组成基础知识。  
随着主存增加，指令本身很难保证直接反映操作数的值或其地址，必须通过某种映射方式实现对所需操作数的获取。指令系统中将这种映射方式称为寻址方式，即指令按什么方式寻找(或访问)到所需的操作数或信息(例如转移地址信息等)。可以被指令访问到的数据和信息包括通用寄存器、主存、堆栈及外设端口寄存器等。  
指令中地址码字段直接给出操作数本身，而不是其访存地址，不需要访问任何地址的寻址方式被称为立即寻址。  


## 第5题 ##

**正确答案：B. 159KB**  
本题考查计算机组成基础知识。  
直接计算16进制地址包含的存储单元个数即可。  
DABFFH-B3000H+1=27C00H=162816=159k，按字节编址，故此区域的存储容量为159kB。  


## 第6题 ##

**正确答案：A. 复杂指令系统计算机**  
本题考查计算机组成与结构基础知识。  
计算机技术发展使得机器性能提高，随着高级语言的发展，程序员需要更强大的命令，指令集往往结合应用需要不断扩展，推动了指令集越来越复杂，形成了CISC，即Complex Instruction Set Computer，就是使用复杂指令集系统的计算机。与其对应的是RISC，即Reduced Instruction Set Computer，精简指令集系统的计算机。  


## 第7题 ##

**正确答案：A. 流量分析**  
本题考查的是网络攻击的基础知识。  
网络攻击有主动攻击和被动攻击两类。其中主动攻击是指通过一系列的方法，主动向被攻击对象实施破坏的一种攻击方式，例如重放攻击、IP地址欺骗、拒绝服务攻击等均属于攻击者主动向攻击对象发起破坏性攻击的方式。流量分析攻击是通过持续检测现有网络中的流量变化或者变化趋势，而得到相应信息的一种被动攻击方式。  


## 第8题 ##

**正确答案：B. 查毒**  
本题考查的是防火墙基础知识。  
防火墙是一种放置在网络边界上，用于保护内部网络安全的网络设备。它通过对流经数据流进行分析和检查，可实现对数据包的过滤、保存用户访问网络的记录和服务器代理功能。防火墙不具备检査病毒的功能。  


## 第9题 ##

**正确答案：C. 本地主机与202.100.112.12建立了安全连接**  
本题考查网管命令netstat-n的含义以及端口的作用。  
从netstat -n的输出信息中可以看出，本地主机192.168.0.200使用的端口号2011、2038、2052都不是公共端口号。  
根据状态提示信息，其中己经与主机128.105.129.30的80端口建立了普通连接， 与主机100.29.200.110正在等待建立连接， 与主机202.100.112.12的443端口建立连接，由于443端口主要用于HTTPS服务，是提供加密和通过安全端口传输的另一种HTTP协议，所以是建立了安全连接。  


## 第10题 ##

**正确答案：C. 发表权**  
我国著作权法在第10条对权利内容作了较为详尽而具体的规定，指明著作权的内容包括人身权利和财产权利。著作人身权是指作者享有的与其作品有关的以人格利益为内容的权利，也称为精神权利，包括发表权、署名权、修改权和保护作品完整权。著作人身权与作者的身份紧密联系，永远属于作者本人，即使作者死亡，其他任何人不能再拥有它。所以，我国著作权法第20条规定“作者的署名权、修改权、保护作品完整权的保护期不受限制。”  
发表权是属于人身权利，但发表权是一次性权利，即发表权行使一次后，不再享有发表权。发表权是指决定作品是否公之于众的权利，作品一经发表，就处于公知状态，对处于公知状态的作品，作者不再享有发表权，以后再次使用作品与发表权无关，而是行使作品的使用权。  


## 第11题 ##

**正确答案：A. 侵犯了公司的软件著作权**  
王某的行为侵犯了公司的软件著作权。因为王某作为公司的职员，完成的某一综合信息管理系统软件是针对其本职工作中明确指定的开发目标而开发的软件。该软件应为职务作品，并属于特殊职务作品。公司对该软件享有除署名权外的软件著作权的其他权利，而王某只享有署名权。王某持有该软件源程序不归还公司的行为，妨碍了公司正常行使软件著作权，构成对公司软件著作权的侵犯，应承担停止侵权法律责任，交还软件源程序。  


## 第12题 ##

**正确答案：C. 20Hz～20KHz**  
声音是通过空气传播的一种连续的波，称为声波。声波在时间和幅度上都是连续的模拟信号，通常称为模拟声音(音频)信号。人们对声音的感觉主要有音量、音调和音色。音量又称音强或响度，取决于声音波形的幅度，也就是说，振幅的大小表明声音的响亮程度或强弱程度。音调与声音的频率有关，频率高则声音高昂，频率低则声音低沉。而音色是由混入基音的泛音所决定的，每个基音都有其固有的频率和不同音强的泛音，从而使得声音具有其特殊的音色效果。人耳能听得到的音频信号的频率范围是20Hz~20kHz，包括：话音(300Hz~3400Hz)、音乐(20Hz~20kHz)、其他声音(如风声、雨声、鸟叫声、汽车鸣笛声等，其带宽范围也是20Hz~20kHz)，频率小于20Hz声波信号称为亚音信号(次音信号)，高于20kHz的信号称为超音频信号(超声波)。  


## 第13题 ##

**正确答案：C. 256**  
颜色深度是表达图像中单个像素的颜色或灰度所占的位数(bit)，它决定了彩色图像中可出现的最多颜色数，或者灰度图像中的最大灰度等级数。8位的颜色深度，表示每个像素有8位颜色位，可表示28=256种不同的颜色或灰度等级。表示一个像素颜色的位数越多，它能表达的颜色数或灰度等级就越多，其深度越深。  
图像深度是指存储每个像素(颜色或灰度)所用的位数(bit)，它也是用来度量图像的分辨率的。像素深度确定彩色图像的每个像素可能有的颜色数，或者确定灰度图像的每个像素可能有的灰度级数。如一幅图像的图像深度为b位，则该图像的最多颜色数或灰度级为2b种。显然，表示一个像素颜色的位数越多，它能表达的颜色数或灰度级就越多。例如，只有1个分量的单色图像(黑白图像)，若每个像素有8位，则最大灰度数目为28=256;—幅彩色图像的每个像素用R、G、B三个分量表示，若3个分量的像素位数分别为4、4、2，贝撮大颜色数目为24+4+2=210=1024，就是说像素的深度为10位，每个像素可以是210种颜色中的一种。本题给出8位的颜色深度，则表示该图像具有28=256种不同的颜色或灰度等级。  


## 第14题 ##

**正确答案：B. 纯度**  
饱和度是指颜色的纯度，即颜色的深浅，或者说掺入白光的程度，对于同一色调的彩色光，饱和度越深颜色越纯。当红色加入白光之后冲淡为粉红色，其基本色调仍然是红色，但饱和度降低。也就是说，饱和度与亮度有关，若在饱和的彩色光中增加白光的成分，即增加了光能，而变得更亮了，但是其饱和度却降低了。对于同一色调的彩色光，饱和度越高，颜色越纯。如果在某色调的彩色光中，掺入其他彩色光，将引起色调的变化，而改变白光的成分只引起饱和度的变化。高饱和度的深色光可掺入白色光被冲淡，降为低饱和度的淡色光。例如，一束高饱和度的蓝色光投射到屏幕上会被看成深蓝色光，若再将一束白色光也投射到屏幕上并与深蓝色重叠，则深蓝色变成淡蓝色，而且投射的白色光越强，颜色越淡，即饱和度越低。相反，由于在彩色电视的屏幕上的亮度过高，则饱和度降低，颜色被冲淡，这时可以降低亮度(白光)而使饱和度增大，颜色加深。  
当彩色的饱和度降低时，其固有色彩特性也被降低和发生变化。例如，红色与绿色配置在一起，往往具有一种对比效果，但只有当红色与绿色都呈现饱和状态时，其对比效果才比较强烈。如果红色与绿色的饱和度都降低，红色变成浅红或暗红，绿色变成浅绿或深绿，再把它们配置在一起时相互的对比特征就会减弱，而趋于和谐。另外饱和度高的色彩容易让人感到单调刺眼。饱和度低，色感比较柔和协调，但混色太杂又容易让人感觉浑浊，色调显得灰暗。  


## 第15~16题 ##

**正确答案：C. 原型化**  
本题考查软件开发方法的基础知识。  
要求考生掌握典型的软件开发方法的基本概念和应用场合。需求不清晰且规模不太大时采用原型化方法最合适，而数据处理领域的不太复杂的软件，适于用结构化方法进行开发。  
**正确答案：A. 结构化**  
本题考查软件开发方法的基础知识。  
要求考生掌握典型的软件开发方法的基本概念和应用场合。需求不清晰且规模不太大时采用原型化方法最合适，而数据处理领域的不太复杂的软件，适于用结构化方法进行开发。  


## 第17~18题 ##

**正确答案：D. 24**  
本题考查软件项目管理的基础知识。  
根据上图计算出关键路径为A-B-C-E-F-I-K-L，其长度为24，关键路径上的活动均为关键活动。  
活动BD不在关键路径上，包含该活动的最长路径为A-B-D-G-I-K-L，其长度为22，因此松弛时间为2。  
**正确答案：A. 2**  
本题考查软件项目管理的基础知识。  
根据上图计算出关键路径为A-B-C-E-F-I-K-L，其长度为24，关键路径上的活动均为关键活动。  
活动BD不在关键路径上，包含该活动的最长路径为A-B-D-G-I-K-L，其长度为22，因此松弛时间为2。  


## 第19题 ##

**正确答案：A. 项目组成员的工作风格也应该作为组织团队时要考虑的一个要素**  
本题考查软件项目管理的基础知识。  
人员管理是软件项目管理的一个重要部分，在组织开发团队时，应该考虑开发人员的工作能力、知识背景、工作风格、兴趣爱好等多方面的因素。每个成员的工作任务分配清楚，不应该参与所有阶段的工作。当项目进度滞后于项目计划时，增加开发人员不一定可以加快开发进度。  


## 第20~21题 ##

**正确答案：C. 中间代码生成和代码优化**  
本题考查程序语言基础知识。  
解释程序也称为解释器，它可以直接解释执行源程序，或者将源程序翻译成某种中间表示形式后再加以执行；而编译程序(编译器)则首先将源程序翻译成目标语言程序，然后在计算机上运行目标程序。这两种语言处理程序的根本区别是：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程；而在解释方式下，解释程序和源程序(或其某种等价表示)要参与到程序的运行过程中，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序，而编译器则需将源程序翻译成独立的目标程序。  
分阶段编译器的工作过程如下图所示。其中，中间代码生成和代码优化不是必须的。  
![7666859618ed4f8198968671f37d3fa7.jpg][]  
**正确答案：B. 参与运行控制，程序执行的速度慢**  
本题考查程序语言基础知识。  
解释程序也称为解释器，它可以直接解释执行源程序，或者将源程序翻译成某种中间表示形式后再加以执行；而编译程序(编译器)则首先将源程序翻译成目标语言程序，然后在计算机上运行目标程序。这两种语言处理程序的根本区别是：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程；而在解释方式下，解释程序和源程序(或其某种等价表示)要参与到程序的运行过程中，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序，而编译器则需将源程序翻译成独立的目标程序。  
分阶段编译器的工作过程如下图所示。其中，中间代码生成和代码优化不是必须的。  
![7666859618ed4f8198968671f37d3fa7.jpg][]  


## 第22题 ##

**正确答案：A. 栈**  
本题考查程序语言基础知识。  
后缀式(逆波兰式)是波兰逻辑学家卢卡西维奇发明的一种表示表达式的方法。这种表示方式把运算符写在运算对象的后面，例如，把a+b写成ab+，所以也称为后缀式。  
借助栈可以方便地对后缀式进行求值。方法为：先创建一个初始为空的栈，用来存放运算数。对后缀表达式求值时，从左至右扫描表达式，若遇到运算数，就将其入栈，若遇到运算符，就从栈顶弹出需要的运算数并进行运算，然后将结果压入栈顶，如此重复，直到表达式结束。若表达式无错误，则最后的运算结果就存放在找顶并且是栈中唯一的元素。  


## 第23~24题 ##

**正确答案：C. 都是互斥信号量，其初值分别为1和1**  
信号量S1是一个互斥信号量，表示半成品箱B1当前无工人(生产者)使用，所以初值为1。信号量S5也是一个互斥信号量，表示成品箱B2当前无工人或检验员使用，所以初值为1。  
**正确答案：D. n、m**  
信号量S1是一个互斥信号量，表示半成品箱B1当前无工人(生产者)使用，所以初值为1。信号量S5也是一个互斥信号量，表示成品箱B2当前无工人或检验员使用，所以初值为1。  


## 第25~26题 ##

**正确答案：D. 201**  
在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，缓冲区中的数据传送到用户工作区的时间为M，而系统处理(计算)的时间为C，如图(a)所示。  
![254621fbb90b4204a4f0c0b98ff69f84.jpg][]  
当第一块数据送入用户工作区后，缓冲区是空闲的就可以传送第二块数据。这样第一块数据的处理C1与第二块数据的输入T2是可以并行的，依次类推，如图(b)所示。系统对每一块数据的处理时间为：Max(C，T)+M。因为，当T&gt;C时，处理时间为M+T;当T&lt;C时，处理时间为M+C。本题每一块数据的处理时间为15+5=20，Docl文件的处理时间为20\*10+1。  
  
![8a7b8113e717450cbeda90110381c0e0.jpg][]  
**正确答案：C. 156**  
在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，缓冲区中的数据传送到用户工作区的时间为M，而系统处理(计算)的时间为C，如图(a)所示。  
![254621fbb90b4204a4f0c0b98ff69f84.jpg][]  
当第一块数据送入用户工作区后，缓冲区是空闲的就可以传送第二块数据。这样第一块数据的处理C1与第二块数据的输入T2是可以并行的，依次类推，如图(b)所示。系统对每一块数据的处理时间为：Max(C，T)+M。因为，当T&gt;C时，处理时间为M+T;当T&lt;C时，处理时间为M+C。本题每一块数据的处理时间为15+5=20，Docl文件的处理时间为20\*10+1。  
  
![8a7b8113e717450cbeda90110381c0e0.jpg][]  


## 第27题 ##

**正确答案：D. P2是阻塞节点，P1、P3是非阻塞节点，该图可以化简，所以是非死锁的**  
R2资源有3个，已分配2个，P3申请1个R2资源可以得到满足，故进程P3可以运行完毕释放其占有的资源。这样可以使得P1、P3都变为非阻塞节点，得到所需资源运行完毕，因此，该进程资源图是可化简的。  


## 第28题 ##

**正确答案：C. 该进程中某线程的栈指针**  
在同一进程中的各个线程都可以共享该进程所拥有的资源，如访问进程地址空间中的每一个虚地址；访问进程所拥有的已打开文件、定时器、信号量机构等，但是不能共享进程中某线程的栈指针。  


## 第29题 ##

**正确答案：B. 原型**  
本题考査软件开发过程模型的基础知识。  
瀑布模型将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段的过程。  
原型模型中，开发人员快速地构造整个系统或者系统的一部分以理解或澄清问题。螺旋模型将开发活动和风险管理结合起来，以减小风险。  
喷泉模型开发过程模型以用户需求为动力，以对象为驱动，适合于面向对象的开发方法。  
在这几种开发过程模型中，原型模型不适宜大规模软件的开发。  


## 第30题 ##

**正确答案：D. 喷泉**  
本题考查软件开发过程模型的基础知识。  
根据题干描述，合适的开发过程模型为喷泉模型。  


## 第31题 ##

**正确答案：D. 易分析性**  
本题考查软件质量的基础知识。  
ISO/IEC软件质量模型由三个层次组成：第一层是质量特性，第二层是质量子特性，第三层是度量指标。易使用性是指与为使用所需的努力和由一组规定或隐含的用户对这样使用所做的个别评价有关的一组属性。其子特性包括易理解性、易学性、易操作性。  


## 第32题 ##

**正确答案：B. 每个子系统采用何种数据结构和核心算法**  
本题考查软件设计的基础知识。  
子系统结构设计中，重点关注如何划分模块，子系统之间以及模块之间的数据和调用关系，模块结构质量等这些粗粒度的问题；而对每个模块内部进行设计时，才需要考虑采用的数据结构以及处理的算法。  


## 第33题 ##

**正确答案：D. 决策树**  
本题考查结构化分析方面的基础知识。  
在结构化分析中，用数据流图对软件功能建模，加工是数据流的一个重要要素，可以用多种方式描述，如流程图、NS盒图等，其中决策树和决策表适于用来表示加工中涉及多个逻辑条件的情况。  


## 第34题 ##

**正确答案：B. 软件维护**  
本题考查软件工程过程及软件工具的基础知识。  
逆向工程从源代码得到软件系统的规格说明和设计信息，属于软件维护阶段行为，因此逆向工程工具属于软件维护工具。  


## 第35~36题 ##

**正确答案：B. 4**  
本题考查软件测试的基础知识。  
画出该代码的流程图，如下：  
![7da4f144eb0a401d81ca3020f4a3f57b.jpg][]  
要满足条件覆盖，要求三个判断框的Y和N至少要经过一次，即1Y2Y；1Y2N；1N3Y；1N3N，至少需要4个测试用例。  
McCabe度量法是一种基于程序控制流的复杂性度量方法，环路复杂性为V(G)=m-n+2，图中m=9，n=7，V(G)=9-7+2=4。  
**正确答案：D. 4**  
本题考查软件测试的基础知识。  
画出该代码的流程图，如下：  
![7da4f144eb0a401d81ca3020f4a3f57b.jpg][]  
要满足条件覆盖，要求三个判断框的Y和N至少要经过一次，即1Y2Y；1Y2N；1N3Y；1N3N，至少需要4个测试用例。  
McCabe度量法是一种基于程序控制流的复杂性度量方法，环路复杂性为V(G)=m-n+2，图中m=9，n=7，V(G)=9-7+2=4。  


## 第37~38题 ##

**正确答案：A. 消息**  
本题考查面向对象的基本知识。  
在面向对象系统中，对象是基本的运行时的实体，它既包括数据(属性)，也包括作用于数据的操作(行为)。所以，一个对象把属性和行为封装为一个整体。封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。从程序设计者来看，对象是一个程序模块；从用户来看，对象为他们提供了所希望的行为。在对象内的操作通常叫做方法。一个对象通常可由对象名、属性和方法三部分组成。  
一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性，这些对象共享这些行为和属性。  
**正确答案：D. 属性和行为**  
本题考查面向对象的基本知识。  
在面向对象系统中，对象是基本的运行时的实体，它既包括数据(属性)，也包括作用于数据的操作(行为)。所以，一个对象把属性和行为封装为一个整体。封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。从程序设计者来看，对象是一个程序模块；从用户来看，对象为他们提供了所希望的行为。在对象内的操作通常叫做方法。一个对象通常可由对象名、属性和方法三部分组成。  
一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性，这些对象共享这些行为和属性。  


## 第39题 ##

**正确答案：B. 覆盖（重置）**  
本题考查面向对象和统一建模语言(UML)的基本知识。  
一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性。有些类之间存在一般和特殊关系，即一些类是某个类的特殊情况，某个类是一些类的一般情况，即继承关系。继承是父类和子类之间共享数据和方法的机制。父类描述了这些子类的公共属性和方法。一个子类可以继承它的父类(或祖先类)中的属性和方法，这些属性和操作在子类中不必定义，子类中还可以定义自己的属性和方法，也可以重新定义父类中己经定义的方法，即重置或覆盖(overriding)。UML类图中，如果父类中已有方法名在子类中不出现，表示子类继承父类中的方法；如果父类中已有方法名在子类中出规了，就表示子类在继承父类接口定义的前提下，用适 合于自己要求的 实现去置换父类中的相应实现，即覆盖了父类中的方法。  


## 第40~42题 ##

**正确答案：A. 参与者**  
本题考查统一建模语言(UML)的基本知识。  
用例图(use case diagram)展现了一组用例、参与者(Actor)以及它们之间的关系。用例图通常包括用例、参与者，以及用例之间的扩展关系(&lt;&lt;extend&gt;&gt;)和包含关系(&lt;&lt;include&gt;&gt;)，参与者和用例之间的关联关系，用例与用例以及参与者与参与者之间的泛化关系。如下图所示。  
![2f081723b6a8452cbcdae0f4b148d241.jpg][]  
用例图用于对系统的静态用例视图进行建模，主要支持系统的行为，即该系统在它的周边环境的语境中所提供的外部可见服务。  
**正确答案：C. 泛化关系**  
本题考查统一建模语言(UML)的基本知识。  
用例图(use case diagram)展现了一组用例、参与者(Actor)以及它们之间的关系。用例图通常包括用例、参与者，以及用例之间的扩展关系(&lt;&lt;extend&gt;&gt;)和包含关系(&lt;&lt;include&gt;&gt;)，参与者和用例之间的关联关系，用例与用例以及参与者与参与者之间的泛化关系。如下图所示。  
![2f081723b6a8452cbcdae0f4b148d241.jpg][]  
用例图用于对系统的静态用例视图进行建模，主要支持系统的行为，即该系统在它的周边环境的语境中所提供的外部可见服务。  
**正确答案：B. 用例**  
本题考查统一建模语言(UML)的基本知识。  
用例图(use case diagram)展现了一组用例、参与者(Actor)以及它们之间的关系。用例图通常包括用例、参与者，以及用例之间的扩展关系(&lt;&lt;extend&gt;&gt;)和包含关系(&lt;&lt;include&gt;&gt;)，参与者和用例之间的关联关系，用例与用例以及参与者与参与者之间的泛化关系。如下图所示。  
![2f081723b6a8452cbcdae0f4b148d241.jpg][]  
用例图用于对系统的静态用例视图进行建模，主要支持系统的行为，即该系统在它的周边环境的语境中所提供的外部可见服务。  


## 第43题 ##

**正确答案：C. 组件图**  
本题考查统一建模语言(UML)的基本知识。  
UML中提供了多种建模系统的图，体现系统的静态方面和动态方面。类图(class diagram)展现了一组对象、接口、协作和它们之间的关系。在面向对象系统的建模中所建立的最常见的图就是类图。类图给出系统的静态设计视图。部署图(deployment diagram)是用来对面向对象系统的物理方面建模的方法，展现了运行时处理结点以及其中构件(制品)的配置。部署图对系统的静态部署视图进行建模，它与组件图(构件图)相关。组件图或构件图(component diagram)展现了一组构件之间的组织和依赖，如题中的图所示。组件图或构件图专注于系统的静态实现视图。它与类图相关，通常把构件映射为一个或多个类、接口或协作。UML部署图经常被认为是一个网络图。  


## 第44题 ##

**正确答案：D. 单例类提供一个创建一系列相关或相互依赖对象的接口**  
本题考査设计模式的基本概念。   
Singleton(单例)设计模式是一种创建型模式，其意图是保证一个类仅有一个实例，并提供一个访问这个唯一实例的全局访问点。单例模式适用于当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时，以及当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。  


## 第45~47题 ##

**正确答案：D. 装饰器(Decorator)**  
本题考查设计模式的基本概念。每种设计模式都有特定的意图，描述一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心，使该方案能够重用而不必做重复劳动。  
组合(Composite)模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。适用于：想表示对象的部分-整体层次结构；希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。  
外观(Facade)模式为子系统中的一组接口提供一个一致的界面，Fapde模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。适用于：要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂；客户程序与抽象类的实现部分之间存在着很大的依赖性；当需要构建一个层次结构的子系统时，使用Fapde模式定义子系统中每层的入口点。  
享元(Flyweight)模式运用共享技术有效地支持大量细粒度的对象。适用于：一个应用程序使用了大量的对象；完全由于使用大量的对象，造成很大的存储开销；对象的大多数状态都可变为外部状态；如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象：应用程序不依赖于对象标识。  
装饰器(Decorator)模式描述了以透明围栏来支持修饰的类和对象的关系，动态地给一个对象添加一些额外的职责，从增加功能的角度来看，装饰器模式相比生成子类更加灵活。适用于：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；处理那些可以撤销的职责；当不能采用生成子类的方式进行扩充时。  
工厂方法(Factory Method)定义一个用于创建对象的接口，让子类决定将哪-个类实例化，使一个类的实例化延迟到其子类。适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。  
观察者(Observer)模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。适用于：当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用；当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时；当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。  
中介者(Mediator)用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。适用于：一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解；一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象；想定制一个分布在多个类中的行为，而又不想生成太多的子类。欲使一个后端数据模型能够被多个前端用户界面连接，采用中介者模式最合适。  
**正确答案：A. 工厂方法（Factory Method）**  
本题考查设计模式的基本概念。每种设计模式都有特定的意图，描述一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心，使该方案能够重用而不必做重复劳动。  
组合(Composite)模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。适用于：想表示对象的部分-整体层次结构；希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。  
外观(Facade)模式为子系统中的一组接口提供一个一致的界面，Fapde模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。适用于：要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂；客户程序与抽象类的实现部分之间存在着很大的依赖性；当需要构建一个层次结构的子系统时，使用Fapde模式定义子系统中每层的入口点。  
享元(Flyweight)模式运用共享技术有效地支持大量细粒度的对象。适用于：一个应用程序使用了大量的对象；完全由于使用大量的对象，造成很大的存储开销；对象的大多数状态都可变为外部状态；如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象：应用程序不依赖于对象标识。  
装饰器(Decorator)模式描述了以透明围栏来支持修饰的类和对象的关系，动态地给一个对象添加一些额外的职责，从增加功能的角度来看，装饰器模式相比生成子类更加灵活。适用于：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；处理那些可以撤销的职责；当不能采用生成子类的方式进行扩充时。  
工厂方法(Factory Method)定义一个用于创建对象的接口，让子类决定将哪-个类实例化，使一个类的实例化延迟到其子类。适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。  
观察者(Observer)模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。适用于：当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用；当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时；当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。  
中介者(Mediator)用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。适用于：一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解；一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象；想定制一个分布在多个类中的行为，而又不想生成太多的子类。欲使一个后端数据模型能够被多个前端用户界面连接，采用中介者模式最合适。  
**正确答案：D. 中介者(Mediator)**  
本题考查设计模式的基本概念。每种设计模式都有特定的意图，描述一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心，使该方案能够重用而不必做重复劳动。  
组合(Composite)模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。适用于：想表示对象的部分-整体层次结构；希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。  
外观(Facade)模式为子系统中的一组接口提供一个一致的界面，Fapde模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。适用于：要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂；客户程序与抽象类的实现部分之间存在着很大的依赖性；当需要构建一个层次结构的子系统时，使用Fapde模式定义子系统中每层的入口点。  
享元(Flyweight)模式运用共享技术有效地支持大量细粒度的对象。适用于：一个应用程序使用了大量的对象；完全由于使用大量的对象，造成很大的存储开销；对象的大多数状态都可变为外部状态；如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象：应用程序不依赖于对象标识。  
装饰器(Decorator)模式描述了以透明围栏来支持修饰的类和对象的关系，动态地给一个对象添加一些额外的职责，从增加功能的角度来看，装饰器模式相比生成子类更加灵活。适用于：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；处理那些可以撤销的职责；当不能采用生成子类的方式进行扩充时。  
工厂方法(Factory Method)定义一个用于创建对象的接口，让子类决定将哪-个类实例化，使一个类的实例化延迟到其子类。适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。  
观察者(Observer)模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。适用于：当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用；当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时；当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。  
中介者(Mediator)用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。适用于：一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解；一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象；想定制一个分布在多个类中的行为，而又不想生成太多的子类。欲使一个后端数据模型能够被多个前端用户界面连接，采用中介者模式最合适。  


## 第48题 ##

**正确答案：C. 动态的语义错误**  
本题考查程序语目基础知识。  
程序已经开始运行，说明编译时无错误，因此不是语法错误和词法错误，编译时发现的语义错误称为静态的语义错误。运行时陷入死循环属于动态语义错误。  


## 第49题 ##

**正确答案：D. 其可识别的非空0、1序列中结尾字符是1**  
本题考查程序语言基础知识。  
若存在一条从初态到某一终止状态的路径，且这条路径上所有弧的标记符连接成的字符串等于ω，则称ω可由NFA识别(接受或读出)。  
对于题中给出的NFA，其初态为q0，q0上的自回路表示识别零个或多个1，接下来识别出一个0时进入状态q1，q1上的自回路表示识别零个或多个0，接下来识别出1个1之后再回到q0。  
例如，该自动机可识别空串(因为q0既是初态，也是终态)、01、00001、101、1、11、111、1111等。  
01的识别路径为q0\-&gt;q1\-&gt;q0  
00001的识别路径为q0\-&gt;q1\-&gt;q1\-&gt;q1\-&gt;q1\-&gt;q0  
101的识别路径为q0\-&gt;q0\-&gt;q-&gt;q1\-&gt;q0  
1的识别路径为q0\-&gt;q0  
11的识别路径为q0\-&gt;q0\-&gt;q0  
111的识别路径为q0\-&gt;q0\-&gt;q0\-&gt;q0  
1111的识别路径为q0\-&gt;q0\-&gt;q0\-&gt;q0\-&gt;q0  
识別字符串时必须从初始状态q0出发，并回到状态q0，因此对于仅由1构成的任意长度的串，在识别过程中不会离开q0。当识别出一个0而离开q0后就进入q1，此后的字符若全部为0，则会一直在q1，直到识别出一个1而回到q0，因此除了空串，该NFA识别的字符串必须以1结尾。  


## 第50题 ##

**正确答案：A. 33**  
本题考查程序语言基础知识。  
若函数调用时采用传值方式，则是将实参的值传给形参，再执行被调用的函数，对形参的修改不影响实参。若采用传引用方式，则是将实参的地址传递给形参，本质上是通过间接访问的方式修改实参，也可以简化理解为：在被调用函数中对形参的修改等同于是对实参进行修改。  
当函数t和f运行时，其每个形参和局部变量都有各自的存储单元，下面图中矩形框表示存储单元。  
如题中所述，调用t时传递给其形参x的值为5。因此函数t被调用而执行时，在执行函数调用f(x，a)之前，其形参x和局部变量a的值如下图(a)所示。  
执行函数调用f(x，a)时，t中x的值传给f的形参r、a的地址传给f的形参s，如下图(b)所示。  
![fe3d02eabcef4236a7e57baae6f1de4b.jpg][]  
在f执行时，其局部变量x的值由运算“X=2\*s+1”改为33，其中运算时可理解为s提供了t的局部变量a的值(是由间接访问机制实现的)。接下来的运算为“S=x+r”，也就是将x的值(即33)与r的值(即5)相加得到38，然后(通过间接访问)存入t的局部变量a，结果如下图(c)、(d)所示。之后运算“r=x-1”将r的值改为32，结果如下图(e)所示。  
![1207b7a8270b4b9d91cffa34f8861984.jpg][]  
当函数f运行结束并返回函数t后，函数f的运行空间将由系统撤销，接下来运算“a-x”产生的值为33(即38-5)，因此函数t的返回值为33。  


## 第51题 ##

**正确答案：B. 视图、基本表和存储文件**  
本题考查数据库的基本概念。  
数据库通常采用三级模式结构，其中，视图对应外模式、基本表对应模式、存储文件对应内模式。  


## 第52题 ##

**正确答案：C. 将实体的码分别和每个多值属性独立构成一个关系模式**  
本题考查对数据库应用系统设计中逻辑结构设计的掌握。  
在数据库设计中，将E-R图转换为关系模式是逻辑设计的主要内容。转换中将实体转换为关系模式，对实体中的派生属性不予考虑，组合属性只取各组合分量，若包含多值属性，通常一个实体对应一个关系模式。对实体中的多值属性，取实体的码和多值属性构成新增的关系模式，且该新增关系模式中，实体的码多值决定多值属性，属于平凡的多值依赖，关系属于4NF。  


## 第53~54题 ##

**正确答案：D. 逻辑透明**  
本题考查分布式数据库基本概念。  
分片透明是指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的，复制透明是指采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的。位置透明是指用户无须知道数据存放的物理位置，逻辑透明，即局部数据模型透明，是指用户或应用程序无须知道局部场地使用的是哪种数据模型。  
**正确答案：A. 分片透明**  
本题考查分布式数据库基本概念。  
分片透明是指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的，复制透明是指采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的。位置透明是指用户无须知道数据存放的物理位置，逻辑透明，即局部数据模型透明，是指用户或应用程序无须知道局部场地使用的是哪种数据模型。  


## 第55~56题 ##

**正确答案：C. A3A5**  
本题主要考核关系模式规范化方面的相关知识。  
根据函数依赖集F可知属性A3和A5只出现在函数依赖的左部，故必为候选关键字属性，又因为A3A5可以决定关系R中的全部属性，故关系模式R的一个主键是A3A5。  
**正确答案：B. 2NF**  
本题主要考核关系模式规范化方面的相关知识。  
根据函数依赖集F可知属性A3和A5只出现在函数依赖的左部，故必为候选关键字属性，又因为A3A5可以决定关系R中的全部属性，故关系模式R的一个主键是A3A5。  


## 第57题 ##

**正确答案：B. 出队序列和出栈序列一定相同**  
本题考查数据结构基础知识。  
栈和队列都是线性的数据结构。栈的操作要求是入桟和出栈都在表尾进行，即在栈中有多个元素时，后进去的元素先出来，特点是后进先出，元素入栈的顺序与出桟的顺序可以相同也可以不同。而队列的修改要求是在队尾加入元素，在队头删除元素，特点是先进先出，元素的入队顺序与出队顺序一定相同。  
将一个栈和队列连接后，进出队列的元素顺序是相同的，而进入队列的元素顺序正是从栈中出来的元素顺序，因此，正确的叙述为出队序列与出栈序列一定相同。  


## 第58题 ##

**正确答案：A. k=2i+j-2**  
本题考查数据结构基础知识。  
解答该问题需先计算排列在Aij之前的元素个数。  
在按行存储方式下，存储在Aij之前的元素分为i-1行，除第1行外，每行3个元素。在第i行上，Aij之前的元素个数分为三种情况：i&gt;j时为0个，i=j时有1个，i&lt;j时为2个，概括为j-i+1个。  
综上，排列在Aij之前的元素个数为(i-1)x3-1+j-i+1，即2i+j-3。  
由于数组B的下标从1开始，所以k=2i+j-3+1。  


## 第59题 ##

**正确答案：D. RDL**  
本题考查数据结构基础知识。  
由于序列的第一个元素是结点7，最后一个元素是结点1，因此，左右子树的遍历顺序是先右后左。观察结点7的左子树，遍历顺序为654，因此是中序遍历过程。所以答案为RDL。  


## 第60题 ##

**正确答案：B. A\[28\]、A\[14\]、A\[21\]、A\[17\]**  
本题考查数据结构基础知识。  
对55个元素构成的有序表进行折半查找时，可用判定树描述查找过程由于A\[19\]小于中间元素A\[28\]，所以判定树的左分支如下图所示。从中可知，查找过程中参与比较的元素分别为A\[28\]、A\[14\]、A\[21\]、A\[17\]、A\[19\]。  


## 第61题 ##

**正确答案：A. e**  
本题考查数据结构基础知识。  
通过一个例子说明。某有向图及其邻接矩阵如下图所示。  
![cec7170efe0749cdb906dc9c471aa2c0.jpg][]  
邻接矩阵中的每个非零元素都表示一条弧，所以非零元素数目为弧的个数e。  


## 第62~63题 ##

**正确答案：D. θ(n3)**  
本题考查算法分析的基础知识。  
根据主方法，先计算算法A的时间复杂度，a=8，b=2，logba=log28=3，而f(n)=n2，因此时间复杂度为θ(n3)。然后计算算法B的时间复杂度，a=X，b=4，logba=log4X，而f(n)=n2，若算法B和算法A的效率一样，则X应该为64(log464=3)，而现在要使得B比A快，则X应该比64小，因此最大的整数应该为63。  
**正确答案：C. 63**  
本题考查算法分析的基础知识。  
根据主方法，先计算算法A的时间复杂度，a=8，b=2，logba=log28=3，而f(n)=n2，因此时间复杂度为θ(n3)。然后计算算法B的时间复杂度，a=X，b=4，logba=log4X，而f(n)=n2，若算法B和算法A的效率一样，则X应该为64(log464=3)，而现在要使得B比A快，则X应该比64小，因此最大的整数应该为63。  


## 第64~65题 ##

**正确答案：A. 插入**  
本题考查算法设计和排序的基础知识。  
排序是一类最基本的操作，因此要求考生熟悉一些典型的排序算法，包括其算法思想、时空复杂度以及应用场合。若数据基本有序，插入排序应该是最佳选择，输入数据是否有序对归并和计数排序算法并没有影响。对传统的快速排序算法，输入数据有序反而使其效率最低。若关键字取值范围较小，则计数排序是最佳选择，因为在该情况下，该算法的时间复杂度为线性时间。  
**正确答案：D. 计数**  
本题考查算法设计和排序的基础知识。  
排序是一类最基本的操作，因此要求考生熟悉一些典型的排序算法，包括其算法思想、时空复杂度以及应用场合。若数据基本有序，插入排序应该是最佳选择，输入数据是否有序对归并和计数排序算法并没有影响。对传统的快速排序算法，输入数据有序反而使其效率最低。若关键字取值范围较小，则计数排序是最佳选择，因为在该情况下，该算法的时间复杂度为线性时间。  


## 第66题 ##

**正确答案：B. 集线器是物理层设备，而网桥是数据链路层设备**  
集线器是物理层设备，相当于在10BASE2局域网中把连接工作站的同轴电缆收拢在一个盒子里，这个盒子只起到接收和发送的功能，可以检测发送冲突，但不能识别数据链路层的帧。网桥是数据链路层设备，它可以识别数据链路层MAC地址，有选择地把帧发送到输出端口，网桥也可以有多个端口，如果网桥端口很多，并配置了加快转发的硬件，就成为局域网交换机。  


## 第67题 ##

**正确答案：B. Client/Server**  
本题考查POP3协议及POP3服务器方面的基础知识。  
POP3协议是TCP/IP协议簇中用于邮件接收的协议。邮件客户端通过与服务器之间建立TCP连接，采用Client/Server计算模式来传送邮件。  


## 第68题 ##

**正确答案：C. 可变大小的滑动窗口协议**  
TCP的流量控制采用了可变大小的滑动窗口协议，由接收方指明接收缓冲区的大小(字节数)，发送方发送了规定的字节数后等待接收方的下一次请求。固定大小的滑动窗口协议用在数据链路层的HDLC中。可变大小的滑动窗口协议可以应付长距离通信过程中线路延迟不确定的情况，而固定大小的滑动窗口协议则适合链路两端点之间通信延迟固定的情况。  


## 第69题 ##

**正确答案：D. 主机**  
主机路由的子网掩码是255.255.255.255。网络路由要指明一个子网，所以不可能为全1，默认路由是访问默认网关，而默认网关与本地主机属于同一个子网，其子网掩码也应该与网络路由相同，对静态路由也是同样的道理。  


## 第70题 ##

**正确答案：B. 将分组从一个区域高速地转发到另一个区域**  
在层次化局域网模型中，核心层的主要功能是将分组从一个区域高速地转发到另一个区域。核心层是因特网络的高速骨干，由于其重要性，因此在设计中应该采用冗余组件设计，使其具备高可靠性，能快速适应变化。在设计核心层设备的功能时，应尽量避免使用数据包过滤、策略路由等降低数据包转发处理的特性，以优化核心层获得低延迟和良好的可管理性。  
汇聚层是核心层和接入层的分界点，应尽量将资源访问控制、核心层流量的控制等都在汇聚层实施。汇聚层应向核心层隐藏接入层的详细信息，汇聚层向核心层路由器进行路由宣告时，仅宣告多个子网地址汇聚而形成的一个网络。另外，汇聚层也会对接入层屏蔽网络其他部分的信息，汇聚层路由器可以不向接入路由器宣告其他网络部分的路由，而仅仅向接入设备宣告自己为默认路由。  
接入层为用户提供了在本地网段访问应用系统的能力，接入层要解决相邻用户之间的互访需要，并且为这些访问提供足够的带宽。接入层还应该适当负责一些用户管理功能，包括地址认证、用户认证和计费管理等内容。接入层还负责一些用户信息收集工作，例如用户的IP地址、MAC地址和访问日志等信息。  


## 第71~75题 ##

**正确答案：D. strict**  
在这个世界上，似乎我们有太多的事情要去做，有太多的事情要去思考，那么需要做的最后一件事就是必须学习新事物。  
而用例恰恰可以解决带有需求的问题：如果具有严格声明的需求，则很难描述事件的步骤和序列。  
简单地说，用例可以将事件序列的说明放在一起，引导系统完成有用的任务。正如听起来一样简单——这很重要。在面对很多需求的时候，通常不太可能理解需求的作者真正想要系统做什么。在前面的例子中，通过指定特定行为发生的时间和条件，用例减少了需求的不确定性。这样的话，行为的顺序就可以当作是一种需求。用例特别适用于捕捉这类需求。尽管听起来可能很简单，但事实情况是由于常规的需求捕捉方法所侧重的是声明需求和“应该怎么样”的陈述，因此完全无法捕捉系统行为的动态方面。用例是一种简单而有效的表达系统行为的方式，使用这种方式所有参与者都很容易理解。  
但是与任何事物一样，用例也存在自己的问题——在用例非常有用的同时，人们也可能误用它，结果就产生了比原来更为糟糕的问题。因此重点在于：如何有效地使用用例，而又不会产生出比原来更严重的问题。  
**正确答案：A. impossible**  
在这个世界上，似乎我们有太多的事情要去做，有太多的事情要去思考，那么需要做的最后一件事就是必须学习新事物。  
而用例恰恰可以解决带有需求的问题：如果具有严格声明的需求，则很难描述事件的步骤和序列。  
简单地说，用例可以将事件序列的说明放在一起，引导系统完成有用的任务。正如听起来一样简单——这很重要。在面对很多需求的时候，通常不太可能理解需求的作者真正想要系统做什么。在前面的例子中，通过指定特定行为发生的时间和条件，用例减少了需求的不确定性。这样的话，行为的顺序就可以当作是一种需求。用例特别适用于捕捉这类需求。尽管听起来可能很简单，但事实情况是由于常规的需求捕捉方法所侧重的是声明需求和“应该怎么样”的陈述，因此完全无法捕捉系统行为的动态方面。用例是一种简单而有效的表达系统行为的方式，使用这种方式所有参与者都很容易理解。  
但是与任何事物一样，用例也存在自己的问题——在用例非常有用的同时，人们也可能误用它，结果就产生了比原来更为糟糕的问题。因此重点在于：如何有效地使用用例，而又不会产生出比原来更严重的问题。  
**正确答案：B. conventional**  
在这个世界上，似乎我们有太多的事情要去做，有太多的事情要去思考，那么需要做的最后一件事就是必须学习新事物。  
而用例恰恰可以解决带有需求的问题：如果具有严格声明的需求，则很难描述事件的步骤和序列。  
简单地说，用例可以将事件序列的说明放在一起，引导系统完成有用的任务。正如听起来一样简单——这很重要。在面对很多需求的时候，通常不太可能理解需求的作者真正想要系统做什么。在前面的例子中，通过指定特定行为发生的时间和条件，用例减少了需求的不确定性。这样的话，行为的顺序就可以当作是一种需求。用例特别适用于捕捉这类需求。尽管听起来可能很简单，但事实情况是由于常规的需求捕捉方法所侧重的是声明需求和“应该怎么样”的陈述，因此完全无法捕捉系统行为的动态方面。用例是一种简单而有效的表达系统行为的方式，使用这种方式所有参与者都很容易理解。  
但是与任何事物一样，用例也存在自己的问题——在用例非常有用的同时，人们也可能误用它，结果就产生了比原来更为糟糕的问题。因此重点在于：如何有效地使用用例，而又不会产生出比原来更严重的问题。  
**正确答案：C. dynamics**  
在这个世界上，似乎我们有太多的事情要去做，有太多的事情要去思考，那么需要做的最后一件事就是必须学习新事物。  
而用例恰恰可以解决带有需求的问题：如果具有严格声明的需求，则很难描述事件的步骤和序列。  
简单地说，用例可以将事件序列的说明放在一起，引导系统完成有用的任务。正如听起来一样简单——这很重要。在面对很多需求的时候，通常不太可能理解需求的作者真正想要系统做什么。在前面的例子中，通过指定特定行为发生的时间和条件，用例减少了需求的不确定性。这样的话，行为的顺序就可以当作是一种需求。用例特别适用于捕捉这类需求。尽管听起来可能很简单，但事实情况是由于常规的需求捕捉方法所侧重的是声明需求和“应该怎么样”的陈述，因此完全无法捕捉系统行为的动态方面。用例是一种简单而有效的表达系统行为的方式，使用这种方式所有参与者都很容易理解。  
但是与任何事物一样，用例也存在自己的问题——在用例非常有用的同时，人们也可能误用它，结果就产生了比原来更为糟糕的问题。因此重点在于：如何有效地使用用例，而又不会产生出比原来更严重的问题。  
**正确答案：A. misapplied**  
在这个世界上，似乎我们有太多的事情要去做，有太多的事情要去思考，那么需要做的最后一件事就是必须学习新事物。  
而用例恰恰可以解决带有需求的问题：如果具有严格声明的需求，则很难描述事件的步骤和序列。  
简单地说，用例可以将事件序列的说明放在一起，引导系统完成有用的任务。正如听起来一样简单——这很重要。在面对很多需求的时候，通常不太可能理解需求的作者真正想要系统做什么。在前面的例子中，通过指定特定行为发生的时间和条件，用例减少了需求的不确定性。这样的话，行为的顺序就可以当作是一种需求。用例特别适用于捕捉这类需求。尽管听起来可能很简单，但事实情况是由于常规的需求捕捉方法所侧重的是声明需求和“应该怎么样”的陈述，因此完全无法捕捉系统行为的动态方面。用例是一种简单而有效的表达系统行为的方式，使用这种方式所有参与者都很容易理解。  
但是与任何事物一样，用例也存在自己的问题——在用例非常有用的同时，人们也可能误用它，结果就产生了比原来更为糟糕的问题。因此重点在于：如何有效地使用用例，而又不会产生出比原来更严重的问题。  



[7666859618ed4f8198968671f37d3fa7.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/第20题/7666859618ed4f8198968671f37d3fa7.jpg
[254621fbb90b4204a4f0c0b98ff69f84.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/第25题/254621fbb90b4204a4f0c0b98ff69f84.jpg
[8a7b8113e717450cbeda90110381c0e0.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/第25题/8a7b8113e717450cbeda90110381c0e0.jpg
[7da4f144eb0a401d81ca3020f4a3f57b.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/第35题/7da4f144eb0a401d81ca3020f4a3f57b.jpg
[2f081723b6a8452cbcdae0f4b148d241.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/第40题/2f081723b6a8452cbcdae0f4b148d241.jpg
[fe3d02eabcef4236a7e57baae6f1de4b.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/第50题/fe3d02eabcef4236a7e57baae6f1de4b.jpg
[1207b7a8270b4b9d91cffa34f8861984.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/第50题/1207b7a8270b4b9d91cffa34f8861984.jpg
[cec7170efe0749cdb906dc9c471aa2c0.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/第61题/cec7170efe0749cdb906dc9c471aa2c0.jpg
