---  
title: 2016年下半年  
# icon: gears  
order: 985  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1：客户服务助理，E2：客户，E3：经纪人。  
  
本题考查采用结构化方法进行系统分析与设计，主要考查数据流图（DFD）的应用，是传统的考题，考点与往年类似，要求考生细心分析题目中所描述的内容。本题题干描述较短，更易于分析。  
DFD是面向数据流建模的结构化分析与设计方法的重要工具，是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。DFD将系统建模成输入、加工（处理）、输出的模型，即流入软件的数据对象、经由加工的转换、最后以结果数据对象的形式流出软件，并采用分层的方式自顶向下建模各层数据流图，来表示不同详细程度的模型。  
上下文数据流图（顶层DFD）通常用来确定系统边界，将待开发系统看作一个大的加工，然后根据哪些外部实体为系统提供输入数据流，以及哪些外部实体接受系统发送的数据流，建模出的上下文图中唯一的一个加工和一些外部实体，以及这两者之间的输入输出数据流。系统边界的变化可能使外部实体成为系统内部加工或内部加工变为外部实体。  
在上下文图中确定的系统外部实体以及与外部实体的输入输出数据流的基础上，将上下文DFD中的加工分解成多个加工，识别这些加工的输入输出数据流，使得所有上下文DFD中的输入数据流，经过这些加工之后变换成上下文DFD的输出数据流，建模0层DFD。根据0层DFD中加工的复杂程度进一步建模加工的内容。  
在建模分层DFD时，根据需求情况可以将数据存储建模在不同层次的DFD中。建模时，需要注意加工和数据流的正确使用，一个加工必须既有输入又有输出；数据流必须和加工相关，即从加工流向加工、数据源流向加工或加工流向数据源。注意要在绘制下层数据流图时要保持父图与子图平衡。父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一条数据流。  
本问题考查的是上下文DFD，要求确定外部实体。在上下文DFI）中，待系统名称“证券交易平台”作为唯一加工的名称，外部实体为这个唯一加工提供输入数据流或者接收其输出数据流。通过考查系统的主要功能，发现系统中涉及到客户服务助理、客户和经纪人，没有提到其他与系统交互的外部实体。根据描述（1）中“客户服务助理提交的开户信息”，（2）中“客户可以向其账户中存款”、（3）中“客户可以从其账户中取款”，（1）中“客户和经纪人均可以进行证券交易”，以及（5）中“将交易明细返回给客户”等信息，对照图1-1，从而即可确定E1为“客户服务助理”实体，E2为“客户”实体，E3为“经纪人”实体。  
  
【问题2】  
D1：客户记录，D2：账户记录，D3：交易记录。  
  
本问题要求确定图1-2中0层数据流图中的数据存储。重点分析说明中与数据存储有关的描述。说明（1）中“并将客户信息存入客户记录中，账户信息（余额等）存入账户记录中”，可知D1为客户记录、D2为账户记录；说明（5）中“平台从交易记录中读取交易信息”，可知D3为交易记录。  
  
【问题3】  
![bdbb84211b2b46c9b6686f80414c3d5a.jpg][]  
  
本问题要求补充缺失的数据流及其起点和终点。对照图1-1和图1-2的输入、输出数据流，数量和名称均相同，所以需要从内部确定缺失的数据流。  
考查说明中的功能，先考查说明（2）/（3）中“客户可以向其账户中存款/取款，根据存款金额修改账户余额”，加工存款与取款分别需要有到数据存储账户记录（D2）标识余额的数据流，图1-2中加工存款与取款没有到数据存储账户记录的数据流。再考査说明（4）中“客户和经纪人均可以进行证券交易（客户通过在线方式，经纪人通过电话），将交易信息存入交易记录中”，图1-2中加工证券交易（在线）和证券交易（电话）分别需要有到交易记录标识交易信息的数据流。  
  
【问题4】  
在图1-1中，将“证券交易中心”作为外部实体，添加从“证券交易平台”到此外部实体的数据流“交易信息”。  
在图1-2中，将证券交易中心作为外部实体，添加从加工“证券交易（在线）”到此外部实体的数据流“交易信息”，添加从加工“证券交易（电话）”到此外部实体的数据流“交易信息”。  
  
DFD中，外部实体可以是用户，可以是其他与本系统交互的系统。如果某功能交互的是外部系统，本题中证券交易通常是在证券交易中心完成的，即证券交易中心。此时证券交易中心即为外部实体，而非本系统内部加工，因此需要对图1-1和图1-2进行修改，添加外部实体“证券交易中心”，并将数据流交易信息的终点全部改为证券交易中心。在图1-1中，将“证券交易中心”作为外部实体，添加从“证券交易平台”到此外部实体的数据流“交易信息”。在图1-2中，将“证券交易中心”作为外部实体，添加从加工“证券交易（在线）”到此外部实体的数据流“交易信息”，添加从加工“证券交易（电话）”到此外部实体的数据流“交易信息”。  


## 第2题 ##

【问题1】  
完善后的实体联系图如下所示（所补苯的联系和类型如虚线所示）：  
![9f1a9d4cbbed4744b9053899f1ca1a53.jpg][]  
  
本题考查数据库系统中实体联系模型（E-R模型）和关系模式设计方面的基础知识。  
①根据题意“每个部门可以有多名员工，每名员工只属于一个部门”，所以部门和员工之间有一个“所属”联系，联系类型为1：\*。  
②根据题意“每个部门有一名经理，只负责管理本部门的事务”，所以部门和经理之间有一个“负责”联系，联系类型为1：1。  
③根据题意“一个客户可以有多个预订申请，但一个预订申请对应唯一的一个客户号”，所以客户和预订申请之间有一个“预订”联系，联系类型为1：\*。  
④根据题意“一个业务员可以安排多个预订申请，一个预订申请只由一个业务员安排，而且可安排多个同类型的客房”，即一份预订申请可以预订多间同类型的客房，所以业务员与客房和预订申请之间的“安排”联系类型为1：\*：\*。  
根据上述分析，完善图2-1所示的实体联系图如图2-2所示。  
![9230673c995a40bcbdf264533a777aca.jpg][]  
  
【问题2】  
（1）  
（a）部门号  
（b）客户号，单位名称  
（c）申请号，客户号  
（d）身份证号，入住时间  
（2）  
“预订申请”关系模式：  
主键为申请号  
外键为客户号  
“安排”关系模式：  
主键为客房号，身份证号，入住时间  
外键为申请号，客房号，业务员  
  
由于部门和员工之间有一个1-2\-8的“所属”联系需要将一端的码“部门号”并入多端，故员工关系模式中的空（a）应填写“部门号”。  
根据题意，客户信息包括客户号、单位名称、联系人、联系电话、联系地址，给定的客户关系模式中，不含客户号、单位名称，故空（b）应填写“客户号，单位名称”。  
由宁预订申请信息包括申请号、客户号、预订入住时间、入住天数、客房类型、客房数量，故空（c）。应填写“申请号，客户号”。  
根据题意“客房号、身份证号和入\_时间唯一标识安排联系的每一个元组”，所以空（d）应填写“身份证号，入住时间”。  
根据题意，“一个申请号对应唯一标识预订申请中的每一个元组”，所以预订申请关系模式的主键为申请号；又因为客户号是蜂户关系的主键，根据外键定义可知，客户号是预订申请关系的外建。  
根据题意“客房号、身份证号和入住时间唯一标识安排联系的每一个元组”，所以安排关系模式的主键为客房号，身份证号，入住时间；外键为申请号，客房号，业务员，因为申请号和客房号为预约申请和客房关案的主键，而“业务员”是员工关系子实体必须参考员工关系的主键“员工号”，所以业务员也是外键。  
  
【问题3】  
存在问题。  
关系模式存在传递依赖，没有达到3NF。  
应将客房关系模式分解为客房1（客房号，客房类型，入住状态）客房2（客房类型，收费标准）。  
  
客房关系模式存在问题。因为客房号为主键，所以客房号可以决定全属性，即客房号→（客房类型，收费标准，入住状态）。又因为客房类型一收费标准，所以该关系模式存在传递依赖，没有达到3NF，应将客房关系模式分解为客房1（客房号，客房类型，入住状态），客房2（客房类型，收费标准）。  


## 第3题 ##

【问题1】  
S1：空闲，S2：准备服务，S3：饮料出售，S4：可购买。  
  
本题属于经典的考题，主要考查面向对象分析与设计的基本概念。在建模方面，本题涉及到了用例图、状态图和类图。用例是描述系统功能需求的一种常用方法，用例规约是创建需求模型，进行系统设计的依据。本题的考点就是由用例规约创建状态图和类图。  
题目说明中已经给出了自动售货机的4个状态分别是：“空闲”状态、“准备服务”状态、“可购买”状态以及“饮料出售”状态。解答本题需要根据用例规约推出这4个状态之间的迁移关系，这样才能与图3-2中的状态S1~S4对应。  
首先从状态图的初始状态“●”开始，S1代表的就是自动售货机的初始状态。在上述4个状态中，只有在“空闲”下，才能开始一次售卖，所以S1对应的是“空闲”状态。  
根据S2相关的事件来看，在该状态时，自动售货机在接收顾客的请求（顾客选择的饮料以及投入的硬币），因此应对应“准备服务”状态。  
状态S3有一个自迁移事件“计算找零”，根据说明和用例规约可知，饮料出售之后进行找零，所以S3对应“饮料出售”状态。S4则对应“可购买”状态。  
  
【问题2】  
E1：所选购的饮料数量不足  
E2：选择饮料\[硬币足够购买饮料\]  
E3：所选购的饮料数量足够/推出饮料  
E4：取走饮料/找零并清空硬币器  
  
确定了状态图中的各个状态，接下来就需要进行状态之间迁移事件的获取。E2是从“准备服务”状态变换到“可购买”状态的事件，“选择饮料\[硬币不足\]”时仍然停留在“准备服务”状态，对应用例规约中的2a；根据用例规约若硬币足够则进入下一步，所以E2所对应的事件是“选择饮料\[硬币足够购买饮料\]”。  
E1事件的触发将使得自动售货机从“可购买”状态变换到“准备服务”状态，对应用例规约中的3a，所以E1对应的事件应是“所选购的饮料数量不足”。  
E3事件的触发将使得自动售货机从“可购买”状态年移到“饮料出售”状态：。根据说明，能够售出饮料必须满足两个条件：该饮料数量，足够以及顾客投入的硬币足够。硬帀是否足够以及饮料数量不足在状态S2已经进行了判断，因此E3对应的事件应是“所选购的饮料数量足够/推出饮料”。  
E4对应的事件是自动售货机完成售卖，回到“空闲”状态时需处理的事件，根据说明可知，E4对应的事件应是“取走饮料/找零并清空硬币器”。  
  
【问题3】  
C1：自动售货机 C2：硬币器 C3：饮料储存仓 C4：硬币 C5：饮料  
或者  
C1：自动售货机 C2：饮料储存仓 C3：硬币器 C4：饮料 C5：硬币  
  
  
本题要求根据说明和用例约创建对应的类模型。根据说明和用例规约可知自动售货机有几个重要的组成元素：饮料、硬币、硬币器和饮料存储仓。1台自动售货机有1个硬币器、1个饮料存储仓；硬币器可以接收多枚硬币，饮料存储仓中可以容纳多种饮料。由此可知，图3-3中的两个0..\*聚集关系应该分别对应“硬币器-硬币”和“饮料存储仓-饮料”这两对“部分-整体”关系；而C1就是自动售货机。  


## 第4题 ##

【问题1】  
（1）j&lt;ls  
（2）t\[i\]==s\[j\];  
（3）j=next\[j\]  
（4）i-j+1  
  
本题考查算法设计与分析以及用C程序设计语言实现算法的能力。  
KMP算法是一个非常经典的模式匹配算法。其核心思想是核心思想：匹配过程中字符对不相等时，不需回溯主串，而是利用已经得到的部分匹配结果将模式向右滑动尽可能远的一段距离继续比较。滑动的距离由next数组给出。该算法提出之后，有一些改进的思想，使得next数组的计算有多种方式。本题干不需要考生考虑如何计算next数组，已经直接给出计算该数组的C代码。只需要根据已经计算的next数组进行模式匹配即可。  
在C函数kmp中，while循环是判断串s和t是否还有字符，因此空（1）处应填写“j&lt;ls”。根据题干描述，“如果j=-1或者t\[i\]==s\[j\]，则将i和j分别加1”，则空（2）处填入“t\[i\]==s\[j\]”，空（3）处是“否则，将j向右滑动到next\[j\]的位置，即j=next\[j\]”的情况，因此填入“j=neXt\[j\]”。空（4）处要填返回值，此处应该是能找到模式串的情况，此时i是主串匹配完成后的位置，j是子串的长；则匹配的起始位置为i-j+1（从1开始）。  
  
【问题2】  
（5）O(ls+lt)  
  
在kmp函数中，只有一个while循环，该算法的时间复杂度为O(ls+lt)。  
  
【问题3】  
（6）-1，-1，1，-1，-1，2，0，0  
（7）6  
  
根据C函数get\_next，得到“BABBCAC”的next数组的值为-1，-1，1，-1，-1，2，0，0。对主串为揂ABB“CBBABBCACCD”和上述模式串，得到匹配位置为6，这里需要注意的是，位置从1开始。  


## 第5题 ##

【问题1】  
（1）virtual void printInvoice()  
（2）ticket-&gt;printInvoice();  
（3）Decorator::printInvoice()  
（4）Decorator::printInvoice()  
（5）&a  
  
本题考查装饰（Decorator）模式的基本概念和应用。  
装饰模式属于结构型设计模式，其设计意图是动态地给一个对象添加一些额外的职责。就增加功能而言，装饰模式比生成子类更加灵活。装饰模式的结构如图5-2所示。  
![5e8855ca51744f18a7fa3b5d047c81e5.jpg][]  
其中：  
•Component定义一个对象接口，可以给这些对象动态地添加职责。  
•ConcreteComponent定义一个对象，可以给这个对象添加一些职责。  
•Decorator维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。  
•ConcreteDecorator向组件添加职责。  
装饰模式适用于：  
•在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。  
•处理那些可以撤销的职责。  
•当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。  
本题将装饰模式用于实现打印发票问题。图5-1的类图中，类Invoice对应图5-2中的Component，其功能是打印发票的内容；HeadDecorator和FoctDecorator是两个ConcreteDecorator，向组件中添加打印发票抬头和发票脚注的功能。  
方法printlnvoice是Invoice中定义的接口，Component类中应定义一个与之一致的接口。在C++中，父类和子类之间共享接口，通常釆用虚拟函数。由此可知，空（1）处应填写"virtual void printInvoice()”。这个接口在类Decorator、HeadDecorator和FootDecorator中分别进行了重置，分别对应代码中的空（2）~（4）。  
类Decorator中保持了一个指向Component对象的指针ticket，用来接收所要装饰的组件Invoice。因此空（2）处应填写“ticket-&gt;printInvoice()”。类HeadDecorator和FootDecomtor是在打印发票内容的基础上，打印发票的抬头和脚注，所以空（3）、（4）处都应填写“Decorator：：printInvoice()”。  
最后—空考查的是装饰模式的调用，由main()函数中给出的第一次调用可以获得一些提示，推断出空（5）出应填写“&a”。  


## 第6题 ##

【问题1】  
（1）ticket.printInvoice()  
（2）super.printInvoice()  
（3）super.printInvoice()  
（4）new HeadDecorator(new FootDecorator(t))  
（5）new FootDecorator(new HeadDecorator(null))  
  
本题考查装饰（Decorator）模式的基一概念和应用。  
装饰模武属于结构型设计模式，其设计意图是动态地给一个对象添加些额外的职责，就增加功能而倉装饰模式比生成子类更加灵活。装饰模式的结构如图6-2所示。  
![487f9d49982f40b58354ea0c2ced97ea.jpg][]  
其中：  
•Component定义一个对象接口，可以给这些对象动态地添加职责。  
•ConcreteComponent定义一个对象，可以给这个对象添加一些职责。  
•Decorator维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。  
•ConcreteDecorator向组件添加职责。  
装饰模式适用于：  
•在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。  
•处理那些可以撤销的职责。  
•当不能釆用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏。或类定义不能用于生成子类。  
    本题将装饰模式用于实现打印发票问题。图6-1的类图中，类Invoice对应图6-2中的Component，其功能是打印发票的内容；HeadDecorator和FootDecorator是两个ConcreteDecorator，向组件中添加打印发票头和发票脚注的功能。  
    方法printlnvoice是Invoice中定义的接口，Component类中应定义一个与之一致的接口。这个接口在类Decorator、HeadDecorator和FootDecorator中分别进行了重新定义，分别对应代码中的空（1）~（3）。  
    类Decorator中保持了一个Component对象——ticket，用来接收所要装饰的组件Invoiceo因此空（1）处应填写“ticket.printInvoice()”。类HeadDecorator和FootDecorator是在打印发票内容的基础上，打印发票的抬头和脚注，所以空（2）、（3）处都应填写“super.printInvoice()”。  
    空（4）~（5）考查的是装饰模式的调用，分别应填写为“new HeadDecorator（new FootDecorator（t））”和“new HeadDecorator（new FootDecorator（null））”。  



[bdbb84211b2b46c9b6686f80414c3d5a.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/bdbb84211b2b46c9b6686f80414c3d5a.jpg
[9f1a9d4cbbed4744b9053899f1ca1a53.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/9f1a9d4cbbed4744b9053899f1ca1a53.jpg
[9230673c995a40bcbdf264533a777aca.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/9230673c995a40bcbdf264533a777aca.jpg
[5e8855ca51744f18a7fa3b5d047c81e5.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/5e8855ca51744f18a7fa3b5d047c81e5.jpg
[487f9d49982f40b58354ea0c2ced97ea.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/487f9d49982f40b58354ea0c2ced97ea.jpg
