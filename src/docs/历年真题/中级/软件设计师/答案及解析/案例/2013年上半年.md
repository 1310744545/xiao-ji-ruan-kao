---  
title: 2013年上半年  
# icon: gears  
order: 992  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1志愿者 E2捐赠人 E3募捐机构 E4场馆  
  
本题采用结构化方法进行系统分析与设计，主要考查数据流图（DFD)的应用，是比较传统的题目，要求考生细心分析题目中所描述的内容。  
DFD是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分。顶层DFD—般用来确定系统边界，将待开发系统看作一个大的加工(处理)，然后根据系统从哪些外部实体接收数据流，以及系统将数据流发送到哪些外部实体，建模出的顶层图中只有唯一的一个加工和一些外部实体，以及这两者之间的输入输出数据流。0层DFD在顶层确定的系统外部实体以及与外部实体的输入输出数据流的基础上，将顶层DFD中的加工分解成多个加工，识别这些加工的输入输出数据流，使得所有顶层DFD中的输入数据流，经过这些加工之后变换成顶层DFD的输出数据流。根据0层DFD中的加工的复杂程度进一步建模加工的内容。  
在建分层DFD时，根据需求情况可以将数据存储建模在不同层次的DFD中，注意在绘制下层数据流图时要保持父图与子图平衡。父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名称上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一个数据流。  
本问题给出0层DFD，要求根据描述确定图中的外部实体。分析题目中描述，并结合己在图中给出的数据流进行分析。从题目的说明中可以看出，与系统交互实体包括志愿者、捐赠人、募款机构和场馆，这四个作为外部实体。  
  
【问题2】  
P1：确定活动时间范围  
P2：搜索场馆  
P3：推广募捐活动  
![049f29cb764641268a5808d3997c8f32.jpg][]  
  
本题考查分层DFD的加工分解，以及父图与子图的平衡。图1-2中对图1-1的加工3进行进一步分解，根据说明（3）中对加工3的描述对图1-2进行分析。首先需要确定活动时间范围，其输入数据流是活动请求，输出流为活动时间。然后是搜索场馆，其输入流为活动时间，输出活动时间和地点，同时向场馆发送的场馆可用性请求和获得的场馆可用性分别作为输入和输出数据流。在确定活动时间和地点的基础上推广募捐活动， 活动时间和地点是其输入流，活动信息作为其输出流，流向举办活动并募集资金，从募款机构获取资金并向其发放赠品，加工2收集募得的资金和物品，因此3.5还需要将所募集资金作为输出流。获取和处理捐赠（资金和物品）时以捐赠请求作为其输入流，输出流为所募集的捐赠，因为既有资金又有物品，而从募款机构募得的只有资金，将图1-1中加工3流向加工2的数据流，分为所募集资金和所募集物品，而3.5的输出流中只有所募集资金。  
因此，P1为确定活动时间范围，P2为搜索场馆，P3为推广募捐活动。图1-2中缺失了从2到3.3的活动请求和从3.5到2的所募集资金这两条数据流。  
题目给出处理和捐赠人之间的交互进一步描述，对3.1进一步建模下层数据流图（图 1-3)。分解加工3.1，确定相关数据流。其中根据加工2的捐赠请求进行募集，所募捐赠需要返回给加工2。  
根据父图与子图的平衡原则，图1-3中此处也缺失了捐赠请求和所募集资金和所募集物品。  
  
【问题3】  
D1：捐赠人信息表 D2:已联系的捐赠人表  
D3：捐赠表 D4:已处理捐赠表  
  
本问题考查2层DFD中数据存储的确定。本案例中，数据存储的描述都是在这一部分描述给出，所以数据存储建模在此层体现。  


## 第2题 ##

【问题1】  
![e87941b93fff481fa7a36f87d03e57d9.jpg][]  
说明：\*填写为m和n均可。  
  
本题考查数据库设计，属于比较传统的题目，考查点也与往年类似。  
本问题考查数据库的概念结构设计，题目要求补充完整实体联系图中的联系和联系的类型。  
根据题目的需求描述可知，一个栏目可以插播多条广告，而多条广告也可以在多个栏目中播放，因此栏目和广告之间存在“插播”联系，联系的类型为多对多（\*:\*，或m:n)。  
根据题目的需求描述可知，一个栏目可以有多个主持人，而一个主持人只能主持一档栏目，因此栏目和主持人之间存在“主持”联系，联系的类型为一对多（1:\*，或1:n)。  
根据题目的需求描述可知，一个栏目需要使用多名场务来进行演出协调，场务可以被多个栏目循环使用，因此演播厅、栏目和场务之间存在“调度”联系，联系的类型为1对多对多（1:\*:\*，或1:m:n)。  
  
【问题2】  
![8e35c009ac5d4f3abe3d38253a07f1ac.jpg][]  
  
本问题考查数据库的逻辑结构设计，题目要求补充完整各关系模式，并给出各关系模式的主键。  
根据实体联系图和需求描述，广告记录广告编号、销售价格和编辑人员工号。所以， 对于“广告”关系模式，需补充属性“广告编号”。广告编号为广告的主键。  
根据实体联系图和需求描述，主持人记录主持人工号和所属的栏目名称。所以，对于“主持人”关系模式，需补充属性“主持人工号”。主持人工号为主持人的主键。  
根据实体联系图和需求描述，插播单需要记录栏目名称、广告编号和播出的时间。 所以，对于“插播单”关系模式，需补充属性“栏目名称”和“广告编号”。栏目名称和广告编号联合作为插播单的主键。  
根据实体联系图和需求描述，调度单需要记录栏目名称、房间号和参与的场务工号。 所以，对于“调度单”关系模式，需补充属性“栏目名称”、“房间号”和“场务工号”。 栏目名称、房间号和场务工号联合作为插播单的主键。  
  
【问题3】  
![9d708119edec43c79aca52fdf610189d.jpg][]  
  
本问题考查数据库的概念结构设计，根据新增的需求增加实体联系图中的实体的联系和联系的类型。  
根据问题描述，一个广告商可以提供多条广告，一条广告只由一个广告商提供。则须在广告商实体和广告实体之间存在“提供”联系，联系的类型为1对多（1:\*，或l:n)  


## 第3题 ##

【问题1】  
A1 ：网络用户或 InternetClient A2：授权用户或 RegisteredClient  
UC1：更新信息 UC2:认证  
(1): «include»  
  
  
本题属于经典的考题，主要考查面向对象分析方法以及UML的用例图和类图的相关应用。  
本问题要求将图3-1所给出的用例图补充完整。用例图的构成要素有：参与者(Actor)、用例(Usecase)以及用例之间的关系。  
本题背景描述简单，再结合图3-1中给出的两个用例“搜索信息”和“删除客户”，很容易确定出“认证”、“更新信息”就是需要补充的用例。下面只需要确定参与者A1、A2以及这两个用例与A1、A2之间的关系即可将图补充完整。在说明中出现了两类角色: 客户和系统管理员。系统管理员已经作为参与者明确标识在3-1中了。那么A1和A2只能从“客户”这个角色中产生。明显地，“客户”在说明中被细分成了两类：网络用户和授权用户，而认证用户是一种特殊的网络用户。因此，A1应该对应“网络用户”，A2 应该对应“授权客户”。要成为授权用户，必须首先经过认证。成为授权用户之后，不仅可以搜索信息，还具有更新信息的权限。更新信息时要求首先登录系统，因此“登录” 是“更新信息”操作中所包含的一个必须步骤。由此可以确定UC1对应“更新信息”， UC2对应“认证”，而（1）处的关系应该是«include»  
  
【问题2】  
Cl：InternetClient C2：CustomerListC3：RegisteredClient  
C4:Administrator C5：Customer  
(2)1 (3)0..\* (4) 0..1 (5) 0..1  
  
本问题考查类建模。表3-1已经给出了类列表，这样对照图3-2寻找对应关系即可。图3-2中有两个明显的结构：继承（Cl、C3和C4之间）和聚集（C2和C5之间）。  
先确定聚集关系相关的类。由表3-1可以找出两个明显具有部分整体概念的类： CustomerList和Customer,由类的说明可以看出，CustomerList表示整体概念，Customer表示部分概念。由此可以确定C2对应CustomerList, C5对应Customer。同时可以确定出这两个类之间的多重度，即（2）处应为1，(3)处为0..\*。  
下面来确定继承关系相关的类。图3-1中已经出现了一个继承关系(A1和A2之间）， 这就给出了一个明显的提示：图3-2中的继承关系与这两类角色相关。回到表3-1中，发现了3个与角色相关的类：IntemetClient (网络用户）、RegisteredClient (授权用户）和Administrator (系统管理员）。由于己经确定了C5是Customer,而能够对Customer 进行操作的只有系统管理员。因此具有继承关系的这3个类应分别是：C1-网络用户，C3-授权用户，C4-系统管理员。（4）、(5)处的多重度也可以确定下来，均为0..1。  
  
【问题3】  
选择候选类时通常考虑的是问题域中自然存在的名词。  
具有下列特征的候选类需要删除：含义相近（冗余）、含义不明确的对象、暗示实现方式的、表示属性或特征、有动词含义的名词（表示行为和方法)。  
  
本问题考查面向对象分析过程中认定类/对象的过程。通常分为两个步骤进行，首先将问题域（需求分析）中所有自然存在的名词都选出来，构成候选类集合。然后针对这个候选类集合，将满足以下原则的名词从候选类集合中删除：含义相近（冗余)、含义不明确的对象、暗示实现方式的、表示属性或特征、有动词含义的名词（表示行为和方法)。 最后剩余的就是所认定的类/对象。  


## 第4题 ##

【问题1】  
(1) d\[i\] = t\[i\] (2) i=m (3) s\[k\]\[count\[k\]\] =i (4) max&lt;d\[i\]  
  
本题考查算法设计与分析技术以及算法的C语言实现，是比较传统的题目，要求考生细心分析题目中所描述的内容。  
根据题中说明和代码注释，算法首先初始化数组d和s中的元素；然后将m个任务分配到m台机器上，此时将任务0，1，...，m-1分别分配到机器0，1，…，m-1上，同时设置d、s和count数组中的相关元素的值，故空格（1）填写d\[i\] = t\[i\];接下来将剩下的n-m个任务分配到m台机器上，从任务m开始，因此空格（2）填写i=m，确定首先空闲的机器k，将当前尚未分配的第一个任务分配到机器k上，并设置d、s和count数组中的相关元素的值，故空格（3）填写s\[k\]\[c0unt\[k\]\] = i;最后确定从任务开始到结束所需要的时间，从所有机器的运行时间中选择运行时间最长的机器的运行时间，即最大的d\[i\]， 因此空格（4）填写max&lt;d\[i\]。  
  
【问题2】  
(5) 贪心 （6） O(mn)  
  
根据上述C代码，算法有两处两重循环，时间复杂度为O(mn)，有两处一重循环，时间复杂度为0(m)，因此整个算法的时间复杂度为O(mn)。  
  
【问题3】  
(7) 0 (8) 1,5 (9) 2,3,4,6 (10) 17  
  
根据说明中的算法思想和C代码，首先将任务0、1和2分配到机器0、1和2上运行，运行时间分别为16、14和6。由于任务2的时间最短，故任务3在机器2上运行，机器2上的运行时间为6+5=11，仍然是时间最短，任务4继续在机器2上运行，机器2上的运行时间为11+4=15。此时机器1上的运行时间最短，任务5在机器1上运行，机器1上的运行时间为14+3=17。此时机器2上的运行时间最短，任务6在机器2上运行， 机器2上的运行时间为15+2=17。所以任务分配完成。根据此分配，在机器0上运行任务0,运行时间为16;机器1上运行任务1和5,运行时间为17;在机器2上运行任务 2, 3, 4和6,运行时间为17。因此从任务开始到结束的时间为17。  
![2aa08a34fdb44e88b16abeea70ab35cd.jpg][]  


## 第5题 ##

【问题1】  
(1) virtual Cloneable\* Clone() = 0  
(2) WorkExperience \*obj = new WorkExperience()  
(3) (WorkExperience \*)work-&gt;Clone()  
(4) Resume \*obj = new Resume(this-&gt;work)  
(5) (Resume \*)a-&gt;Clone()  
  
本题考查原型（Prototype)模式的概念及应用。  
Prototype模式是一种对象创建型模式。Prototype模式通过给出一个原型对象来指明所要创建的对象的类型，然后通过复制这个原型对象的方法，创建出更多同类型的对象。原型模式又可以分为两种：浅克隆和深克隆。浅克隆仅仅复制所考虑的对象，而不复制它所引用的对象，也就是其中的成员对象并不复制；深克隆除了对象本身被复制外，对象包含的引用也被复制，即成员对象也被复制。  
原型模式的优点是：  
(1) 向客户隐藏制造新实例的复杂性；  
(2) 提供让客户能够产生未知类型对象的选项；  
(3) 在某些环境下，复制对象比创建新对象更有效。  
在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型模式。使用原型模式的缺点是：对象的复制有时相当复杂。  
Prototype模式的结构如下图所示。  
![5651af5bd12b4c1eb3e144552cc060d7.jpg][]  
题目利用原型模式来实现自动生成多份求职简历，而且每份简历的工作经历有所差别。题目中使用的是原型模型中的深克隆。题目中的类Cloneable对应上图中的类 Prototype, Resume 和WorkExperience 分别是两个具体克隆类。由于WorkExperience是Resume的一部分，所以在Resume中有一个WorkExperience类型的成员对象。  
下面来分析程序。  
第（1）空出现在类Cloneable的定义中。类Cloneable的作用是声明一个克隆自身的接口，在C++中通常都采用抽象类来定义这种抽象操作接口。C++中的抽象类是包含了至少一个纯虚拟函数的类。纯虚拟函数的语法是：  
virtual &lt;函数名&gt;(&lt;参数列表&gt;)=0;  
下面来确定纯虚拟函数的原型。由类图5-1以及Cloneable的子类WorkExperience 中定义的成员函数Clone()可知，（1）空应该填写virtual Cloneable\* Clone() = 0。空（2）出现在类WorkExperience成员函数Clone()的定义中。WorkExperience作为具体克隆类，应实现继承自父类的纯虚拟函数Ck&gt;ne()。根据已给出的代码的提示，在 Clone()方法中，应再创建一个WorkExperience对象，而这个对象的名称就是obj。因此  
(2) 空处应填 WorkExperience \*obj = new WorkExperience()0  
本题釆用的是深克隆，除了对象本身被复制外，成员对象也被复制。work是Resume中的成员对象，所以（3）空是对成员对象的克隆，因此应调用work对象的克隆操作， 即(WorkExperience \*)work-&gt;Clone()。  
第（4）空出现在Resume的Clone()方法中，功能与第（2）空类似，完成Resume对象的克隆，所以第（4）空应填 Resume \*obj = new Resume(this-&gt;work)。  
第（5）空是对原型模式的应用。用简历a克隆出简历b,即调用a的克隆操作，所以第（5）空应填(Resume \*)a-&gt;Clone()0  


## 第6题 ##

【问题1】  
(1) implements  
(2) WorkExperience obj = new WorkExperience()  
(3) implements  
(4) (WorkExperience)work.Clone()  
(5) new Resume(this.work)  
(6) (Resume)a.Clone()  
  
本题考査原型（Prototype)模式的概念及应用。  
Prototype模式是一种对象创建型模式。Prototype模式通过给出一个原型对象来指明所要创建的对象的类型，然后通过复制这个原型对象的方法，创建出更多同类型的对象。 原型模式又可以分为两种：浅克隆和深克隆。浅克隆仅仅复制所考虑的对象，而不复制它所引用的对象，也就是其中的成员对象并不复制；深克隆除了对象本身被复制外，对象包含的引用也被复制，即成员对象也被复制。  
原型模式的优点是：  
(1) 向客户隐藏制造新实例的复杂性；  
(2) 提供让客户能够产生未知类型对象的选项；  
(3) 在某些环境下，复制对象比创建新对象更有效。  
在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型模式。使用原型模式的缺点是：对象的复制有时相当复杂。  
Prototype模式的结构如下图所示。  
![4f6254f09acc4d77b9c86afaf90dfce0.jpg][]  
题目利用原型模式来实现自动生成多份求职简历，而且每份简历的工作经历有所差別。题目中使用的是原型模型中的深克隆。题目中的类Cloneable对应上图中的类Prototype, Resume和WorkExperience,分别是两个具体克隆类。由于WorkExperience是Resume的一部分，所以在Resume中有一个WorkExperience类型的成员对象。  
下面来分析程序。  
Cloneable是Java中的一个接口，其中已经定义f Clone()接口，可以直接在程序中使用。对于两个具体克隆类Resume和WorkExperience来说，只要实现Cloneable即可。 因此第（1）、(3)空均填写implements。  
空（2）出现在类WorkExperience成员函数Clone()的定义中。WorkExperience作为具体克隆类，应实现Cloneable中的方法Clone()。根据已给出的代码的提示，在Clone() 方法中，应再创建一个WorkExperience对象，而这个对象的名称就是obj。因此（2）空处应填 WorkExperience obj = new WorkExperience() 。  
本题采用的是深克隆，除了对象本身被复制外，成员对象也被复制。work是Resume 中的成员对象，所以（4）空是对成员对象的克隆，因此应调用work对象的克隆操作， 即(WorkExperience)work.Clone() 。  
第（5）空出现在Resume的Clone()方法中，功能与第（2）空类似，完成Resume对象的克隆，所以第（5）空应填new Resume(this.work)。  
第（6）空是对原型模式的应用。用简历a克隆出简历b,即调用a的克隆操作，所以第(6)空应填(Resume)a.Clone()。  



[049f29cb764641268a5808d3997c8f32.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/049f29cb764641268a5808d3997c8f32.jpg
[e87941b93fff481fa7a36f87d03e57d9.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/e87941b93fff481fa7a36f87d03e57d9.jpg
[8e35c009ac5d4f3abe3d38253a07f1ac.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/8e35c009ac5d4f3abe3d38253a07f1ac.jpg
[9d708119edec43c79aca52fdf610189d.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/9d708119edec43c79aca52fdf610189d.jpg
[2aa08a34fdb44e88b16abeea70ab35cd.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/2aa08a34fdb44e88b16abeea70ab35cd.jpg
[5651af5bd12b4c1eb3e144552cc060d7.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/5651af5bd12b4c1eb3e144552cc060d7.jpg
[4f6254f09acc4d77b9c86afaf90dfce0.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/4f6254f09acc4d77b9c86afaf90dfce0.jpg
