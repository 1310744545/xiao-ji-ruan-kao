---  
title: 2018年下半年  
# icon: gears  
order: 981  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1：客户；E2：经纪人；E3：财务人员；E4：外部网站  
  
本题考查采用结构化方法进行软件系统的分析与设计，主要考查利用数据流图 (DFD)进行需求分析和建模。DFD是面向数据流建模的工具，它将系统建模成输入、加工（处理）、输出的模型，即流入软件的数据对象、经由加工的转换、最后以结果数据对象的形式流出软件，并采用自顶向下分层建模进行逐层细化。  
顶层DFD (上下文数据流图）建模用于确定系统边界以及系统的输入输出数据，待开发软件系统被看作一个加工，为系统提供输入数据以及接收系统输出数据的是外部实体，外部实体和加工之间的输入输出即为数据流。数据流或者由具体的数据属性（也称为数据结构）构成，或者由其他数据流构成，即组合数据流，用于在高层数据流图中组合相似的数据流。将上下文DFD中的加工分解成多个加工，分别识别这些加工的输入数据流以及经过加工变换后的输出数据流，建模0层DFD。根据0层DFD中加工的复杂程度进一步建模加工的内容。根据需求情况可以将数据存储建模在不同层次的DFD中。  
在建模分层DFD时，需要注意加工和数据流的正确使用，一个加工必须既有输入又有输出；数据流须和加工相关，即数据流至少有一头为加工。注意要在绘制下层数据流图时保持父图与子图平衡，即父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流的组合数据流。  
题目题干描述清晰，易于分析，要求考生细心分析题目中所描述的内容。  
本问题考查的是上下文DFD，要求确定外部实体。在上下文DFD中，待开发系统名称“房屋中介系统”作为唯一加工的名称，为这一加工提供输入数据流或者接收其输出数据流的外部实体，涉及到外部网站、经纪人、客户和财务人员，再根据描述相关信息进行对应，对照图1-1，即可确定E1为“客户”实体，E2为“经纪人”实体，E3为“财务人员”实体，E4为“外部网站”。  
  
【问题2】  
D1：客户记录；D2：潜在房源记录；D3：房源记录；D4：订单记录  
  
本问题要求确定图1-2 0层数据流图中的数据存储。重点分析说明中与数据存储有关的描述。说明1中“系统自动采集外部网站的潜在房源信息，保存为潜在房源”，可知加工“房源采集与管理”向存储中写入新的潜在房源信息，由此可知D2为“潜在房源”；再由说明1中“由经纪人联系确认的潜在房源变为房源”等信息，可知此加工需要向存储中写入新房源信息，由此可知D3为“房源”。说明2中“求租/求购客户进行注册”和“或由经纪人对求租/求购客户进行登记”可知加工“客户管理”向D1中添加新客户信息，由此可知D1为“客户”。说明4中交易管理“经纪人对租售客户双方进行交易信息管理，包括订单提交和取消”“系统更新订单状态”等，可知D4为“订单”。  
  
【问题3】  
![8e36b357051344859df7d4684401261c.jpg][]  
  
本问题要求补充缺失的数据流及其起点和终点。对照图1-1和图1-2的输入、输出数据流，缺少了从加工到外部实体E2 (经纪人）的数据流—“交易反馈”，说明4中，交易管理需“向客户和经纪人发送交易反馈”，可以此数据流起点为P4 (交易反馈），终点为E2。  
再考查题干中的说明判定是否缺失内部的数据流，不难发现图1-2中缺失的数据流。根据说明1的描述“系统自动采集外部网站的潜在房源信息，保存为潜在房源。由经纪人联系确认的潜在房源变为房源”可知加工房源采集与管理（P1)从潜在房源（D2)读取数据进行确认，说明3 “根据客户的需求情况向已登录的客户推荐房源”可知加工房源推荐（P3)从存储客户（D1)获取“需求情况”，说明4中“系统更新订单状态和房源状态”可知交易管理（P4)需更新房源（D3)的状态。  
  
【问题4】  
客户信息=身份证号+姓名+手机号+需求情况+委托方式  
房源信息=基本情况+配套设施+交易类型+委托方式+业主  
  
数据流由具体的数据属性构成采用符号加以表示，“=”表示组成（被定义为），“+”表示有多个属性（与），\{\}表示其中属性出现多次，（)表示其中属性可选等。图中的“客户信息”和“房源信息”来自于E1客户或E2经纪人。在说明1中给出“房源信息包括基本情况、配套设施、交易类型、委托方式、业主等”，说明2中给出“客户信息包括身份证号、姓名、手机号、需求情况、委托方式等”，即采用和“ + ”将数据流及其属性表示出来。  


## 第2题 ##

【问题1】  
完善后的实体联系图如下所示（所补充的联系和类型如虚线所示）:  
![bf151da8e9de4beb93883e4b56305514.jpg][]  
  
本题考查数据库系统中实体联系模型(E-R模型)和关系模式设计方面的基础知识。  
可分析如下：  
①根据题意“每个分公司包含有不同的部门，但一个部门只对应一个分公司。”分公司和部门之间有一个“组成”联系，联系类型为1:\*。  
②根据题意“每个分公司只有一名经理，负责该分公司的管理工作。”所以分公司和经理之间有一个“管理1”联系，联系类型为1:1。  
③根据题意“每个部门只有一名主管，只负责管理本部门的工作。”所以部门和主管之间有一个“管理2”联系，联系类型为1:1。  
④根据题意“一个部门有多名员工，每名员工只属于一个部门。”，部门和员工之间有一个“隶属”联系，联系类型为1:\*。  
  
【问题2】  
（a）经理（或员工号）；  
（b）主管号（或员工号），分公司编号；  
（c）隶属部门（或部门号），岗位。  
  
根据【需求分析】1.分公司需要记录的信息包括公司编号、名称、经理（应参照员工关系的员工号）、联系地址和电话”，所以空（a）应填写“经理”。  
根据【需求分析】2.部门需要记录的信息包括部门号、部门名称、主管号（应参照员工关系的员工号）、电话、分公司编号”，所以空（b）应填写“主管号，分公司编号”。  
根据【需求分析】3..员工需要记录的信息包括员工号、姓名、隶属部门、岗位，电话号码和基本工资”，所以空（c）应填写“隶属部门，岗位”。  
  
【问题3】  
“部门”关系模式的主键为：部门号；  
外键为：主管号、分公司编号;  
“员工”关系模式的主键为：员工号；  
外键为：部门号；  
  
根据题干所述“部门号唯一标识部门信息中的每一个元组”，部门关系的主键为部门号。由于部门关系中的“主管号”必须参照员工关系的员工号，“分公司编号”必须参照分公司关系的分公司编号，故部门关系的外键为主管号、分公司编号。  
根据题干所述“员工号唯一标识员工信息中的每一个元组”，故员工关系的主键为员工号；又由于隶属部门必须参照部门关系的部门号，故员工关系的外键为隶属部门。  
“是”或“需要”。  
  
【问题4】  
部门与历任主管之间的联系类型是的必须建立一个独立的关系模式，该模式的属性由两端的码加上联系的属性构成。  
  
如果需要系统能记录部门历任主管的任职时间，那么“在数据库设计时需要增设一个实体”的说法是正确的。因为部门与历任主管之间的联系类型是\*：\*的，必须建立一个独立的关系模式，该模式为（部门号，历任主管，任职时间）。  


## 第3题 ##

【问题1】  
C1：SNSGroup；C2：SNSUser；C3：SNSAdmin。  
（其中C2、C3可以互换）  
  
本题主要考查面向对象分析与设计应用。在建模方面，本题仅涉及到了UML的类图，要求根据需求说明将模型补充完整。题目较为简单，属于经典考题。  
本题给出的应用场景是社交网络平台中的在线群组。根据题干说明和表3-1给出的类列表，类之间的关系比较明确。  
在图3-1所示的类图中，有一个继承结构：SNSObserver、C2和C3。表3-1中给出了5个类，图3-1中标识出了2个。根据说明，在剩下的3个类中，能够与这个继承结构相匹配的类只有SNSUser和SNSAdmin了。那么C1对应的就是类SNSGroup。  
  
【问题2】  
  
观察者（Observer)模式。  
意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。  
观察者模式的适用场合：  
（1）当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。  
（2）当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。  
（3）当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。  
  
图3-1中采用的是观察者（Observer)模式。观察者模式的意图是，定义吋象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。  
观察者模式的结构图如图3-2所示，其中：  
Subject (目标）知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口。  
Observer (观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口。  
ConcreteSubject (具体目标）将有关状态存入各ConcreteObserver对象；当它的状态发生改变时，向它的各个观察者发出通知。  
ConcreteObserver (具体观察者）维护一个指向ConcreteSubject对象的引用；存储有关状态，这些状态应与目标的状态保持一致；实现Observer的更新接口，以使自身状态与目标的状态保持一致。  
![cb6a988ecb3f4c36b93397d7f26ce8b6.jpg][]  
观察者模式的适用场合：  
（1）当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。  
（2）当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。  
（3）当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。  
  
【问题3】  
（1）在SNSSubject和SNSObserver之间增加继承关系;SNSObserver为基类，SNSSubject为派生类。  
（2）为类SNSGroup增加自关联（自己到自己的关联关系）。  
  
对于新需求：一个群组可以作为另外一个群组中的成员，也就是说群组是可以嵌套的。针对这个新需求，对图3-2所示的类图需要进行如下修改：  
在SNSSubject和SNSObserver之间增加继承关系;SNSObserver为基类，SNSSubject为派生类。为类SNSGroup增加自关联（自己到自己的关联关系）。  


## 第4题 ##

【问题1】  
（1）max=C\[i\]\[j-1\]  
（2）t=i  
（3）isMatch(B\[t\],B\[j\])或其等价形式  
（4）C\[1\]\[n\]  
  
本题考査算法设计与分析以及用C程序设计语言实现算法的能力。要求考生要熟练掌握几种常用的算法设计策略的基本概念、解题思路、实现方法和时间复杂度分折方法。本题是采用动态规划方法求解RNA序列的二级结构。  
在C函数isMatch中，判断两个字符是否匹配。  
在C函数RNA\_2中，求解最大的匹配数。代码涉及到三重for循环。最外for循环中的循环变量k表示字符间隔长度，中间for循环的循环变量i表示待考虑的子问题的起始字符下标，根据i和k可以确定j，即待考虑的子问题。每次先假设该子问题的值为也就是题干中递归式第一部分中的前一部分，因此空（1）填写max=C\[i\]\[j-1\] 。最内层for循环中的循环变量t是求解问题bibi+1 ……bj的子问题的最优匹配数，也就是题干中递归式第一部分中的后一部分，t从i开始，因此空（2）处填t=i。判断if 中其实是实现递归式第一部分的条件，也就是B\[t\]和B\[j\]是否匹配，因此空（3）处填写isMatch(B\[t\],B\[j\])，注意条件i&lt;j-1已经在循环中约束。空（4）处要填返回值，即C\[1\]\[n\]。  
  
【问题2】  
（5）动态规划法  
（6）O(n3)  
  
【问题3】  
（7）2  
  
运行上述C程序，得到：  
c\[1\]\[6\]=1，c\[2\]\[7\]=0，c\[3\]\[8\]=1，c\[4\]\[9\]=0  
c\[1\]\[7\]=1，c\[2\]\[8\]=1，c\[3\]\[9\]=1  
c\[1\]\[8\]=1，c\[2\]\[9\]=1  
c\[1\]\[9\]=2  


## 第5题 ##

【问题1】  
（1）virtual double travel(int miles,FrequentFlyer\* context)=0  
（2）context-&gt;setState(context-&gt;silver)  
（3）context-&gt;setState(context-&gt;gold)  
（4）context-&gt;setState(context-&gt; silver)  
（5）context-&gt;setState(context-&gt;basic)  
  
本题考查设计模式中状态（State)模式的基本概念和实现。  
状态模式的意图是，允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。状态模式的结构图如图5-3所示。  
![f65b9fbd50564c86abe878e8279e753e.jpg][]  
其中：  
Context (上下文）定义客户感兴趣的接口；维护一个ConcreteState子类的实例，这个实例定义当前状态。  
State (状态）定义一个接口以封装与Context的一个特定状态相关的行为。  
ConcreteState(具体状态子类)的每个子类实现与Context的一个状态相关的行为。  
状态模式适用于以下情形：  
一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。  
一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。  
这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。  
本题中的类CState 对应于图5-3中的State,类CNonMember、CBasic、CSilver 和CGold则是具体的状态子类，每个子类实现与CFrequentFlyer(对应图5-3中的Context) 的一个状态相关的行为。  
第（1）空需要填写CState中的核心方法，这个方法将在CFrequentFlyer中被调用，该空的答案可以从CState的子类中得出。这里采用了C++中的纯虚拟函数机制，使CState成为了抽象基类，为其子类提供统一操作接口，具体实现则由子类来实现。因此第（1）空应填入virtual double travel(int miles,FrequentFlyer\* context)=0  
第（2）~（5）空体现的是4个具体状态一普卡（Basic)、银卡（Silver)、金卡（Gold)以及非会员（NonMember) 之间的转换，如图5-1所示。对于普卡会员，当累积的里程数大于等于25000并且小于50000时，可升级为银卡会员，即类CFrequentFlyer所维护的状态应被设置为银卡（也就是CSilver的实例）。状态的设置需要调用类CFrequentFlyer中的方法setState，这个方法的形参类型是CState\*，可以接受CState以及其子类类型的实参。这种类型转换是由面向对象程序设计中的继承机制保证的。因此第(2)空应填入context-&gt;setState(context-&gt;silver)。同理，根据图5-1，第(3) 空应填入context-&gt;setState(context-&gt;gold)。  
第（4）、（5）空在类CGold中，根据图5-1可知，第(4) 空应填入context-&gt;setState(context-&gt; silver)；第(5) 空应填入context-&gt;setState(context-&gt;basic)。  


## 第6题 ##

【问题1】  
（1）abstract double travel(int miles,FrequentFlyer context)  
（2）context.setState(new CSilver())  
（3）context.setState(new CGold ())  
（4）context.setState(new CSilver())  
（5）context.setState(new CBasic())  
  
本题考查设计模式中状态（State)模式的基本概念和实现。  
状态模式的意图是，允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。状态模式的结构图如图6-3所示。  
![2ff3fe279f6f4b929a458f417a74be00.jpg][]  
其中：  
Context (上下文）定义客户感兴趣的接口；维护一个ConcreteState子类的实例，这个实例定义当前状态。  
State (状态）定义一个接口以封装与Context的一个特定状态相关的行为。  
ConcreteState(具体状态子类）每个子类实现与Context的一个状态相关的行为。  
状态模式适用于如下情形：  
一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。  
一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。  
本题中的类CState对应于图6-3中的State,类CNonMember、CBasic、CSilver 和CGold则是具体的状态子类，每个子类实现与CFrequentFlyer(对应图5-3中的Context) 的一个状态相关的行为。  
第（1）空需要填写CState中的核心方法，这个方法将在CFrequentFlyer中被调用，该空的答案可以从CState的子类中得出。这里采用了Java中抽象类和抽象方法。因此第 (1)空应填入abstract double travel(int miles,FrequentFlyer context)。  
第（2）~（5）空体现的是4个具体状态普卡（Basic)、银卡（Silver)、金卡（Gold)以及非会员（NonMember) 之间的转换，如图6-1所示。对于普卡会员，当累积的里程数大于等于25000并且小于50000时，可升级为银卡会员，即类CFrequentFlyer所维护的状态应被设置为银卡（也就是CSilver的实例）。状态的设置需要调用类CFrequentFlyer中的方法setState，这个方法的形参类型是CState\*，可以接受CState以及其子类类型的实参。这种类型转换是由面向对象程序设计中的继承机制保证的。因此第(2) 空应填入context.setState(new CSilver())。同理,根据图6-1，第(3) 空应填入context.setState(new CGold ())。  
第(4)、（5）空在类CGold中，根据图6-1可知，第(4)空应填入context.setState(new CSilver())；第（5）空应填入context.setState(new CBasic())。  



[8e36b357051344859df7d4684401261c.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/8e36b357051344859df7d4684401261c.jpg
[bf151da8e9de4beb93883e4b56305514.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/bf151da8e9de4beb93883e4b56305514.jpg
[cb6a988ecb3f4c36b93397d7f26ce8b6.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第3题/cb6a988ecb3f4c36b93397d7f26ce8b6.jpg
[f65b9fbd50564c86abe878e8279e753e.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/f65b9fbd50564c86abe878e8279e753e.jpg
[2ff3fe279f6f4b929a458f417a74be00.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/2ff3fe279f6f4b929a458f417a74be00.jpg
