---  
title: 2016年上半年  
# icon: gears  
order: 986  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1：客户  
E2：管理员  
  
本题考查采用结构化方法进行系统分析与设计，主要考查数据流图(DFD)的应用，是比较传统的题目，考点与往年类似，要求考生细心分析题目中所描述的内容。  
面向数据流建模是目前仍然被广泛使用的结构化分析与设计的方法之一，而DFD是面向数据流建模的重要工具，是一种便于用户理解、分析系统数据程的图形化建模工具，是系统逻辑模型的重要组成部分。DFD将系统建模成“输入一加工(处理)一输出”的模型，即流入软件的数据对象、经由加工的转换、最后以结果数据对象的形式流出软件，并采用分层的方式加以表示。  
上下文DFD(顶层DFD)通常用来确定系统边界，将待开发系统看作一个大的加工(处理)，然后根据系统从哪些外部实体接收数据流，以及系统将数据流发送到哪些外部实体，建模出的上下文图中只有唯一的一个加工和一些外部实体，以及这两者之间的输入输出数据流。0层DFD在上下文确定的系统外部实体以及与外部实体的输入输出数据流的基础上，将上下文DFD中的加工分解成多个加工，识别这些加工的输入输出数据流，使得所有上下文DFD中的输入数据流，经过这些加工之后变换成上下文DFD的输出数据流。根据0层DFD中加工的复杂程度进一步建模加工的内容。  
在建分层DFD时，根据需求情况可以将数据存储建模在不同层次的DFD中，注意要在绘制下层数据流图时要保持父图与子图平衡。父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入(或输出)数据流对应于子图中几个输入(或输出)数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一条数据流。  
本题考查上下文DFD，要求确定外部实体。在上下文DFD中，系统名称作为唯一加工的名称，外部实体和该唯一加工之间有输入输出数据流。通过考查系统的主要功能，不难发现，系统中涉及到客户和会议中心管理员，没有提到其他与系统交互的外部实体。根据描述(1)“客户提交预订请求后”，(2)“会议中心管理员收到客户预定请求的通知之后，提交确认”、“根据客户记录给客户发送临时预订确认信息和支付定金要求”等信息，对照图1-1，从而即可确定E1为“客户”实体，E2为“管理员”实体。  
  
【问题2】  
D1：预订表  
D2：客户表  
D3：场地表(设施表或场地设施表)  
D4：设备表  
注：D3和D4可互换  
  
本题要求确定图1-2所示的0层数据流图中的数据存储。重点分析说明中与数据存储有关的描述。根据(1)“客户提交预订请求后，检查预订表”，(2)“系统生成新临时预订存入预订表，并对新客户创建一条客户信息记录加以保存”，可知D1为预订表、D2为客户表；根据“会议中心提供举办会议的场地设施和各种设备”，(3)“根据临时预订或变更预定的设备和设施需求，分配所需设备(均能满足用户要求)和设施，更新相应的表和预订表”，“分配设施和设备”可知D3为和D4分别为场地(设施)表和设备表。  
  
【问题3】  
![6b378da9b534452cbec8eb833c5b49b5.jpg][]  
  
本问题要求补充缺失的数据流及其起点和终点。  
对照图1-1和图1-2的输入、输出数据流，数量不同，考查图1-1中从加工“会议预订系统”输出至E1的数据流，有“临时预订/预订/变更确认信息”，而图1-2中从加工输出至E1的数据流“临时预订确认信息”和“变更预订确认信息”，但缺少了其中一条数据流“预订确认信息”。  
另外，图1-1中有“付款凭据”，图1-2中没有“付款凭据”，而只有“已支付定金凭据”，没有针对说明(7)中“管理员收到客户余款支付的通知后”中的“支付余款凭据”。上述两条数据流的遗失，使父图和子图数据流没有达到平衡。所以需要确定这两条条数据流或者其分解的数据流的起点或终点。  
考查说明中的功能，先考查“确认预定”，功能(4)中“给客户发送预订确认信息”，对照图1-2，加工4没有到实体E1客户的“预订确认信息”数据流；功能(7)中“管理员收到客户余款支付的通知后”，对照图1-2，加工7没有从实体E1客户输入的数据流“余款支付凭据”。图中“余款支付凭据”数据流是上下文数据流图中数据流“支付凭据”的分解，与另一条分解出的数据流“已支付定金凭据”对照，改名为“已支付余款凭据”。  
下面再仔细核对说明和图1-2之间是否还有遗失的数据流。  
不难发现，功能(4)中“根据客户记录给客户发送预订确认信息”，而图1-2中加工4从D1预订表中读取预订信息，并没有读取客户信息，所以，此处遗失了数据流“客户记录”，起点是D2客户表，终点是加工4确认预订；功能(5)中“管理员确认变更后，根据客户记录给客户发送确认信息”，而图1-2中加工5并没有所根据的“客户记录”输入数据流，所以，此处遗失了数据流“客户记录”，起点是D2客户表，终点是加工5变更预订；功能(6)中“根据客户记录给满足条件的客户发送支付余款要求”，而图1-2中加工6并没有所根据的“客户记录”输入数据流，所以，此处遗失了数据流“客户记录”，起点是D2客户表，终点是加工6要求预订。  
继续核对说明和图1-2，不难发现，功能(6)中“管理员从预订表中查询距预订的会议时间两周内的预定”，而图1-2中没有从D1预订表到加工6的输入流，所以，此处遗失了数据流“距预订会议时间两周内的预订”，其起点是D1预订表，终点是加工6要求付款。  
  
【问题4】  
将Email系统作为外部实体，并将发送给客户(E1)的确认信息数据流的终点全部改为Email系统(或具体说明确认信息数据流：临时预订确认信息、预订确认信息、变更确认信息，终点均改为Email系统)。  
  
DFD中，外部实体可以是用户，也可以是与本系统交互的其他系统。如果某功能交互的是外部系统(在本题中是Email系统)，则本系统需要将发送给客户的确认信息发送给Email系统。然后由第三方Email系统向客户发送邮件，此时第三方Email系统即为外部实体，而非本系统内部加工，因此需要对图1-1和图1-2进行修改，添加外部实体“Email系统”，并将数据流确认信息的终点全部改为Email系统。即将数据流“临时预订确认信息”、“预订确认信息”、“变更确认信息”数据流的终点改为新的外部实体“Email系统”。  


## 第2题 ##

【问题1】  
补充内容如图中虚线所示：  
![3b5e77a01cd340e0ab46885adcf4587a.jpg][]  
  
本题考查数据库概念结构设计和逻辑结构设计。  
此类题目要求考生认真阅读题目中的需求描述，配合已给出的E-R图，理解概念结构设计中设计者对实体及联系的划分和组织方法，结合需求描述完成E-R图中空缺部分，并使用E-R图向关系模式的转换方法，完成逻辑结构设计。  
根据所给E-R图，结合需求描述，购物车作为顾客和商品之间的联系，而订单由顾客从购物车中选择商品生成，因此将购物车这一联系当作实体，与订单实体产生联系。将联系当作实体参与另一联系，称为聚合，通常当后一联系与此联系相关时，采用这种设计方法。顾客可以从购物车中生成多个订单，一个订单只能从一个购物车里提取商品，属于一对多联系。  
根据需求描述中的“分拣后的商品交由配送员根据配送单上的收货地址进行配送。”可以知道，配送是与分拣联系相关的联系，同样的，将分拣联系进行聚合，参与配送联系，同时参与配送联系的还有配送员和地点，为多对多对多联系，语义为配送员根据分拣结果按照收货地点进行配送，与需求相符。  
  
【问题2】  
(a)所在仓库  
(b)支付凭证  
(c)订单ID  
  
本小题考核E-R图向关系模式的转换。由于E-R图中没有画出实体及联系的属性，需要根据需求描述进行补充。根据需求中的“一种商品只能放在一个仓库中”和“一份订单所含的多个商品可能由多名分拣员根据商品的所在仓库信息从仓库中进行分拣操作”，可以确定“所在仓库”作为商品实体的属性，转入商品关系中。  
订单关系由E-R图中的订单实体和一对多联系网购合并而成，取一方的主码，即购物车这一联系的主码，为参与该联系的实体的主码商品条码和顾客编号，加上网购联系的属性数量，并入到订单实体转成的关系模式中。订单ID为订单实体的标识符，订单实体的其他属性需要通过需求描述中获取。根据需求“订单生成后，由顾客选择系统提供的备选第三方支付平台进行电子支付，支付成功后系统需要记录唯一的支付凭证编号”，支付凭证编号应为订单的属性，转入订单关系中。  
E-R图中的分拣联系为分拣员与订单之间的多对多联系，转换成独立的分拣关系模式，应包含分拣员实体的标识符分拣员工号和订单实体的标识符订单ID，及分拣联系的属性分拣时间。  
  
【问题3】  
补充内容如图中虚线所示：  
![a8124950c6664cd3bc210a8f82277b69.jpg][]  
  
实体店的订单是营业员根据销售结果生成的，将销售联系聚合成实体，与订单产生联系。一笔销售对应一个订单，一个订单对应一笔销售，为一对一联系。转换为关系模式时，将此联系归入订单关系，即取销售的标识符销售ID加入到订单关系模式中。  


## 第3题 ##

【问题1】  
U1: Run  
U2: Step  
U3: Write  
U4: Read  
U5: Left  
U6: Move  
注：U1和U2可以互换；U4~U6可以互换。  
  
本题属于经典的考题，主要考查面向对象分析方法与设计的基本概念。在建模方面，本题涉及到了UML的类图和用例图。本题的考点比较常规，题目难度不大。  
在图3-1的用例图中，需要确定6个用例。在面向对象方法中，用例及用例图是描述功能需求的工具，每个用例表示一个单一的功能单元。通过对【说明】中功能描述的阅读，可以将未出现在图3-1中的功能单元列举出来：Run、Step、Move、Left、Read和Write。下面就是要判断这6个用例在图中的对应关系了。由图3-1可知，U3中包含了Show Errors的功能，所以U3只能对应用例“Write”。其余的没有严格的顺序要求，但是在回答【问题2】时要根据所填写的用例来判断用例之间的关系。这里我们按照下列顺序填写：U1-&gt;Run；U2-&gt;Step；U3-&gt;Write；U4-&gt;Read；U5-&gt;Left；U6-&gt;Move。  
  
【问题2】  
U1~U2与Run Program有关系；是泛化关系  
U3~U6与Manipulate Robots有关系；是泛化关系  
  
图3-1中没有将用例之间的关系完整地给出来，因此需要根据【说明】中的功能描述判定U1~U6与其他用例之间的关系。根据【说明】中的描述可知，Run和Step是Run Program的两种具体方式，所以这3个用例之间是有关系的，在UML用例图中，这种关联通常采用泛化关系描述。同理，U3~U6用例是用例Manipulate Robots的4种具体实现方法，因此这5个用例之间也是泛化关系。  
  
【问题3】  
C1: World  
C2: Robot/Robots  
C3: Instruction  
C4: InstructionSet  
C5: Error/Errors  
  
本题要求将类图中缺失的5个类补充完整。在解答此类题目时，首先考虑类图中的特殊关系，如继承关系、聚集或组合关系等，这是比较好的突破口。另外应关注类之间的多重度。在图3-2中出现了两个聚集关系：C1和C2之间以及C3和C4之间。我们先考虑C1和C2这一对，因为这两个类之间的多重度是一个具体的范围1..2。【说明】中有一句话：“用户通过操作仿真系统中的1~2个机器人来探索虚拟世界”，也就是说在虚拟世界中包含着1-2个机器人，由此可以推断C2对应的是机器人Robot/Robots，Cl代表的就是整个虚拟世界World。  
下面我们来看C3和C4这一对聚集关系。C4和Interpreter、Parser有关联，而这两个类与文件及机器人指令集的解析有关，由此可以推断，C3、C4这两个类也应该跟解析功能相关。由【说明】可知，系统中有两类需要解析的事物：虚拟世界文件和机器人指令集，而机器人指令集是由若干条指令构成的，这里就出现了一个聚集结构。因此C3应该对应Instruction，C4对应的是InstructionSet。  
对于最后一个类，将功能需求与用例图再回顾一遍，发现在类图中还缺少关于错误信息的描述，因此C5所对应的就是类Error。  


## 第4题 ##

【问题1】  
（1）size\[1\]\[j\]=1  
（2）size\[i\]\[j\]=size\[i-1\]\[j\]  
（3）net\[m++\]=i或其等价形式  
  
一般不要求考生设计问题的求解算法，但要求考生能够理解题目给出的算法设计思路，并补充C程序。如本题中的空(1)，可以根据题干中递归式第一部分和C代码中的注释，得到答案size\[1\]\[j\]=1。  
![9abba0ea3e904cc09cab7685d7fe7b9e.jpg][]  
空(2)则根据阅读题干中递归式第二部分和C代码中的注释，得到答案size\[i\]\[j\]=size\[i-1\]\[j\]。  
![4d327d139b734c5fbf3277f7f868d89f.jpg][]  
  
【问题2】  
（4）动态规划算法  
（5）O(n2)  
（6）O(n)  
  
题干在叙述过程中，较明显的提到了动态规划策略的几个特点，如最优子结构，递归式，自底向上求解等，因此这是一个动态规划算法。算法的时间复杂度分析也较简单。函数maxNum中有两重循环，时间复杂度为0(n2)。函数constructSet中有一重循环，时间复杂度为O(n)。  
  
【问题3】  
(7)4  
(8)(3，4)(5，5)(7，9)(9，10)  
  
本问题考查该算法的一个实例，理解了题干就可以直接计算出该实例的解，即最大不相交连接数为4，连线为：(3，4)(5，5)(7，9)(9，10)。  


## 第5题 ##

【问题1】  
（1）Address\*address;  
（2）address-&gt;street();  
（3）address-&gt;zip();  
（4）address-&gt;city();  
（5）DutchAddress\*addrAdapter = new DutchAddressAdapter(addr)  
  
本题考查Adapter(适配器)模式的基本概念和应用。  
Adapter模式的设计意图是，将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  
Adapter模式有两种实现方式。类适配使用多重继承对一个接口与另一个接口进行匹配，其结构如图5-2所示。  
![08c449a10adb426288cf66f0c6eed5ae.jpg][]\\  
对象适配器依赖于对象组合，其结构如图5-3所示。  
![5ad196c7240c434680abf712cc93f558.jpg][]  
定义Client使用的与特定领域相关的接口。  
Client与符合接口的对象协同。  
Adaptee定义一个已经存在的接口，这个接口需要适配。  
Adapter对Adaptee的接口与Target接口进行适配。  
Adapter模式适用于：  
想使用一个己经存在的类，而它的接口不符合要求。  
想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作。  
(仅适用于对象Adapter)想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配他们的接口。对象适配器可以适配它的父类接口。  
本题中釆用对象适配器，题中类DutchAddressAdapter对应图5-3中的Adapter、DutchAddress对应图5-3中的Target、Address对应图5-3中的Adaptee。  
由图5-3可知，在Adapter中应该有一个Adaptee的对象，因此空(1)处应该填写的是Address的对象：Address\*address。  
类DutchAddress的实现釆用了C++中的抽象类，作为其子类DutchAddressAdapter，必须对DutchAddress中的3个纯虚拟函数进行重置，所以空(2)~(4)是在考查这3个纯虚拟函数在子类中的实现方式。由图5-3可知，Adapter中方法的实现方式还是要借助于Adaptee中所提供的行为，也就是说，DutchAddressAdapter中3个纯虚拟函数的实现与Address是密不可分的。由此可知，空(2)~(4)分别应填入：address-&gt;street()、address-〉zip()和address-&gt;city()0  
第(5)空考查Adapter模式的使用。这里调用普通函数testDutch来进行测试，这个函数要求传递DutchAddress类型的参数，并且给出了实参的名字：addrAdatper，，因此第(5)空应该填写的是addrAdapter的创建语句，这里需要使用到DutchAddress的构造函数。因此第(5)空应填写：DutchAddress\*addrAdapter=new DutchAddressAdapter(addr)。  


## 第6题 ##

【问题1】  
（1）Address address;  
（2）address.street();  
（3）address.zip();  
（4）address.city();  
（5）DutchAddress addrAdapter=new DutchAddressAdaptor(addr)  
  
本题考查Adapter(适配器)模式的基本概念和应用。  
Adapter模式的设计意图是，将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  
Adapter模式有两种实现方式。类适配使用多重继承对一个接口与另一个接口进行匹配，其结构如图6-2所示。  
![a5fd84c2e0c045b782858778e75b8916.jpg][]  
对象适配器依赖于对象组合，其结构如图6-3所示。  
![524626ec0eed4575ac443f7dd672edee.jpg][]  
    本题中釆用对象适配器，题中类DutchAdddressAdapter对应图6-3中的Adapter、DutchAddress对应图6-3中的Target、Address对应图6-3中的Adaptee。  
    由图6-3可知，在Adapter中应该有一个Adaptee的对象，因此空(1)处应该填写的是Address的对象：Addressaddress。  
    空(2)~(4)考查父类中的3个方法在子类DutchAddressAdapter的实现方式。由图6-3可知，Adapter中方法的实现方式还是要借助于Adaptee中所提供的行为，也就是说，DutchAddressAdapter中3个方法的实现与Address是密不可分的。由此可知，空(2)~(4) 分别应填入：address.street()、address.zip()和address.city()。  
第(5)空考查Adapter模式的使用。这里使用方法testDutch来进行测试这个方法要求传递DutchAddress类型的参数，并且给出了实参的名字：addrAdatper。因此第(5)空应该填写的是addrAdapter的创建语句，这里需要使用到DutchAddress的构造函数。因此第(5)空应填写：DutchAddressaddrAdapter=new DutchAddressAdapter(addr)。  



[6b378da9b534452cbec8eb833c5b49b5.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/6b378da9b534452cbec8eb833c5b49b5.jpg
[3b5e77a01cd340e0ab46885adcf4587a.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/3b5e77a01cd340e0ab46885adcf4587a.jpg
[a8124950c6664cd3bc210a8f82277b69.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/a8124950c6664cd3bc210a8f82277b69.jpg
[9abba0ea3e904cc09cab7685d7fe7b9e.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/9abba0ea3e904cc09cab7685d7fe7b9e.jpg
[4d327d139b734c5fbf3277f7f868d89f.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/4d327d139b734c5fbf3277f7f868d89f.jpg
[08c449a10adb426288cf66f0c6eed5ae.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/08c449a10adb426288cf66f0c6eed5ae.jpg
[5ad196c7240c434680abf712cc93f558.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/5ad196c7240c434680abf712cc93f558.jpg
[a5fd84c2e0c045b782858778e75b8916.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/a5fd84c2e0c045b782858778e75b8916.jpg
[524626ec0eed4575ac443f7dd672edee.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/524626ec0eed4575ac443f7dd672edee.jpg
