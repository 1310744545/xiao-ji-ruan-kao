---  
title: 2011年上半年  
# icon: gears  
order: 996  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1: 病人  
E2: 护理人员  
E3: 医生。  
本问题考查顶层DFD。顶层DFD —般用来确定系统边界，将待开发系统看作一个加工，因此图中只有唯一的一个处理和一些外部实体，以及这两者之间的输入输出数据流。题目要求根据描述来确定图中的外部实体。分析题目中的描述，并结合已经在顶层数据流图中给出的数据流进行分析。从中可以看出，与系统的交互者包括病人、医生和护理人员。其中，本地监控定期获取病人的生命特征，病人是生命特征数据来源，医生和护理人员提出相关请求，并得到相关报告结果，如请求病人生命特征报告，并获得相关报告。医生还需要在必要时添加或更新生命特征范围。对应图1-1中数据流和实体的对应关系，可知E1为病人，E2为护理人员，E3为医生。  
  
【问题2】  
D1: 为生命特征范围文件;  
D2: 为日志文件;  
D3: 为病例文件;  
D4: 为治疗意见文件。  
本问题考查0层DFD中数据存储的确定。根据说明中描述：（2）格式化生命特征： 对病人的各项重要生命特征数据进行格式化，然后存入日志文件并检查生命特征；（4）维护生命特征范围：医生在必要时（如新的研究结果出现时）添加或更新生命特征值的正常范围；（6）生成病历：根据日志文件中的生命特征，医生对病人的病情进行描述，形成病历存入病历文件；（8）生成治疗意见：根据日志文件中的生命特征和病历，医生给出治疗意见，如处方等，并存入治疗意见文件。因此，D1为生命特征范围文件，D2 为日志文件，D3为病例文件，D4为治疗意见文件。  
  
【问题3】  
![f1d6c83572714951ad5678cc888e8aa0.jpg][]  
  
【问题4】  
不可以  
本问题考查绘制DFD时的注意事项。在DFD中，每条数据流的起点和终点之一必须是加工（处理)。本题中，医生和护理人员根据查询到的治疗意见对病人进行治疗属于系统之外的行为，所以两个实体之间不可以有数据流。  


## 第2题 ##

【问题1】  
![0314af600f704cf29a31b1a368fde57f.jpg][]  
本问题考查数据库的概念结构设计，题目要求补充完整实体联系图中的联系和联系的类型。  
根据题目的需求描述可知，一个库管员可以管理多个仓库，每个仓库有一名库管员。所以，仓库实体和库管员实体之间存在“管理”联系，联系的类型为多对一（\*:1)。  
根据题目的需求描述可知，一个仓库中可以存放多类服装，一类服装可能存放在多个仓库中。所以，仓库实体和服装实体之间存在“存放”联系，联系的类型为多对多（\*:\*)。  
根据题目的需求描述可知，一个采购订单可以包含多类服装，每类服装可由多个不同的供应商供应。所以，采购订单实体与服装实体和供应商实体三者之间存在“采购” 联系，三者之间联系的类型为多对多对多（\*:\*:\*)。  
根据题目的需求描述可知，一个供应商可以供应多类服装，一类服装可由多个供应商供应。所以，供应商实体和服装实体之间存在“供应”联系，联系的类型为多对多（\*:\*)。  
  
【问题2】  
(1) 仓库编码，库管员编码  
(2) 供应商编码，服装编码  
(3) 订单编码，订货日期，应到货日期  
(4) 订单编码，服装编码，供应商编码，数量，釆购价格  
  
本问题考查数据库的逻辑结构设计，题目要求补充完整各关系模式，并给出各关系模式的主键。  
根据实体联系图和需求描述，系统记录库管员的库编码、姓名和级别。所以，对于“库管员”关系模式，需补充属性“库管员编码”。  
根据实体联系图和需求描述，仓库信息主要包括：仓库编码、仓库位置、仓库容量和库管员。对于“仓库信息”关系模式，由于仓库实体与库管员实体有多对一联系，需记录对应的库管员，并且需补充属性——仓库编码。因此，“仓库信息，，关系模式，需补充属性“仓库编码”和“库管员编码”。  
根据实体联系图和需求描述，供应商信息包括：供应商编码、供应商名称、地址、企业法人和联系电话。所以，对于“供应商”关系模式，需补充属性“供应商编码”。  
根据实体联系图和需求描述，“供应情况”关系模式，需记录供应商和服装的多对多联系，即一个供应商可以供应多类服装，一类服装可由多个供应商供应。所以，对于“供应商”关系模式，需补充属性“供应商编码”和“服装编码”。  
根据实体联系图和需求描述，采购订单主要记录订单编码、订货日期和应到货日期。所以，对于“采购订单”关系模式需补充属性：订单编码、订货日期和应到货日期。由于采购订单还需详细记录所采购的每类服装的数量、采购价格和对应的多个供应商。因此，“采购订单明细”关系模式，需记录采购订单实体与服装实体和供应商实体三者之间 存在的多对多对多联系。对于“采购订单明细”关系模式，需补充属性：订单编码、服装编码、供应商编码、数量和采购价格。  
  
【问题3】  
![c6ea4d4ed2f84f9687665ce6c9d1dbb7.jpg][]  
本问题考查的是数据库的概念结构设计，根据新增的需求增加实体联系图中的实体的联系和联系的类型。  
根据问题描述，多个库管员需对每个仓库中的每一类被抽查服装记录一条抽查结果。则在库管员实体与仓库实体和服装实体三者之间存在“抽查”联系，联系的类型是多对多对多(\*:\*:\*)。  


## 第3题 ##

【问题1】  
U1：移动元素  
U2: 调整元素大小。  
U1、U2可互换  
本问题主要考查用例之间的关系。在UML中，用例之间有3种关系：包含（include）、 概括（generalize）和扩展（extend）。  
如果多个用例中都含有相同的事件流，那么可以将其抽取出来放在一个单独的用例中，其他用例都可以通过包含（include)这个用例来使用其中的事件流。包含关系可以避免在多个用例的描述中重复拷贝相同的事件流。  
概括关系是指子用例（child use case)继承父用例（parent use case)的行为，而子用例本身还可以增加新的行为或重置父类的某些行为。这种关系与面向对象程序设计中的“继承”很类似。  
一个用例（基础用例，base use case)中加入一些新的动作后则构成了另外一个用例 (扩展用例，extending use case)，那么这两个用例之间的关系就是扩展关系。扩展关系与概括关系有相似之处，但是比概括关系更为严格。基础用例必须声明特定的扩展点，而扩展用例只能在这些扩展点上添加新行为。  
由说明可知，图形编辑器的基本操作为创建图形、创建元素、选择元素和删除图形。对照图3-1，可知这些最终都被确定为用例。除此之外，用例“创建图元”、“创建文本” 与用例“创建元素”之间是概括关系，即能创建的元素分别是图元和文本。图3-1中缺少了两个用例，而这两个用例都是与“选择元素”相关的。因此需要仔细阅读说明中关于“选择元素”的描述，其中最关键的一句描述为“拖拽选定元素的控制点，可以移动元素或者调整元素的大小”。这句话中出现了两个动词短语“移动元素”、“调整元素大小”，这两个动作都是要先选择对应元素之后，才能实施的。因此，可以推出，U1和U2 应对应“移动元素”和“调整元素大小”。  
  
【问题2】  
下一步就是确定“移动元素”、“调整元素大小”与“选择元素”之间的关系。由说明可知，必须先选择元素才能通过拖拽控制点来对元素进行相应的操作。因此，“移动元素”和“调整元素大小”是对“选择元素”的扩展，因此这三个用例之间应该是扩展关系。（1）和（2）处应填写extend。  
本问题考査类图，考点是类层次结构及多重度。图3-2中有两个非常明显的继承结构，需要考生将其填充完整。这两个继承结构的最顶层父类分别是“工具”和“元素”，这就需要仔细阅读说明中与这两个词汇相关的描述。说明中第一次出现“工具”这个词，是在句子“编辑器提供了两种操作图形的工具：选择工具和创建工具”。这是典型的一般/特殊关系的描述，由此可以推断出，C1和C2应该对应“选择工具”和“创建工具”， 到底是怎样的对应关系，还需要进一步的细节信息。说明中的①给出“创建工具用于创建文本元素和图元元素”，而C1的一个子类就是“文本工具”，所以可以确定C1是“创建工具”，C2是“选择工具”。那么C3~C5应该就是与创建图元元素相关的工具了，而图元分为三类：线条、矩形和椭圆。所以C3~C5分别对应“线条工具”、“矩形工具” 和“椭圆工具”。  
现在图3-2中左边的继承结构已经填充完整了。右边的继承结构就可以对应地填写出来了，C6~C8分别对应的是类“线条”、“矩形”和“椭圆”。  
确定多重度时，需要在说明寻找关联两端的类相关的描述。“对图形进行操作时，一次只能使用一种工具（即当前活动工具，active)”，即在图形编辑器中一次只能使用一个工具，而任何一个工具只属于这个图形编辑器。所以（3）处应填0..1，（4）处应填1。  
一个图形可以包含多个元素，对于一个图形中的特定元素来说，只能属于这个图形。所以（5）处应填1，(6)处应填1..\*或\*。  
  
【问题3】  
桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化，对一个抽象的实现部分的修改应该对使用它的程序不产生影响。  
本问题考查桥接模式，该模式将抽象部分与其实现部分分离，使它们都可以独立地变化。  
在以下情况中可以使用Bridge模式：  
(1) 不希望在抽象以及抽象的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻可以选择或切换实现部分。  
(2) 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充，使用Bridge模式可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。  
(3) 对一个抽象的实现部分的修改应该对用户不产生影响，即客户的代码不必重新编译。  


## 第4题 ##

【问题1】  
根据题中说明，第3到第5行代码进行c数组的初始化，c数组的长度为R，在C语言中，下标从0开始，因此空格（1）中填写R。第6到第8行检查a数组的每一个元素。如果元素的值为i，则增加c\[i\]的值。因此c\[a\[i\]\] = c\[a\[i\]\] + 1，空格(2)填写c\[a\[i\]\]+l。 完成第6行到第8行的代码后，c\[i\]中就存放了等于i的元素的个数。第9到第11行， 通过在数组c中记录计数和，c\[i\] = c\[i - 1\] + c\[i\],可以确定对每一个i=0，1，…，R-1,有多 少个元素是小于或等于i的。因此空格(3)填写c\[i - 1\] + c\[i\]o第12行到第15行把数组a中每个元素a\[i\]放在输出数组b中与其相应的最终位置上，b\[c\[a\[i\]\] - 1\] =a\[i\]，因 此空格（4）填写a\[i\]。由于可能存在相同元素，因此每次将一个值a\[i\]放入数组b中时， 都要减小c\[i\]的值。下面以一个例子来说明排序过程。  
设a= \{4，1，3,4,3,4\}，R = 5,即待排序的元素值在\{0，1，2,3,4\}中，其排序过程如下图 所示。  
图中(a)为输入数组a，(b)为初始化后的c数组，(c)为统计数组a中每个元素 后的c数组，(d)为计数和，即统计小于等于i的元素个数后的c数组。(e)到(j)是 将a数组中的元素依次放到b数组的过程，(k)是数组a和数组b的元素对应关系。  
![58bf8fec526246dfa5749a845ad65803.jpg][]  
  
【问题2】  
![c8b934f7fd08456d8c127f63a5a55cc6.jpg][]  
  
![67693ec339c941699f7d2632e71b68ed.jpg][]  
  
【问题3】  
![d5673c485edc409b89058bcbbc7f699a.jpg][]  
从图(k)可以看出，算法不稳定。算法不稳定的原因在于将数组a中元素放到数组b中时，是从数组a的第一个元素开始，依次取出元素放到数组b中。这样，相.同的两个元素值，在数组a中的相对位置和在数组b中的相对位置正好相反。若从数组a的最后一个元素开始，依次向前取元素放到b数组中，可以保持相同元素的相对位置。因此将第12行的代码for(i = 0; i&lt; n;i++)改为for(i = n-l;i&gt;=0;i--),则排序算法是稳定的。  


## 第5题 ##

【问题1】  
(1) virtual void add(MenuComponent\* menuComponent) = 0  
(2) MenuComponent \*  
(3) menuComponents.push\_back(menuComponent)  
(4) (\*iter)  
(5) allMenus  
  
Composite模式将对象组合成树形结构以表示“整体-部分”的层次结构，其中的组合对象使得你可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。Composite模式使得用户对单个对象和组合对象的使用具有一致性。  
Composite模式的结构下图所示。  
![b7e37a9f622d4def8f93ca746a8bbdec.jpg][]  
其中：  
•类Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为，声明一个接口用于访问和管理Component的子部件；  
•类Leaf在组合中表示叶节点对象，叶节点没有子节点；并在组合中定义图元对象的行为：  
•类Composite定义有子部件的那些部件的行为，存储子部件，并在Component 接口中实现与子部件有关的操作：  
•类Client通过Component接口操纵组合部件的对象。  
下列情况可以使用Composite模式：  
(1) 表示对象的整体-部分层次结构；  
(2) 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所 有对象。  
试题五将组合模式应用到饭店菜单的构造中。图5-2中的类MenuComponent对应上图中的Component, MenuItem对应Leaf, Menu对应Composite。在实现时，通常都会把Component定义为抽象类。  
在C++中，抽象类是指至少包含一个纯虚拟函数的类。类MenuComponent中已经包含了一个纯虚拟函数print，所以MenuComponent已经是一个抽象类了。（1）处根据注释，这里应该定义功能为“添加新菜单”的成员函数。在子类MenuItem和Menu中可以看到，都有add成员函数，说明子类中重置了父类中的成员函数。所以(1)处的成员函数也应该定义为纯虚拟函数，即virtual void add(MenuComponent\* menuComponent) = 0。  
由图5-2可以看出，Menu中包含了 MenuComponent的对象集合。程序中用C++标准模板库中的list来实现这个聚集关系。因此(2)处应填入MenuComponent \*。由于使用了list，就可以利用list中提供的各种方法了。list中用于添加元素的方法是push\_back，所以（3）处应填入 menuComponents.push\_back(menuComponent)»  
(4) 处出现在方法print中，其功能是打印出所有菜单的信息。这里使用了list中的迭代器类iterator,遍历每个子菜单，并调用子菜单中定义的print方法打印该子菜单的 信息。(4)处应填入\*iter。为了能够在main中打印出所有的菜单信息，必须使用表示菜单结构中最顶层菜单的对象来调用print，因此(5)处应填入allMenus。  


## 第6题 ##

【问题1】  
(1) abstract class 或 public abstract class  
(2) public abstract void add(MenuComponent menuComponent)  
或 abstract void add(MenuComponent menuComponent)  
或 protected abstract void add(MenuComponent menuComponent) ,  
(3) add(menuComponent)  
(4) menuComponent.print()  
(5) allMenus.print()  
  
Composite模式将对象组合成树形结构以表示“整体-部分”的层次结构，其中的组合对象使得你可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。 Composite模式使得用户对单个对象和组合对象的使用具有一致性。  
Composite模式的结构下图所示。  
![2161075d5b874690b78f079b2db8fe81.jpg][]  
其中：  
•类Component为组合中的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为，声明一个接口用于访问和管理Component的子部件：  
•类Leaf在组合中表示叶节点对象，叶节点没有子节点；并在组合中定义图元对象的行为；  
•类Composite定义有子部件的那些部件的行为，存储子部件，并在Component 接口中实现与子部件有关的操作；  
•类Client通过Component接口操纵组合部件的对象。  
下列情况可以使用Composite模式：  
(1) 表示对象的整体-部分层次结构；  
(2) 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。  
试题六将组合模式应用到饭店菜单的构造中。图6-2屮的类MenuComponent对应上图中的Component，MenuItem对应Leaf，Menu对应Composite。在实现时，通常都会把Component定义为抽象类。  
在Java中，用abstract关键字限定的类即为抽象类，所以（1）处应填入abstract class。  
(2)处根据注释，这里应该定义功能为“添加新菜单”的成员函数。在子类MenuItem和Menu中可以看到，都有add成员函数，说明子类中重置了父类中的成员函数。所以(2) 处应填入 public abstract void add(MenuComponent menuComponent)。  
由图6-2可以看出，Menu中包含了MenuComponent的对象集合。程序中用Java中的list来实现这个聚集关系，这样就可以利用list中提供的各种方法了。list中用于添加元素的方法是add,所以（3）处应填入add(menuComponent)。  
(4) 处出现在方法print中，其功能是打印出所有菜单的信息。这里使用了list中的迭代器类iterator,遍历每个子菜单，并调用子菜单中定义的print方法打印该子菜单的信息。（4）处应填入menuComponent.print()。  
为了能够在main中打印出所有的菜单信息，必须使用表示菜单结构中最顶层菜单的对象来调用print，因此（5）处应填入allMenus.print()。  



[f1d6c83572714951ad5678cc888e8aa0.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/f1d6c83572714951ad5678cc888e8aa0.jpg
[0314af600f704cf29a31b1a368fde57f.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/0314af600f704cf29a31b1a368fde57f.jpg
[c6ea4d4ed2f84f9687665ce6c9d1dbb7.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/c6ea4d4ed2f84f9687665ce6c9d1dbb7.jpg
[58bf8fec526246dfa5749a845ad65803.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/58bf8fec526246dfa5749a845ad65803.jpg
[c8b934f7fd08456d8c127f63a5a55cc6.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/c8b934f7fd08456d8c127f63a5a55cc6.jpg
[67693ec339c941699f7d2632e71b68ed.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/67693ec339c941699f7d2632e71b68ed.jpg
[d5673c485edc409b89058bcbbc7f699a.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/d5673c485edc409b89058bcbbc7f699a.jpg
[b7e37a9f622d4def8f93ca746a8bbdec.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/b7e37a9f622d4def8f93ca746a8bbdec.jpg
[2161075d5b874690b78f079b2db8fe81.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/2161075d5b874690b78f079b2db8fe81.jpg
