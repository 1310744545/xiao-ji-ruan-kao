---  
title: 2017年上半年  
# icon: gears  
order: 984  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1：供应商  
E2：采购部  
E3：检验员  
E4：库管员  
E5：S/R职员  
  
本题考查采用结构化方法进行系统分析与设计中对数据流图（DFD)的应用，考点与往年类似，要求考生细心分析题目中所描述的内容。题干描述清晰，易于分析。  
DFD是面向数据流建模的结构化分析与设计方法的工具。DFD将系统建模成输入、加工（处理)、输出的模型，即流入软件的数据对象经由加工的转换，最后以结果数据对象的形式流出软件，并采用自顶向下分层且逐层细化的方式，建模不同详细程度的数据流图模型。  
上下文数据流图（顶层DFD)通常用来确定系统边界，将待开发系统看作一个大的加工，然后根据为系统提供输入数据流，以及接受系统发送的数据流，来确定系统的外部实体，以及外部实体和加工之间的输入输出数据流。  
在上下文图中确定的系统外部实体以及与外部实体的输入输出数据流的基础上，将上下文DFD中的加工分解成多个加工，识别这些加工的输入数据流以及结果加工变换后的输出数据流，建模0层DFD。根据0层DFD中加工的复杂程度进一步建模加工的内容。  
在建模分层DFD时，根据需求情况可以将数据存储建模在不同层次的DFD中。建模时，需要注意加工和数据流的正确使用，一个加工必须既有输入又有输出；数据流必须和加工相关，即从加工流向加工、数据源流向加工或加工流向数据源。注意要在绘制下层数据流图时要保持父图与子图平衡。  
本问题考查的是上下文DFD，要求确定外部实体。在上下文DFD中，待系统名称 “采购系统”作为唯一加工的名称，外部实体为这一唯一加工提供输入数据流或者接收其输出数据流。通过考査系统的主要功能发现，系统中涉及到供应商、采购部、检验员、库管员以及S/R职员。根据说明1中“采购部门每天检查部件库存量”，说明2中“向其供应商下达采购订单”、说明3. (1)中“并将提单信息发给S/R职员”，3. (2)中“并将已验证的提单发给检验员”，以及3. (3)中“库管员根据收到的接收的部件列表添加本次采购数量”等信息，对照图M，从而即可确定E1为“供应商”实体，E2为“采购部”实体，E3为“检验员”实体，E4为“库管员”实体，E5为“S/R职员”实体。  
  
【问题2】  
D1：库存  
D2：采购订单  
D3：质量标准  
D4：供应商  
(注：名称后面可以带有“文件”）  
  
本问题要求确定图1-2 0层数据流图中的数据存储。重点分析说明中与数据存储有关的描述。说明1中“每天检查部件库存量”以及说明3. (3)中“与原有库存量累加来更新库存部件中的库存量”，可知D1为库存；说明2中“向其供应商（通过供应商文件访问供应商数据）下达采购订单，并存储于采购订单文件中”，可知D2为采购订单、D4 为供应商；说明3. (2)中“通过访问质量标准来检查装运部件的质量”，可知D3为质量标准。  
  
  
【问题3】  
![b29cc98faab0409baadd4cf210abd89d.jpg][]  
本问题要求补充缺失的数据流及其起点和终点。对照图1-1和图1-2的输入、输出数据流，缺少了从加工到外部实体E1 (供应商）的数据流—“通知”，根据说明中发给供应商的通知分为两种情况，一种是在验证装运部件时出现不符合采购订单和提单信息的情况下，“将S/R职员提交的装运错误信息生成装运错误通知发送给供应商”；另一种情况是在检验部件质量时，“如果部件未通过检查，则将检验员创建的缺陷装运信息生成缺陷装运通知发送给供应商”。所以缺少了两条数据流，加工“验证装运部件”流出的数据流“装运错误通知”和加工“检验部件质量”流出的数据流“缺陷装运通知”，这两条数据流的综合即为上下文DFD中的“通知”。  
再考查说明中的功能判定是否缺失内部的数据流，不难发现缺失的数据流。先考查说明3. (2)中“如果收货部件项目出现在采购订单和提单上，则已验证的提单和收货部件项目将被送去检验”，发现在图1-2中缺失，起点为“验证装运部件”，终点为“更新部件库存”。再说明3. (3)中“与原有库存量累加来更新库存部件中的库存量”，加工“更新部件库存”需要从数据存储“库存（D1)”中取出原有部件库存量，与“接收到的部件量”累加后得到“更新部件数量”更新库存部件中的库存量，图1-2中缺失了从D1到P5的数据流“原有部件库存量”。  
  
【问题4】  
图1-1 (或父图）中某加工的输入输出数据流必须与图1-2 (或子图）的输入输出数据流在数量和名字上相同；图1-1 (或父图）中的一个输入（或输出）数据流对应于图1-2 (或子图）中几个输入（或输出）数据流，而图1-2 (或子图）中组成这些数据流的数据项全体正好是父图中的这一条数据流。  
  
在自顶向下建模分层DFD时，会因为加工的细分而发生数据流的分解情况，需要注意保持数据流图之间的平衡（本题中图1-1和图1-2)。父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一条数据流。  


## 第2题 ##

【问题1】  
补充内容如下图中虚线所示。  
![6d6ab67823ea4f048e6a9d82438cb2c3.jpg][]  
  
本题考查数据库概念设计及逻辑设计中E-R图向关系模式的转换方法。  
此类题目要求考生认真阅读题目中对需求问题的描述，经过分类、聚集、概括等方法，从中确定实体及其联系。题目已经给出了6个实体以及部分实体之间的联系，需要根据需求描述，将实体之间联系补充完整。  
题目中已经给出了租客与公寓间的租赁关系，由“一份租赁合同通常由一个或多个租客（合租）与该公寓楼的经理签订”可知，需要建立经理和“租客与公寓间的租赁关系”之间的联系，即将联系作为实体，参与下一次联系，使用聚合的方法。因此，最后的结果如参考答案图中虚线部分所示。  
  
【问题2】  
(a) 业务技能  
(b) 楼编号  
(c) 月租金  
  
从需求描述4中“系统需记录每个维修工的业务技能”，可知员工的属性信息需要业务技能属性。由需求1中“每幢公寓楼有唯一的楼编号和地址”，可知楼编号是唯一的，不会重复，可作为公寓楼的主键属性。需求5中说明了合同的属性信息中包含签定日期、开始时间、租期、押金、月租金，模式中还缺少月租金属性。完整的关系模式如下：  
![9f7b8f5459a44fc1a6050f95a1736b0f.jpg][]  
ER图的补充方式不唯一，补充内容如ER图一或ER图二中虚线所示。  
ER图一  
![25d8368f37ae45eca8b47131f6fc53c0.jpg][]  
ER图二  
![4af5ec777061466cb64633d9a9c04c72.jpg][]  
  
【问题3】  
关系模式：维修记录（故障编号，租客编号，楼编号，公寓号，故障描述，员工编号，维修日期，维修内容）  
备注：此联系名称能够合理表达需求即可。  
  
此题E-R图不唯一，这里给出两种备选的答案。  
答案一：由“公寓内设施如出现问题，租客可在系统中进行故障登记”，但公寓出现问题的次数不止一次，可知租客和公寓之间存在着m:n联系。系统故障生成之后会派维修工进行维修，因此可建立维修工和特定故障记录之间的联系。  
答案二：也可直接建立租客、公寓和维修工之间的三元联系。  


## 第3题 ##

【问题1】  
（a）C2、C4、C7、C10、C11  
（b）C3、C5、C8  
（c）C1、C6、C9、C12  
  
本题考查面向对象设计方法及应用。  
面向对象设计是一种工程化软件设计规范，其基本思想包括抽象、封装和可扩展性。类封装了信息和行为，是面向对象技术的重要组成部分，类是具有相同属性、方法和关系的对象集合的总称。在系统中，每个类都具有一定的职责，即指类所担任的任务。一个类可以有多种职责，设计得好的类一般至少有一种职责。类图描述了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。状态图是描述一个实体基于事件反映的动态行为，显示了该实体如何根据当前所处的状态对不同的事件作出反应。  
面向对象设计是软件设计师必须掌握的专业知识与技能，特别是需要掌握软件类设计、类图和状态图等设计内容。  
设计类是面向对象设计中最重要的组成部分，也是最复杂和最耗时的部分。面向对象设计过程中，类可以分为三种类型：实体类、控制类和接口类。其中，实体类映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息，主要负责持久化数据的存储；控制类是用于控制用例工作的类，一般是由动宾结构的短语转化来的名词，主要负责业务逻辑的处理；接口类用于封装在用例内、外流动的信息或数据流，主要负责系统与用户之间的交互。在表3-1中，C1 (会员）、C6 (订单表)、C9 (邮箱地址)、C12 (支付方式）主要用来存储信息，所以属于实体类；C3 (计算总价)、C5 (调用支付系统)、C8 (发送完整订单信息）主要用来处理业务逻辑，所以属于控制类；C2 (列出电动玩具清单及价格）、C4 (显示地址和联系方式）、C7 (显示完整订单信息）、CIO (显示清单和定制属性)、C11 (显示默认支付方式）主要用来与用户交互，所以属于接口类。  
  
【问题2】  
X1：收货地址  
X2：支付方式  
X3：邮箱地址  
X4：定制属性  
  
根据创建新订单的用例描述，所设计的系统部分类图如下图所示。所以X1~X4处分别填入的类名：收货地址、支付方式、邮箱地址和定制属性。  
![b728a379ec5f4e1689650003abe150a4.jpg][]  
  
【问题3】  
S1：挂起  
S2：备货  
S3：定制  
S4：发货  
S5：收货  
  
根据订单处理过程的描述，所设计的系统状态图如下图所示。所以S1~S5处分别填入的状态名：挂起、备货、定制、发货和收货。 ![0e52fbbbee864555a8522cee954fdd43.jpg][]  


## 第4题 ##

【问题1】  
(1) first+(last-first) / 2+1或(last+first) / 2+1或(last+first+1) / 2或等价形式  
(2) firstSum &lt; lastSum  
(3) first+(last-first) /2或（last+first) /2或等价形式  
  
本题考查算法设计与分析的相关知识。  
此类题目要求考生掌握常见的算法设计策略，包括分治法、动态规划、贪心法、回溯法和分支限界法，需掌握这些算法设计策略求解问题的特点，并熟悉一些典型的实例。 在做题过程中，认真阅读题目对问题和求解方法的描述。  
题干已经描述了假币问题的求解算法的基本思路。这个题目应该比较简单。已经知道假币的重量较轻。  
C代码中，空（1）所在的代码块是在偶数块硬币的前提下，计算前半部分硬币的重量，因此该空格应填first+(last-first)/2+1。空（2）是判断前半部分firstSum轻还是后半部分lastSum轻，从而确定是在前半部分还是后半部分递归调用，因此该空格应填firstSum&lt;lastSum。空（3）所在的代码块是在奇数块硬币的前提下，判断前半部分和后半部分的重量关系，奇数块硬币还有一枚在中间的硬币，若前半部分和后半部分一样重，那么说明中间这枚硬币是假币，因此空（3）应填入的内容为first+(last-first)/2。  
  
【问题2】  
（4）分治法  
（5）0(lgn)  
  
这是一个典型的分治算法，算法时间复杂度为T(n)=T(n/2)+0(1)=0(lgn)。  
  
【问题3】  
（6）2  
（7）4  
  
对于30枚硬币的情况，首先需要分成两个15枚比较轻重（1次比较)。  
最好的情况是，再进行一次比较时，前7枚和后7枚一样重（1次比较)，此时假币在中间，即第8枚。因此，最少经过2次比较即可确定假币。  
最坏的情况是，前7枚和后7枚不一样重，假设前7枚更轻（1次比较)。此时取出前7枚硬币，继续比较前3枚和后3枚，还是不一样重，假设前3枚更轻（1次比较)。 剩下3枚硬币，再经过一次比较即可确定假币（1次比较）。因此最多经过4次比较即可确定假币。  


## 第5题 ##

【问题1】  
（1）virtual void buildParts()=0  
（2）this-&gt;pizzaBuilder=pizzaBuilder  
（3）pizzaBuilder-&gt;buildParts()  
（4）waiter-&gt;setPizzaBuilder(hawaiian\_pizzabuilder)  
（5）waiter-&gt;construct()  
  
本题考查生成器（Builder)模式的基本概念和应用。  
生成器模式是创建型设计模式中的一种。创建型模式抽象了实例化过程，帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。  
生成器模式是对象创建型模式，其意图是将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。此模式的结构图如下图所示。  
![cadecbddca094cfc8e77d2ff50deba8a.jpg][]  
其中：  
• Builder为创建一个Product对象的各个部件指定抽象接口。  
• ConcreteBuilder实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口。  
• Director构造一个使用Builder接口的对象。  
• Product表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表不并定义  
它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口。客户以及Builder和Director的交互过程如下图所示。  
![ea49cd7a1a564cacb7e3ccea0847b05f.jpg][]  
本题中图5-1类图中的类与上图中类之间存在着对应关系。Waiter与Director对应；PizzaBuilder与Builder对应；HawaiianPizzaBuilder 和SpicyPizzaBuilder与ConcreteBuilder对应，均作为PizzaBuilder的子类，并且，由于本题中检索产品的接口简单一致，所以也定义在父类PizzaBuilder中，而没有分别定义HawaiianPizzaBuilder和SpicyPizzaBuilder中；Pizza与Product对应。其对应的协作为，客户创建Waiter对象并用想要的具体PizzaBuilder对象配置Waiter中定义的PizzaBuilder对象。其中，PizzaBuilder为创建一个Pizza对象的各个部件指定抽象接口，由具体的构建器子类实现。然后使PizzaBuilder进行Pizza对象的构建。  
在PizzaBuilder中定义创建Pizza对象的各个部件制定抽象接口，由于该操作的具体实现在子类HawaiianPizzaBuilder和SpicyPizzaBuilder中，所以此处定义为纯虚函数，即：  
virtual void buildParts ()=0;  
客户（main()函数）创建Waiter对象，并用PizzaBuilder对象进行配置，即在main() 函数中创建一个PizzaBuilder的具体子类的对象并进行Builder的配置，即：  
PizzaBuilder\* hawaiian\_pizzabuilder=new HawaiianPizzaBuilder();  
waiter-&gt;setPizzaBuilder(hawaiian\_pizzabuilder);  
然后开始Pizza的构建，即:  
waiter-&gt;construct();  
上图协作中最后的获取结果在本题中用输出表示，因为创建了HawaiianPizzaBuilder对象，所以输出为cross+mild+ham&pineapple。  
在Waiter中，定义函数setPizzaBuilder()和construct()。其中，setPizzaBuilder()使用客户提供的具体PizzaBuilder对象来设置PizzaBuilder对象，其引用名称为pizzaBuilder，对象中属性的名称和方法参数的名称相同时，釆用this关键字加以区分，即：  
void setPizzaBuilder (PizzaBuilder\* pizzaBuilder) \{ /\*设置构建器\*/  
this-&gt;pizzaBuilder=pizzaBuilder;  
\}  
construct()函数使用所设置的PizzaBuilder对象创建Pizza及其部件，即：  
void construct () \{ /\*构建\*/  
pizzaBuilder-&gt;createNewPizza();  
pizzaBuilder-&gt;buildParts();  
\}  
综上所述，空（1）为定义创建Pizza的对象的各个部件制定抽象接口，即纯虚函数的定义：virtual void buildParts()=0 ；空（2 )为PizzaBuilder对象的设置，即: this-&gt;pizzaBuilder=pizzaBuilder；空（3）为具体PizzaBuilder对象进行Pizza的构建，即: pizzaBuilder-&gt;buildParts()；空（4）和空（5）为客户程序用具体的PizzaBuilder对象设置Waiter中的PizzaBuilder,并通知开始构建，即waiter-&gt;setPizzaBuilder(hawaiian\_ pizzabuilder)和waiter-&gt;construct()。  


## 第6题 ##

【问题1】  
（1）abstract void buildParts()  
（2）this.pizzaBuilder=pizzaBuilder  
（3）pizzaBuilder.buildParts()  
（4）waiter.setPizzaBuilder(hawaiian\_pizzabuilder)  
（5）waiter.construct()  
  
本题考查生成器（Builder)模式的基本概念和应用。  
生成器模式是创建型设计模式中的一种。创建型模式抽象了实例化过程，帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。  
生成器模式是对象创建型模式，其意图是将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。此模式的结构图如下图所示。  
![c8e61deba2bb4cf5a31e174878a331ff.jpg][]  
其中：  
Builder为创建一个Product对象的各个部件指定抽象接口。  
ConcreteBuilder实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口。  
Director构造一个使用Builder接口的对象。  
Product表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表不并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口。  
客户以及Builder和Director的交互过程如下图所示。  
![19e9340f5c794c70958bbfde2033fe57.jpg][]  
本题中图6-1类图中的类与上图中类之间存在着对应关系。Waiter与Director对应；PizzaBuilder与Builder对应；HawaiianPizzaBuilder和Spicy PizzaBuilder与ConcreteBuilder对应，均作为PizzaBuilder的子类，并且，由于本题中检索产品的接口简单一致，所以也定义在父类PizzaBuilder中，而没有分别定义HawaiianPizzaBuilder和SpicyPizzaBuilder中；Pizza与Product对应。其对应的协作为，客户创建Waiter对象并用想要的具体PizzaBuilder对象配置Waiter中的定义的PizzaBuilder对象。其中，PizzaBuilder为创建一个Pizza对象的各个部件指定抽象接口，由具体的构建器子类实现。然后使PizzaBuilder进行Pizza对象的构建。  
在PizzaBuilder中定义创建Pizza对象的各个部件制定抽象接口，由于该操作的具体实现在子类HawaiianPizzaBuilder和SpicyPizzaBuilder中，所以此处定义为抽象方法，即：  
public abstract void buildParts();  
客户（FastFoodOrdering)创建Waiter对象，并用PizzaBuilder对象进行配置，即在main()方法中创建一个PizzaBuilder的具体子类的对象并进行Builder的配置，即：  
PizzaBuilder hawaiian\_pizzabuilder=new HawaiianPizzaBuilder();  
waiter.setPizzaBuilder(hawaiian\_pizzabuilder);  
然后开始Pizza的构建，即：  
waiter.construct ();  
上图协作中最后的获取结果在本题中用输出表示，因为创建了HawaiianPizzaBuilder 对象，所以输出为cross+mild+ham&pineapple。  
在Waiter中，定义方法setPizzaBuilder()和construct()。其中，setPizzaBuilder()使用客户提供的具体PizzaBuilder对象来设置PizzaBuilder对象，其引用名称为pizzaBuilder，对象中属性的名称和方法参数的名称相同时，釆用this关键字加以区分，即：  
void setPizzaBuilder (PizzaBuilder\* pizzaBuilder) \{ /\*设置构建器\*/  
this.pizzaBuilder=pizzaBuilder;  
\}  
construct()方法使用所设置的PizzaBuilder对象创建Pizza及其部件，即：  
void construct () \{ /\*构建\*/  
pizzaBuilder.createNewPizza();  
pizzaBuilder.buildParts();  
\}  
综上所述，空（1）为定义创建Pizza的对象的各个部件制定抽象接口，即抽象方法的定义：abstract void buildParts();空（2）为PizzaBuilder对象的设置，即：this.pizzaBuilder=pizzaBuilder ；空（3）为具体PizzaBuilder对象进行Pizza的构建，即：pizzaBuilder.buildParts()；空（4）为客户程序用具体的PizzaBuilder对象设置Waiter中的PizzaBuilder,即：waiter.setPizzaBuilder(hawaiianjpizzabuilder),空（5）通知开始构建，即：waiter. construct()。  



[b29cc98faab0409baadd4cf210abd89d.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/b29cc98faab0409baadd4cf210abd89d.jpg
[6d6ab67823ea4f048e6a9d82438cb2c3.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/6d6ab67823ea4f048e6a9d82438cb2c3.jpg
[9f7b8f5459a44fc1a6050f95a1736b0f.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/9f7b8f5459a44fc1a6050f95a1736b0f.jpg
[25d8368f37ae45eca8b47131f6fc53c0.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/25d8368f37ae45eca8b47131f6fc53c0.jpg
[4af5ec777061466cb64633d9a9c04c72.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/4af5ec777061466cb64633d9a9c04c72.jpg
[b728a379ec5f4e1689650003abe150a4.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第3题/b728a379ec5f4e1689650003abe150a4.jpg
[0e52fbbbee864555a8522cee954fdd43.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第3题/0e52fbbbee864555a8522cee954fdd43.jpg
[cadecbddca094cfc8e77d2ff50deba8a.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/cadecbddca094cfc8e77d2ff50deba8a.jpg
[ea49cd7a1a564cacb7e3ccea0847b05f.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/ea49cd7a1a564cacb7e3ccea0847b05f.jpg
[c8e61deba2bb4cf5a31e174878a331ff.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/c8e61deba2bb4cf5a31e174878a331ff.jpg
[19e9340f5c794c70958bbfde2033fe57.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/19e9340f5c794c70958bbfde2033fe57.jpg
