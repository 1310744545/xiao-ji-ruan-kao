---  
title: 2014年上半年  
# icon: gears  
order: 990  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1：巴士司机  
E2：机械师  
E3：会计  
E4：主管  
E5：库存管理系统  
  
本题考查的是DFD的应用，属于比较传统的题目，考查点也与往年类似。  
本问题考查的是顶层DFD。顶层DFD通常用来确定系统边界，其中只包含一个唯一的加工（即待开发的系统)、外部实体以及外部实体与系统之间的输入输出数据流。题目要求填充的正是外部实体。  
从题干说明1）没有明确说明由巴士到车库后由谁提供待维修问题，图1-1中的E1，考察说明中3)中最后一句说明“巴士司机可査看已维修机械问题”可以看出，从系统到巴士司机有输出数据流“已维修机械问题”，可知E1为巴士司机。从2)中“机械师根据维修记录文件中的待维修机械问题，完成对巴士的维修，登记维修情况”；再看说明4)中机械师提供维修工时，可以看出，从E2到系统有输入数据流“维修工时”、输出数据流“待维修机械问题”，可知E2为机械师，还将维修总结发送给主管，即系统到E4 有输出数据流“维系总结”，可知E4为主管。从说明5)将维修工时和所用部件成本详细信息给会计，从系统到E3有输出数据流“维修工时和所用部件成本详细信息”，可知E3为会计。说明3)中将所用部件淸单发送给库存管理系统以对部件使用情况进行监控，及系统到E5有输出数据流“所用部件清单”，可知E5为库存管理系统。  
  
【问题2】  
D1：巴士列表文件  
D2：维修记录文件  
D3：部件清单  
D4：人事档案  
  
本问题考查0层数据流图中的数据存储。系统中的主要功能与图1-2中的处理一一对应，1）对应处理“ 记录巴士ID和维修问题”，将巴士ID记录在巴士列表文件中，可知D1为巴士列表文件。说明2）对应处理 “ 确定所需部件 ”，将维修所需部件在部件清单中进行标记，可知以D3为部件清单。说明1）中将待维修机械问题记录在维修记录文件中，可知D2为维修记录文件。说明4）对应处理“ 记录维修工时“，描述了将机械师提供的维修工时记录在人事档案中，可以判定D4是人事档案。  
  
【问题3】  
图1-2中处理3只有输出数据流，没有输入数据流。D2和D3是黑洞，只有输入的数据流，没有输出的数据流。父图与子图不平衡，图1-2中没有图1-1中的数据流“维 修情况”。  
  
本问题考查0层数据流图中的数据流。分析图1-2,可以发现，处理3只有输出数据流没有输入数据流，D2和D3只有输入数据流，而没有输出流，造成黑洞。另外，对 照图1-2和图1-1，发现图1-1中从E2输入的数据流维修工时/维修情况，在图1-2中只有维修工时，造成父图与子图不平衡。  
  
【问题4】  
![a8e934cb23cc4eaca34fa617ef4a46b6.jpg][]  
  
针对【问题3】分析图1-2中存在的问题，题目要求以补充数据流的方式解决，进一步分析说明，说明3)对应处理“完成维修”，机械师根据维修记录文件中的待维修机械问题完成对巴士的维修，可知处理完成维修需要从维修记录文件读取待维修问题，补充一条从D2到处理3的数据流“待维修机械问题”。说明5)对应处理“计算维修总成本”，需要计算部件淸单中实际所用部件，补充从部件清单到计算总成本的数据流“实际所用部件”。说明3)中机械师要登记维修情况，判定图1-2中缺少了 E2到处理3的数据流“维修情况”。  
到此为止所有缺失的数据流都补齐了，也解决了【问题3】中的平衡问题、处理只有输出数据流没有输入数据流的问题，D2和D3也既有输入数据流，又有输出数据流。  


## 第2题 ##

【问题1】  
![4c827fd3766943c692712452d7ab0997.jpg][]  
  
本题考查数据库设汁，属于比较传统的题目，考查点也与往年类似。  
本问题考查数据库的概念结构设计，题目要求补充完整实体联系图中的联系和联系的类型。  
根据题目的需求描述可知，一个家电厂商可以供应多台家电，而一台家电只能对应一个家电厂商，因此“家电厂商”和“家电”之间存在“供应”联系，联系的类型为一对多（1:\*，或 l:m)。  
根据题目的需求描述可知，“员工”和“部门经理”之间存在一个包含关系。  
根据题目的需求描述可知，“客户”、“客服”和“家电’’之间存在“购买”联系，联系的类型为多对多对多（\*:\*:\*，或m:n:o)。  
  
【问题2】  
（1）厂商ID  
（2）部门经理工号 或 经理工号 或 员工工号  
（3）家电条码，客户ID，客服工号  
![54b8978e864d419da0c6b94e67d4b4b1.jpg][]  
  
本问题考查数据库的逻辑结构设计，题目要求补充完整各关系模式，并给出各关系模式的主键。  
根据实体联系图和需求描述，“家电”和“家电厂商”存在多对一的关系，在家电关系中耑要记录家电厂商的主键，也就是“厂商ID”。所以，对于“家电”关系模式，需补充属性“厂商ID”。“家电条码”为“家电”关系的主键。  
根据实体联系图和需求描述，“家电厂商”和“部门经理”之间存在多对一的关系，在家电厂商关系中需要记录部门经理的主键，也就是“部门经理工号”（或“经理工号”、或“员工工号”)。“厂商ID”为“家电厂商”的主键。  
根据实体联系图和需求描述，“客户”、“客服”和“家电”之间的多对多对多的“购买”联系。因为是多对多对多联系，所以“购买”联系需要单独作为一个关系，这个关系需要id录“客户”、“客服”和“家电”的主键。所以，对于“购买”关系模式，需补充属性“客户ID” “客服工号”和“家电条码”。“订购单号”为“购买”的主键。  
  
【问题3】  
![cd881bcc824b4ed89081d7079cc118af.jpg][]  
  
本问题考查数据库的概念结构设计，根据新増的需求增加实体联系图中的实体的联系和联系的类型。  
根据问题描述，需要新增“客户经理”，包含于“员工”。  
根据问题描述，客户只由一名客户经理和一名基金经理负责，客户经理和基金经理均可负责多名客户，所以“客户”、“客户经理”和“基金经理”之间存在一个“理财”联系，联系的类型为多对1对1（\*:1:1， 或m:1:1)。  


## 第3题 ##

【问题1】  
C1：Patron  
C2：Book  
C3：Catalog  
C4：Check out Session controller  
  
本题属于经典的考题，主要考查面向对象分析方法以及UML类图和通信图的相关知识。  
说明中给出了一个具体用例的详细描述，给出了其中的一个系统操作“checkout bookID)(借书)”的通信图，需要考生利用通信图中的信息来补充类图中缺失的部分。 通信图（communication diagram)强调收发消息的对象的结构组织，在早期的版本中也被称作协作图。通信图强调参加交互的对象的组织。产生一张通信图，首先要将参加交互的对象作为图的顶点，然后把连接这些对象的链表示为阁的弧，最后用对象发送和接收的消息来修饰这些链。这就提供了在协作对象的结构组织的语境中观察控制流的一个清晰的可视化轨迹。  
消息checkOut(booklD)的接收者是类CheckoutSessionContrailer的对象，说明类CheckoutSessionController中应该包含这一方法，否则无法响应该条消息。由图3-1可知，C4 处所代表的类应该是CheckoutSessionController。  
消息find(booklD)的接收者是类Book，同理，由图3-1可知，C2处对应的类应该是Book。  
根据用例描述，图书信息是包含在图书目录中，所以C3处对应的类应该是Catalog, C1处对应的就应该是Patron了。  
  
【问题2】  
M1:getforcheckout  
M2:isFaculty  
M3:circulates  
M4:recordBookLoan  
  
图3-1填充完整之后，图3-2的空缺就比较容易填写了。在通信图中，对象之间传递的消息就对应着接收对象中的方法。M1对应的就是类Catalog中的方法，由图3-1可 知，M1对应的是getForCheckOut。  
M3对应的应该是类Book中的方法。由图3-1可知，Book中有3个方法，find和checkout已经出现在通信图上了，所以M3应该是circulates。  
M2和M4是类Patron中的方法。Patron中有2个方法。通信图中的消息是有序号的，这个序号表示了消息的时间顺序，也就是说发送M2的时间要早于消息M4,因此必须区分类Patron中两个方法使用的先后顺序。在用例描述中特别指出：图书的归还时间与读者的身份有关。计算还书及借书费用时，需先确定读者的身份，因此方法isFaculty 应该先被调用，所以M2对应isFaculty，M4对应recordBookLoan。  
  
【问题3】  
策略模式  
策略模式定义了一系列算法，并将每个算法封装起来，而且使它们可以相互替换。 策略模式让算法独立于使用它们的客户而变化。适用于需要在不同情况下使用不同的策略（算法)，或者策略还可能在未来用其他方式来实现。  
  
本题在设计类时使用到了策略模式。  
策略模式定义了一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。策略模式的结构如下图所示。  
![f7aee57d8cfd48b79c8395a56a4d49a2.jpg][]  
其中：  
• Strategy (策略）定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。  
• ConcreteStrategy (具体策略）以Strategy接口实现某具体算法。  
• Context (上下文）用一个ConcreteStrategy对象来配置；维护一个对Strategy对象的引用；可定义一个接口来让Strategy访问它的数据。  
Strategy模式适用于：  
•许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。  
•需要使用一个算法的不同变体。例如，定义一些反应不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。  
•算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。  
• 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的Strategy类中，以代替这些条件语句。  


## 第4题 ##

【问题1】  
1）k≤r 或 k&lt;r+1  
2）arr\[k\]=right\[j\]  
3) begin&lt;end  
4)mergeSort(arr,mid+1,end)  
  
本题考査算法设计、分析和C程序实现的知识，属于传统题目，考查点也与往年类似。  
归并排序是一种经典的排序算法，基本思想：把n个元素构成的数组分成两个n/2 个元素构成的子数组，再进一步划分，一直到每个子数组仅包含1个元素，此时再把两 两有序的数组合并成更大的有序数组，一直到整个数组有序为止。  
本问题考査算法的实现。C程序中有两个函数，merge函数将两个有序数组合并成一个更大的有序数组。归并过程是首先将两个有序的子数组的元素分别放到left和right 数组中，然后依次比较这两个数组中的元素，从小到大把元素放到arr数组的特定元素中。包含空格（1）的for循环中，给出了将left和right元素放入arr中，放入的位置是从p到r,因此，空格（1）填写k &lt;= r。在比较left\[i\]和right\[j\]元素时，若left\[i\] &gt; right\[j\]， 则应该把right\[j\]的值放入arr\[k\]中，因此空格（2）填写arr\[k\] = right\[j\]。mergeSort函数进行数组的排序。若数组元素个数大于1，则继续划分，因此空格（3）填写begin &lt; end。将数组从arr\[begin\]到arr\[end\]划分为anfbegin\]到arr\[mid\]和 arr\[mid + 1\]到arr\[end\]两个部分，因此空格(4)填写mergeSort(arr，mid + l，end)。  
  
【问题2】  
5) 分治  
6) T(n)=2T(N/2)+O(n)或 T(n)=2T(n/2)+f(n) (f(n)为线性函数）  
7) O(nlogn)  
8) O(n)  
  
本问题考查算法的设计策略和时间复杂度，归并排序算法是一个典型的分治算法。每次将一个规模为n的问题变成两个规模为n/2的子问题，划分时直接从中间分开，因此划分采用O(1)的时间，然后是递归求解两个子问题，根据merge函数代码，合并的时间是线性时间O(n)。因此递归式为T(n)=2T(n/2)+f(n), f(n)为线性函数。用主方法求解，得到时间复杂度为O(nlgn)。由于在归并过程中，需要left和right两个辅助数组，其规模为待排序的数组长度，即O(n)  
  
【问题3】  
(9) nl+n2  
  
本问题考查对算法的进一步分析。元素之间的比较次数就是merge函数的最后一个for循环体执行的次数，由于k从p到r，故循环体执行次数为r-p+1次，即n1+n2次。  


## 第5题 ##

【问题1】  
(1) Subject  
(2) (\*it)-&gt;update(temperature, humidity, cleanness)  
(3) notifyObservers  
(4) measurementsChanged()  
(5) Observer  
(6) envData-&gt;registerObserver（this）  
  
本题考察观察者（Observer)模式的概念及应用。  
观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。  
Observer模式适用于：  
①当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这两者封装在独立地对象中以使它们可以各自独立地改变和复用。  
②当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。  
③当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即：不希望这些对象是紧耦合的。  
观察者模式的结构如下图所示，其中：  
![d018de9c1ef04be3a3ec94bae0353d28.jpg][]  
Subject (主题）知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口。  
Observer (观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口。  
ConcreteSubject (具体主题）将有关状态存入一个ConcreteObserver对象；当它的状态发生改变时，向它的各个观察者发出通知。  
ConcreteObserver (具体观察者）维护一个指向ConcreteSubject对象的引用；存储有关状态，这些状态应与主题的状态保持一致；实现Observer的更新接口以使自身状态与主题的状态保持一致。  
在本题的说明中，给出了观察者模式的结构图，答题时需要首先确定程序中的类与观察者模式结构的对应关系，也就是要找到哪些是ConcreteSubject，哪些是 ConcreteObserver。由程序上下文可以判断出，类EnvironmentData对应的是ConcreteSubject,类CurrentConditionsDisplay 对应的是ConcreteObserver。根据类图，它们分别为Subject和Observer的子类。由此可以，空（1）和空（5）应分别填写Subject 和Observer。  
空（2）要求给出方法notifyObservers的实现，其功能是在主题发生变化时通知观察者。通知的实现是通过向对该主题感兴趣的所有观察者发送update消息实现的。对主题EnvironmentData感兴趣的观察者由向量observers表示，所以在notifyObservers方法中，就是对向量observers中的每个成员发送update消息，因此空（2）应填写 (\*it)-&gt;update(temperature, humidity, cleanness)。  
方法measurementsChanged表示主题发生了变化，这时应该通知对应的观察者，所以空（3）处应填写notifyObservers()。  
方法setMeasurements用于设置发生变化后的主题内容，所以空（4）处应填写measurementsChanged()。  
CurrentConditionsDisplay是对主题EnvironmentData感兴趣的一个观察者，要能够获得主题的变化，需要首先将自己注册为该主题的观察者，这个注册行为在其构造函数中完成。因此空（6）处应填写envData-&gt;registerObserver(this)。  


## 第6题 ##

【问题1】  
(1) Subject  
(2) observer.update(temperature, humidity, cleanness)  
(3) notifyObservers()  
(4) measurementsChanged()  
(5) Observer  
(6) envData.registerObserver(this)  
  
【试题分析】  
本题考查观察者（Observer)模式的概念及应用。  
观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。  
Observer模式适用于：   
①当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。  
②当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。  
③当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即：不希望这些对象是紧耦合的。  
观察者模式的结构如下图所示，其中：  
![658fb0a035064c5081cdd6d7f2ce23c2.jpg][]  
  
Subject (主题）知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口。  
Observer (观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口。  
ConcreteSubject (具体主题）将有关状态存入一个ConcreteObserver对象；.当它的状态发生改变时，向它的各个观察者发出通知。  
ConcreteObserver (具体观察者）维护一个指向ConcreteSubject对象的引用；存储有关状态，这些状态应与主题的状态保持一致；实现Observer的更新接口以使自身状态与主题的状态保持一致。  
在本题的说明中，给出了观察者模式的结构图，答题时需要首先确定程序中的类与观察者模式结构的对应关系，也就是要找到哪些是ConcreteSubject,哪些是 ConcreteObserver。由程序上下文可以判断出，类EnvironmentData对应的是ConcreteSubject,类CurrentConditionsDisplay 对应的是ConcreteObserver。根据类图，它们分别为Subject和Observer的子类。由此可以，空（1）和空（5）应分别填写Subject 和Observer。  
空（2）要求给出方法notifyObservers的实现，其功能是在主题发生变化时通知观察者。通知的实现是通过向对该主题感兴趣的所有观察者发送update消息实现的。对主题EnvironmentData感兴趣的观察者由向量observers表示，所以在notifyObservers方法中，就是对向量observers中的每个成员发送update消息，因此空（2）应填写observer.update(temperature，humidity, cleanness)。  
方法measurementsChanged表示主题发生了变化，这时应该通知对应的观察者，所以空（3）处应填写notifyObservers()。  
方法setMeasurements用于设置发生变化后的主题内容，所以空（4）处应填写measurementsChanged()。  
CurrentConditionsDisplay是对主题EnvironmentData感兴趣的一个观察者，要能够获得主题的变化，需要首先将自己注册为该主题的观察者，这个注册行为在其构造函数中完成。因此空（6）处应填写envData.registerObserver(this)。  



[a8e934cb23cc4eaca34fa617ef4a46b6.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/a8e934cb23cc4eaca34fa617ef4a46b6.jpg
[4c827fd3766943c692712452d7ab0997.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/4c827fd3766943c692712452d7ab0997.jpg
[54b8978e864d419da0c6b94e67d4b4b1.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/54b8978e864d419da0c6b94e67d4b4b1.jpg
[cd881bcc824b4ed89081d7079cc118af.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/cd881bcc824b4ed89081d7079cc118af.jpg
[f7aee57d8cfd48b79c8395a56a4d49a2.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第3题/f7aee57d8cfd48b79c8395a56a4d49a2.jpg
[d018de9c1ef04be3a3ec94bae0353d28.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/d018de9c1ef04be3a3ec94bae0353d28.jpg
[658fb0a035064c5081cdd6d7f2ce23c2.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/658fb0a035064c5081cdd6d7f2ce23c2.jpg
