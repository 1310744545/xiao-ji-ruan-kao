---  
title: 2012年下半年  
# icon: gears  
order: 993  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1:商家.E2:支付系统.E3:物流系统.E4:Crystal Report或第三方服务.  
本问题考查顶层DFD。顶层DFD—般用来确定系统边界，将待开发系统看作一个加工，图中只有唯一的一个处理和一些外部实体，以及这两者之间的输入输出数据流。题目要求根据描述确定图中的外部实体。外部实体可以是和系统交互的人，以及和系统交互的外部系统或服务。分析题目中的描述，并结合已经在顶层数据流图中给出的数据流进行分析。分析题目中的说明，管理员维护系统中信息，顾客和商家是系统的主要使用者；商家杳看订购自家商品的订单信息，根据特殊优惠条件修改价格，更新订单表中的商品价格，还可以添加物流标识并进行物流跟踪；使用支付系统进行支付，通过物流系统进行物流跟踪，以及第三方服务Crystal Report生成报表。可以看出，和系统的交互者钮括管理员、顾客、商家三类人，支付系统、物流系统和Crystal Report三种外部系统。  
对应图1-1中数据流和实体的对应关系，管理员和顾客已经给出，可知E1为商家，E2为支付系统，E3为物流系统，E4为第三方服务Crystal Report。  
  
【问题2】  
D1：订单表.D2:商品表.D3:商品分类表.D4:购物车表.  
本问题考查0层DFD中数据存储的确定。根据说明中所描述的处理和相关数据存储之间的连接关系，判定每个数据存储。加入购物车和浏览购物车分别读取和更新购物车表中的数据；改变价格和提交订单要读取和更新订单表中的数据；维护信息时需要维护商品表和商品分类表，生成报街要读取商品表和商品分类表，加入购物车时，需要读取商品表中的商品信息。  
根据描述和图1-2中的数据存储的输入输出数据流提示，可知：D1为订单表，D2为商品表，D3为商品分类表，D4为购物车表。  
  
【问题3】  
![56b2a14920dd447b956a6bc357a57172.jpg][]  
本问题考查绘制0层DFD时是否将本层该绘制的数据流全部绘制出。对照顶层数 据流图和0层数据流图，检查是否和外部实体之间的数据流一致；仔细对照说明中的描述和图1-2中给出的数据流，检查是否遗漏掉信息。说明中：提交订单处理时，后台计算购物车表中的商品的总价，即需要读出购物车表中的相关价格进行计算，读取出其中数据；付款需要读取顾客表中关联的支付账户，并向支付系统提交转账请求，然后根据转账结果更改购物车表中商品的状态；生成报告时根据管理员和商家设置的报告选项，从订单表、商品表以及商品分类表中读取数据，再调用第三方服务Crystal Reports生成相关报告。将这些说明和图1-2进行对照，发现缺少了从付款到购物车表（D4)、从购物车表到提交订单、从顾客表到付款，以及从订单表（D1)到生成报表等4条数据流。  
  
【问题4】  
转账请求=验证码+价格+账号信息 顾客订单物流查询请求=顾客标识+订单标识  
商家订单物流査询请求=商家标识+\{订单标识\}  
解析：本问题考查在绘制数据流图时数据流的数据项组成。数据流图描述了系统的分解， 但它并没有给出图中各成分的说明。通常采用数据字典为数据流图中的每个数据流、文件、处理，以及组成数据流或文件的数据项做出说明。对于数据流，通常列出该数据流的各组成数据项，并采用数据字典定义式中出现的符号进行表示，如“=”表示“被定义为”，“+”表示“与” “\{……\}广表示其中数据可以有多个等等。本试题说明中：付款时，需根据顾客表中关联的支付账户将转账请求（验证码、价格等）提交给支付系统；物流跟踪时，根据顾客和商家的标识以及订单标识进行查询，而且在改变价格时商家查 看订购自家商品的订单信息，可知商家可以查询一批订单。可以看出，提交给支付系统的请求中包含支付账户、验证码与价格；顾客订单查询请求中有顾客标识、订单标识；商家订单查询请求中有商家标识、订单标识（一批订购自家商品的订单标识)。因此“转账请求=支付账户+验证码+价格”；“商家订单物流查询请求=物流标识+\{订单标识\} ”; “顾客订单物流标识=物流标识+订单标识”。  


## 第2题 ##

【问题1】  
![5496a41df4df441b86cd530258540318.jpg][]  
根据题意，一个客户可以提交多个会议申请，但一个会议申请对应唯一的一个客户号， 故应在客户和会议申请之间增加一个1 :n的“提交”联系：由于业务员负责受理会议申请，若申请符合公司规定则置受理标志并填写业务员的员工号，因此业务员和会议申请之间有一个1 :n的“受理”联系；由于一个已受理的会议申请对应一个策划任务，一个策划任务只对应一个已受理的会议申请，但一个策划任务可由多名策划员参与执行，且一名策划员可以参与多项策划任务，因此策划任务和策划员之间有一个n: m的“执行”联系; 由于每个部门有多名员工处理部门的日常事务，每名员工只能在一个部门工作，因此部门和员工之间有一个1 :n的“所属”联系；又由于每个部门有一名主管负责管理本部门的事务和人员，而该主管也是一名员工，因此主管和部门之间有一个1 : 1的“管理”联系。  
  
【问题2】  
a）部门号，职位  
b）申请号，客房类型，客户号  
c）申请号，员工号  
d）申请号，员工号  
关系模式为：  
会议申请(申请号，客房类型，客户号\#，开会日期，会议地点，持续天数，会议人数，预算费用，会议类型，酒店要求，会议室要求，客房数，联系人，联系方式，受理标志，员工号\#)  
策划任务(申请号\#，员工号\#，策划内容，参与人数，要求完成时间）  
执行策划(申请号\#，员工号\#，实际完成时间）  
  
根据题意，在员工关系模式中，部门与员工之间是一个1 :n的联系，需要将1端 (即部门）的码“部门号”并入员工关系；又因为每个员工担任相应职位，故员工关系模式欢迎添加“职位”属性；可见，空（a）应填写“部门号，职位”。  
在会议申请关系模式中，由于申请号、客房类型、客户号为主键，故空（b）应填写“申请号，客房类型，客户号”；在策划任务关系模式中，申请号、员工号为主键，故空（c）应填写“申请号，客户号”；由于一个策划任务可由多名策划员参与执行，且一名策划员可以参与多项策划任务，故在执行策划关系模式中，执行策划又由于一个业务员可以安排多个托运申请，申请号、员工号为主键，故空（d）应填写“申请号，客户号”。  
  
【问题3】  
会议申请关系模式的主键为“申请号，客房类型”，因为，申请号、客房类型能唯—标识该关系模式的每一个元组。会议申请关系模式的外键为客户号及员工号，因为， 客户号及员工号分别为客户及员工关系模式的主键，故为该关系模式的外键。  
策划任务关系模式的主键为申请号，因为，申请号能唯一标识该关系模式的每一个元组，故申请号为该关系模式的主键。策划任务关系模式的外键为员工号，因为，员工 号为员工关系模式的主键，故为该关系模式的外键。  
执行策划关系模式的主键为“申请号，员工号”，因为，申请号k员工号能唯一标识该关系模式的每一个元组，故“申请号，员工号”为该关系模式的主键。执行策划关 系模式的外键为申请号及员工号，因为，申请号和员工号分别为会议申请和员工关系模式的主键，故为该关系模式的外键。  
  
会议申请存在数据冗余及数据修改的不一致性问题，应该将关系模式分解为如下两个模式：  
会议申请1 (申请号，客户号，开会日期，会议地点，持续天数，会议人数，预算费用，会议类型，酒店要求，会议室要求，联系人，联系方式，受理标志，员工号）  
会议申请2 (申请号，客房类型，客房数）。  
关系模式“会议申请”存在数据冗余及数据修改的不一致性问题，应该将关系模式分解。  


## 第3题 ##

【问题1】  
UC1 ： CheckAvailability  
UC3 ： GetDiscount  
UC5 ： ManageCrCardPayment  
UC2 ： MakeReservation  
UC4 ： ManageCashPayment  
UC6 ： CalculateRefund  
UC4和UC5可以互换。  
  
本题要求将图3-1所给出的用例图补充完整。题目说明中已经给出了所有可能的用例的列表（如表3-1所示）。这就省去了寻找用例的步骤，只需要依据用例列表中给出的 用例，在说明中确定用例与Actor之间的关系即可将图补充完整。  
用例图的构成要素有：参与者（Actor)、用例（Usecase)以及用例之间的关系。题目中的信息系统的主要用户是售票处的工作人员（TicketingOfficer),所以在图3-1中只给出了1个参与者。由说明可知，售票处工作人员利用该系统可以实现6个主要的功能： 管理预定申请（Managelnquiries)、预定（MakeReservation)、支付管理（ManagePayment)、 游客取消预定（CancelReservation)、自动取消预定（AutoCancelReservation)和信息查询（CheckAvailability)。其中“管理预定申请”、“支付管理”、“游客取消预定”、“自动取消预定”和“支付管理”均己经出现在图3-1中。支付租赁费用是预定过程中的一个必要步骤，而UC2和“支付管理”之间又是“include”关系，可以推断出UC2应该对应用例“预定（MakeReservation)”。那么用例“管理预定申请”和“预定”具有的相同步骤就是UC1所对应的用例，由此推断出UC1对应用例“信息查询(CheckAvailability)”。  
由功能“支付管理”的说明可知，它具备两个能力：管理支付方式（信用卡或现金）以及计算折扣。UC4和UC5与用例“支付管理”之间是概括关系，说明UC4和UC5是 支付方式的两个特化，所以UC4为“现金支付（MangeCashPayment)”，UC5为“信用卡支付（ManageCrCardPayment)”。UC3 对应“计算折扣（GetDiscount)”。  
这时用例列表中只剩下用例CalcuateRefimd (计算取消预定的赔偿金）没有出现在图中了，那么它就是UC6对应的用例。从图3-1来看，UC6应该表示用例“游客取消预定（CancelReservation)”和“自动取消预定（AutoCancelReservation)”中包含的公共事件流。不管是哪种类型的取消预定，都需要计算赔偿金，以决定退还给用户的费用，所以UC6对应用例CalcuateRefimd。  
  
【问题2】  
Cl: NationalPark  
C2: Rate  
C3: TicketingOfficer  
C4: Payment  
C5: Discount  
C6: CashPaymen  
C7: CreditCardPayment  
C6和C7可以互换。  
  
本题考察的是类图建模。题目中已经给出了类的列表，要求考生根据说明指出每个类在类图中的位置。在解题时，可以同时参考用例图中给出的信息。  
先整体地看一下类图，寻找其中是否包含继承、聚集或组装等这些层次结构，这是快速确定部分类的关键。在图3-2中有一个继承结构：C4、C6和C7。在图3-1中，用 例之间也有一个概括的关系，这就提示我们，C4、C6和C7这3个类一定与支付功能相关。在表3-2中寻找与支付功能相关的类：Payment、CashPayment和CreditCardPayment。下来就是确定这3个类中，哪个是父类。很明显，Payment应该作为父类。因此C4对应 Payment, C6 对应CashPayment，C7 对应CreditCardPayment (C6 和 C7 可以互换支付管理中还有一项计算折扣的能力，类列表中的类Discount表示付款折扣，而与C5与C4之间具有关联关系，所以C5应该对应类Discout。  
Cl、C2分别与类“Reservationltem”之间具有组装和聚集的关系，而从说明中可知，具有这种整体部分关系的只有公园、预定及租赁费用之间，所以C1对应NationalPark, C2对应Rate。最后的一个类C3对应TicketingOfficer，即用例图中的Actor。  
  
【问题3】  
解答1:增加一个新的类，该类与类Reservationltem之间有关联关系。或解答2:修改Rate类，使其具有计算赔偿金的功能。  
  
在面向对象方法中，好的类模型对需求的变化应该具有一定的适应性。本题考察的就是这一点。根据题目，现在对原有的赔偿金计算规则要进行修正。除了考虑取消预定的时间之外，同时要考虑所预定的小木屋或营地的地段以及需求量。修正类模型时通常两种基本方式，一种是修改已有的类，使其适应新的需求；第二种是增加一个新的类来完成新的需求，但是需要同时考虑新增加的类与已有类之间的关系。这道题目两种修改方法都可以采用。  
若要修改己有的类，需要首先了解哪个类与现在的新需求是有相关性的。新需求针对的是赔偿金，赔偿金又与租赁费用相关，所以要找原先与租赁费用相关的那个类，即Rate。解决方案之一就是修改Rate，使其能够按照新的规则计算赔偿金。  
第二种修改方式，增加一个专门计算赔偿金的类。按照新的计算规则，这个类就与游客的每次预定内容相关，因此这个新增加的类应该与类Reservationltem之间有关联关系。  


## 第4题 ##

【问题1】  
（1）j = 0  
（2）b\[j\] = b\[j\] + s\[i\] 及其等价形式  
（3）min = temp  
（4）b\[m\] = b\[m\] + s\[i\]及其等价形式  
  
根据最先适宜算法思想，每取出一个货物，从第一个集装箱开始判断该货物是否能放入集装箱，若能则放入，因此空（1）填j = 0。while循环判断，若货物不能放入集装 箱，则考虑下一个集装箱。不满足while循环中的条件，说明货物能放入集装箱，因此空(2)填b\[j\] = b\[j\] + S\[i\]。根据最优适宜算法思想，每取出一个货物，从第一个集装箱开始，确定能放入该货物且剩余容量最小的集装箱，并把该货物放入该集装箱中。if条件判断，若找到了比能放入货物且剩余容量更小的集装箱，则剩余容量最小值改为当前的集装箱的剩余容量，因此空(3)填min = temp。确定了集装箱后，把货物装入集装箱中，空(4) b\[m\] = b\[m\] + s\[i\]。  
  
【问题2】  
（5）贪心（6）贪心（7） O(n2)  (8) O(n2)  
  
最先适宜算法总是把货物放入第一个能放入的集装箱，最优适宜算法总是把货物放入能容纳该货物且剩余容量最小的集装箱，因此都是基于贪心策略进行的，空(5)和(6) 填贪心。函数firstfit中的for循环考虑n个货物，其中嵌套了while循环，最多的集装箱数为n，因此时间复杂度为O(n2)。函数bestfit中的for循环考虑n个货物，其中嵌套了 for循环检查每个集装箱的剩余容量，最多的集装箱数为n，因此时间复杂度为O(n2)。  
  
【问题3】  
（9）5 (10) 4(11)否  
  
对实例n = 10, C = 10, S = \{4,2,7,3,5,4,2,3,6,2\},根据最先适宜和最优适宜算法，其具体的装箱方案分别如下图(a)和(b)所示。  
![e8ba7226d7f14feb9c4e9961e1011a71.jpg][]  
因此最先适宜和最优适宜方法所需的集装箱数分别为5和4,装箱问题是一个非常难的问题，这两种贪心策略不能确保得到最优解，即最少的装箱数。  


## 第5题 ##

【问题1】  
1、virtual void Insert(Department\* department)  
2、virtual Department GetDepartment(int id)  
3、public IDepartment  
4、public IDepartment  
5、class IFactory  
6、virtual IDepartment\* CreateDepartment()  
  
本题考查抽象工厂（Abstract Factory)模式的概念及应用。  
Abstract Factory模式的意图是，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。Abstract Factor模式的结构如下图所示。  
![a9e31cedcc1441a79296cc5c4365a370.jpg][]  
其中，类AbstractFactory声明一个创建抽象产品对象的操作接口；类ConcreteFactory 实现创建具体产品对象的操作；类productA为一类产品对象声明一个接口；类 ConcreteProduct具有2个功能：定义一个将被相应的具体工厂创建的产品对象；实现ProductA 接口；类Client 仅使用由AbstractFactory 和AbstractProduct 类声明的接口。  
在以下情况可以使用AbstractFactory模式：  
(1) 一个系统要独立于它的产品的创建、组合和表示时；  
(2) —个系统要由多个产品系统中的一个来配置时；  
(3) 当要强调一系列相关的产品对象的设计一边进行联合使用时；  
(4) 提供一个产品类库，而只想显示它们的接口而不是实现时。  
题目利用抽象工厂模式来解决在同一个软件系统中支持多种不同数据库的问题，这也是软件开发中比较常见的情形。其中的类IFactory相当于上图中的类AbstractFactory; 类IDepartment相当于上图中的类ProdcutA。本题中只给出了一个产品类。  
下面来分析程序。  
第（1）、(2)空出现类IDepartment的定义中。类IDepartment的作用是为一类产品对象声明一个接口，在C++中通常都采用抽象类来定义这种抽象操作接口。C++中的抽 象类是包含了至少一个纯虚拟函数的类。纯虚拟函数的语法是：virtual &lt;函数名 &gt;(&lt;参数列表&gt;)=0;  
在程序中己经出现了纯虚拟函数的标志“=0”，因此（1）、（2）空应该都是纯虚拟 函数。下面来确定纯虚拟函数的原型。这需要去考察类IDepartment的子类，因此纯虚拟函数是在父类中定义，在子类中实现。由类图5-1可知，类IDepartment的子类分别是SqlserverDepartment 和 AccessDepartment。至此可以提前确定（3）、（4）空的内容了，即其所对应的父类。因此（3）、（4）空都应该填写public IDepartment。我们看类SqlserverDepartment 中的方法,分别为:Insert 和GetDepartment，而在类AccessDepartment 中也出现了这两个方法，且接口完全一致。所以这两个方法就应该是类IDepartmeiit中所定义的抽象接口。由此可知，（1）空应该填写virtual void Insert(Department\* department)，(2)空应该填写 virtual Department GetDepartment(int id)。  
空（5）和（6）分别缺失在类的名称以及该类中的方法。由图5-1和代码可知，缺少类IFactory的定义，所以（5）空处应该填写class IFactory。那么类〖Factory应包含的方法是什么？类IFactory的作用是声明一个创建抽象产品对象的操作接口，这个接口一定会同时出现在IFactory的子类SqlServerFactory和AccessFactory中，即 CreateDepartment。(6)处同样应该是一个纯虚拟函数，所以（6）空处应该填写virtual IDepartment\* CreateDepartment()。  


## 第6题 ##

【问题1】  
1.void Insert(Department department)  
2.Department GetDepartment(int id)  
3.implements IDepartment  
4.implements IDepartment  
5.interface IFactory  
6.IDepartmentCreateDepartment()  
  
本题考查抽象工厂（Abstract Factory)模式的概念及应用。  
Abstract Factory模式的意图是，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。Abstract Factor模式的结构如下图所示。  
![e153104892cd44a9a464ab7802f9892b.jpg][]  
其中，类AbstractFactory声明一个创建抽象产品对象的操作接口；类ConcreteFactory 实现创建具体产品对象的操作；类ProductA为一类产品对象声明一个接口；类 ConcreteProduct具有2个功能：定义一个将被相应的具体工厂创建的产品对象；实现ProductA 接口；类Client 仅使用由AbstractFactory 和AbstractProduct 类声明的接口。  
在以下情况可以使用Abstract Factory模式：  
(1) 一个系统要独立于它的产品的创建、组合和表示时；  
(2) —个系统要由多个产品系统中的一个来配置时；  
(3) 当要强调一系列相关的产品对象的设计一边进行联合使用时；  
(4) 提供一个产品类库，而只想显示它们的接口而不是实现时。  
题目利用抽象工厂模式来解决在同一个软件系统中支持多种不同数据库的问题，这也是软件开发中比较常见的情形。其中的类IFactory相当于上图中的类AbstractFactory; 类IDepartment相当于上图中的类ProdcutA。本题中只给出了一个产品类。  
下面来分析程序。  
第（1）、（2）空出现类IDepartment的定义中。类IDepartment的作用是为一类产品对象声明一个接口，在Java中通常都采用Inteface来定义这种抽象操作接口。要确定接口的原型，需要去考察实现接口IDepartment的类。由类图6-1可知，实现接口IDepartment 的类分别是SqlserverDepartment和AccessDepartment。至此可以提前确定（3）、(4)空的内容了。（3）、(4)空都应该填写 implements IDepartment。我们看类SqlserverDepartment 中的方法，分别为：Insert和GetDepartment，而在类AccessDepartment中也出现了这两个方法，且接口完全一致。所以这两个方法就应该是IDepartment中所定义的抽象接口。由此可知，（1）空应该填写 void Insert(Department department)，(2)空应该填写 Department GetDepartment(int id)。  
空（5）和（6）分别缺失在类的名称以及该类中的方法。由图6-1和代码可知，缺少类 IFactory 的定义。由代码 “class SqlServerFactory implements IFactory” 和 “class AccessFactory implements IFactory” 可知，IFactory 也是一个接口。所以（5）空处应该填写Interface IFactory。那么类IFactory应包含的方法是什么？类IFactory的作用是声明一个创建抽象产品对象的操作接口，这个接口一定会同时出现在类SqlServerFactory和AccessFactory中，即CreateDepartment。(6)处同样应该是一个纯虚拟函数，所以（6） 空处应该填写 IDepartment CreateDepartment()。  



[56b2a14920dd447b956a6bc357a57172.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/56b2a14920dd447b956a6bc357a57172.jpg
[5496a41df4df441b86cd530258540318.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/5496a41df4df441b86cd530258540318.jpg
[e8ba7226d7f14feb9c4e9961e1011a71.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/e8ba7226d7f14feb9c4e9961e1011a71.jpg
[a9e31cedcc1441a79296cc5c4365a370.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/a9e31cedcc1441a79296cc5c4365a370.jpg
[e153104892cd44a9a464ab7802f9892b.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/e153104892cd44a9a464ab7802f9892b.jpg
