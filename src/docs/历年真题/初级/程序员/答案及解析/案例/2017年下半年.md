---  
title: 2017年下半年  
# icon: gears  
order: 983  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
（1）2，n或2，n，1  
（2）A\[k\]或其等价形式  
（3）k-1，1，-1  
（4）A\[i\]+A\[i-1\]或其等价形式  
（5）A\[i\]或其等价形式  
  
本题考查对算法流程图的理解和表示能力，这是程序员必须真备的技能。  
对k=1,2,3,…，（x + 1）k的展开式系数可列出如下（杨辉三角）:  
k=1时 1 1  
k=2时 1 2 1  
k=3时 1 3 3 1  
k=4时 1 4 6 4 1  
...  
A\[0\] A\[1\] A\[2\] A\[3\] A\[4\]...  
计算是逐行进行的，而且各行计算的结果需要保存在同一数组A中。  
杨辉三角的规律为：每行有k+1个数，依次保存在A\[0:k\]中。首末两数都是1。中间任一个数等于其上面一个数与左上数之和。由于采用同一数组存放各行，因此每计算出一个数存放后就会代替原来的数。这样，在同一行计算的过程中，不能从左到右计算,而应从右到左计算（按数组下标i递减的顺序)。  
流程图中，一开始对A\[0\]和A\[1\]置1,这就是k=1时的计算结果。  
接着需要对k=2,3,…，n进行循环计算，因此流程图空（1）处应填2,n或者2，n，1。  
在对第k行进行计算时，显然应首先将最右边的A\[k\]置1，因此空（2）处应填A\[k\]。  
接着应从右到左逐个计算这一行中间的各个数：A\[k-1\],A\[k-2\]…，A\[1\]，因此，（3）处应填k-1,1,-1(即数组下标从k-1开始每次递减1直到1)。  
接着应计算A\[i\]。根据杨辉三角的规律，它应等于原来的A\[i\]与前一个数A\[i-1\]之和。因此空(4)处应填A\[i\]+A\[i-1\]，而空（5）处应填A\[i\]。  
当i和k双重循环结束后，A\[0:n\]中的结果就是(x+1)n展开后的各项系数。  


## 第2题 ##

【问题1】  
（1）j&lt;n或其等价形式  
（2）j++或其等价形式  
（3）k=j  
（4）data\[i\]=data\[k\]或\*（data+i）=\*（data+k）或其等价形式  
（5）selectSort(arr,m)  
其中，m可替换为8或者sizeof(arr)/sizeof(int)  
（6）i=0  
  
本题考查C程序的基本结构、运算逻辑和函数调用及应用。  
题干中已明确对简单选择算法作了说明，在实现该排序方法的函数selectSort(intdata\[\],intn)中，第一重循环for(i=0;i&lt;n-1;i++)的作用是控制排序的趟数。在每趟排序过程中,都是从data\[i\]~data\[n-1\]中选出最小元素，并用k记录其下标，k的初始值设置为等于i，因此空（1）处应填入“j&lt;n”，使得在该条件下可以遍历选择范围内所有元素，空（2）处应填入“j++”或其等价形式。  
在一趟选择的过程中，只需记下最小元素的下标，因此在满足“data\[j\]&lt;data\[k\]”的条件下，需要用k记住j(即更小元素的下标)，因此空（3）处应填入“k=j”。  
显然，如果data\[i\]~data\[n-1\]中最小元素（即data\[k\])并不是data\[i\]时，需要将两者的值交換，因此空（4）应填入“data\[i\]=data\[k\]”或其等价形式。  
空（5）处考查函数调用。根据注释，需要调用selectSort对数组arr进行非递减排序，按照sdectSort的定义要求，第一个形参本质上需要实参为指针，因此其对应的实参为main函数中的数组arr(数组名表示数组空间的首地址，实质上界常量指针)，第二个参数为表示数组元素个数的整数，实参为m、8或sizeof(arr)/sizeof(int)都可以，空（5）处应填入’‘selectSort(arr,m)”或其等价形式。  
空（6）所在循环语句通过i遍历数组元素并逐个输出，此处填入“i=0”实现对i的初始化。  


## 第3题 ##

【问题1】  
D或3或x1=D或x1=3或其等价形式  
A或0或x2=A或x2=0或其等价形式  
C或2或x3=C或x3=2或其等价形式  
B或1或x4=B或x4=1或其等价形式  
  
本题考查C程序的基本结构、语句和运算逻辑及其应用。  
本问题主要通过以不同实参调用同一个函数考査对if语句的理解和应用。  
代码中if语句的含义可用下面的流程图表示：  
![445071bfc5c946308543fad366524771.jpg][]  
对于函数调用x1=f(1997)，将1997传给yr后计算yr%400值为397,等于0不成立（即不能被400整除），接下来计算yr%4值为1,等于0不成立 (即不能被4整除），因此执行return D。  
对于函数调用x1=f(2000)，将2000传给yr后计算yr%400值为0,等于0成立（即 可以被400整除），因此执行return A。  
对于函数调用x1=f(2100)，将2100传给yr后计算yr%400值为10,等于0不成立 (即不能被400整除)，接下来计算yr%4值为0,等于0成立（即可以被4整除），接下来计算yr%100值为0,不等于0不成立（即可以被100整除），因此执行return C。  
对函数调用x1=f(2020)，将2020传给yr后计算yr%400值为20，等于0不成立 (即不能被400整除），接下来计算yr%4值为0,等于0成立（即可以被4整除），接下来计算yr%100值为20,不等于0成立(即不能被100整除)，因此执行return B。  
  
【问题2】  
（1）Average！  
poor！  
Oops，Error  
（2）Excellent！  
Good！  
  
本问题主要通过输入不同值考查对switch语句的理解和应用，特别要注意其中break的作用。题目中的switch语句在逻辑上可以理解为下面流程图的含义，实际上通过将各情况的代码位置记在一个称为跳转表的数组中，根据score的值实现直接跳转，可以得到更高效的执行效率。  
![91f92d0d638a4210bf8e1475f998c41a.jpg][]  
输入为3时，score的值不等于5也不等于4,而满足score等于3的情况，输出“Average!”后，由于没有遇到break,所以接下来执行输出“Poor!”和输出“Oops, Error”, 然后结束switch语句。  
输入为5时，满足score等于5的情况，输出“Excellent!”后，由于没有遇到break, 所以接下来执行输出“Good!”，遇到break，就结束switch语句。  
若输入为4,满足score等于4的情况，因此执行输出“Good!”，遇到break,就结 束switch语句。  
若输入为6，score的值不等于5、4、3、2、1和0中的任何一个，则执行default部分的语句，即输出“Oops, Error”，然后结束switch语句。  
  
【问题3】  
0 1 0  
0 2 0  
0 2 1  
1 0 1  
1 2 0  
1 2 1  
  
本问题主要通过输入不同值考查对嵌套循环语句的理解和应用。  
i、j和k的取值关系如下表所示，要求输出i、j不同且j、k不同时它们的值，而i与k相同则不管，因此容易得到输出结果。  
![1d99ff57cb0f4f758826df91f70b64f9.jpg][]  


## 第4题 ##

【问题1】  
（1）low&lt;=high或其等价形式  
（2）high=mid-1或其等价形式  
（3）low=mid+1或其等价形式  
（4）low&lt;=high或其等价形式  
（5）r，low，mid-1  
（6）r，mid+1，high  
  
本题考查C程序的基本结构、递归运算逻辑和二分查找算法的实现。  
二分查找算法要求查找表的元素已经有序，且可以随机访问元素，其基本思想是：首先令待查元素与中间位置上的元素进行比较，若相等，则查找成功结束；若大于中间元素，则继续在后半个查找表中继续进行二分查找，否则在前半个查找表中继续进行二分查找。  
由于有序序列存储在数组中，所以查找表的开始位置（即最小元素的位置）用low表示，结束位置（即最大元素的位置）用high表示（即查找表可以通过\[low,high\]来表示），从而可以计算出中间位置mid为(low+high)/2,前半个查找表可用\[low，mid-1\]表示，后半个查找表可用\[mod-1,high\]表示。因此，在查找过程中，若待查元素小于中间位置的元素，则将high更新为mid-1;若待查元素大于中间位置的元素，则将low更新为mid+1，从而在继续进行二分查找时仍然通过\[low,high\]来表示查找表。显然，low&lt;=high表示查找范围有效，即查找表至少有一个元素。  
函数1中的空（1）处应填入“low&lt;=high”，空（2）处表示要在前半个查找表中继续查找，因此需要修改表尾的位置参数，应填入“high=mid-1”；空（3）处表示要在后半个查找表中继续查找，因此需要修改表头的位置参数，应填入“low=mid+1”。  
用递归方式实现二分查找算法时，表头位置参数或表尾位置参数的修改通过递归调用时的实参来表示。函数2中的空（4）处应填入“low&lt;=high”表示查找表有效，空(5)处表示要在前半个查找表中继续查找，因此需要修改查找表的表尾位置参数，完整的递归调用为“biSearch\_rec(r,low,mid-1，key)”；空（3）处表示要在后半个查找表中继续查找，因此需要修改查找表的表头位置参数，完整的递归调用为“biSearch\_\_rec(r，mid+1,high,key)”。  
二分查找算法的时间复杂度为O(log2n)，最多与\[log2(n+1)\]个数组元素进行比较，即可确定查找结果。  
  
【问题2】  
(7) A  


## 第5题 ##

【问题1】  
（1）implements Item  
（2）this.price=price  
（3）visitor.visit(this)  
（4）implements Visitor  
（5）public void visit(Book book)  
（6）item.accept(visitor)  
  
本题考查Java语言程序设计能力，涉及接口、类、对象、方法的定义和使用。本题也是典型的访问者（Visitor)设计模式的实现示例。访问者设计模式的典型类图如下所示。该模式中最核心的部分当属Visitor接口，其为元素对象结构中每一种具体元素（ConcreteElement)定义了visit操作。  
![61bc38c9802943c5971ced63d54eca71.jpg][]  
先考查题目说明，实现一个超市简单销售系统中的部分功能，顾客选择图书等物品(Item)加入购物车（ShoppingCart),到收银台（Cashier)对每个购物车中的物品统计其价格进行结账。具体物品有图书（Book)、CD和DVD等。  
根据题目说明进行设计，给出图5-1的类图，定义相关的接口、类及其之间的关系。其中Shopp ngCart购物车中持有各种物品，物品（Item)定义为接口，声明两个方法，-个是getPrice()可以获得物品价格，另一个accept(visitor:Visitor)接受由visitor对象进行价格统计，方法由子类实现。Book、CD和DVD三个具体类实现接口Item,需要具体定义getPrke()和accept()方法的实现。Visitor定义为访问每个物品的接口，具体访问者即其实现类Cashier对ShoppingCart中的每个物品进行统计。  
元素对象结构中，Item定义为接口，用interface关键字。其中声明的方法缺省为public,此处显式添加了public关键字，没有方法实现：  
public:void accept(Visitor visitor);public double getPrice();  
接口无法直接创建对象，需要由具体类Book、CD和DVD实现Item中声明的方法接口后，才能创建对象。在Java中，釆用implements关键字后加接口名，即:  
class Book implements Item\{...\}  
class CD implements Item\{...\}  
class DVD implements Item\{...\}  
在具体实现类的构造器中，对象的属性与构造器参数price同名，用this关键字加以区分。其中this关键字用来引用当前对象或类实例，可以用点取属性或行为，即：  
this.price=price;  
其中，this.price表示当前对象的price属性，price表示参数。  
public void accept(Visitor visitor)方法用于具体的收银员访问本元素以统计价格，即visitor对象使用其visit方法访问当前的物品对象  
visitor.visit(this);  
这一类图中的核心是Visitor接口：interface Visitor\{\}，该接口定义了一个访问Item对象结构中的每种具体物品元素的操作，即:  
public void visit(Book book);  
public void visit(CD cd);  
public void visit(DVD dvd);  
具体访问物品的收银员Cashier实现该Visitor接口，实现其中的visit方法。Cashier记录（存储）所统计的物品总价格totalForCart,在访问每个物品之后，将按具体规则对物品进行价格统计，累加至总价格。Cashier中定义public double getTotal()方法以返回购物车中物品的总价格。  
ShoppingCart类定义购物车中一系列物品的集合：  
private java.util.ArrayList&lt;Item&gt;items=new java.util.ArrayListo();  
其中，采用泛型元素类型&lt;Item&gt;约束，从Java7起，支持创建ArrayList等集合类对象时，从上下文推断其泛型元素类型，不用显式指出。即newjava.util.ArrayList&lt;&gt;()。  
ShoppingCart中的calculatePrice()方法即为触发结账离幵的行为，其中每个物品接受Cashier对象的价格统计：  
for(Item item:items) \{  
item.accept(visitor);  
\}  
最后通过visitor.getTotal()返回总价格。ShoppingCart中还定义一个方法用来向购物车添加物品：  
public void add(Item e)\{this.items.add(e);  
\}  
整个系统在使用时先创建ShoppingCart对象，向其中添加物品，结账离开时调用calculatePrice()统计总价，在main()方法中如下定义：  
public static void main(String...args)\{  
ShoppingCart cart=new ShoppingCart();  
cart.add(new Book(20));  
cart.add(new CD(10));  
cart.add(new DVD(20));  
  
double total=cart.calculatePrice();  
System.out.println("total:"+total);  
\}  
综上所述，空（1）需要标识实现接口implements Item;空（2）要表示将参数price赋值给当前对象的price,即this.price=price;空（3）处需要使visitor对象调用visit当前对象来统计价格，即visitor.visit(this);空（4）为实现接口implements Visitor;空（5）处为具体类中实现接口中声明的方法public void visit(Bookbook);空（6）处为物品对象接受收银员对当前对象进行统计，item.accept(visitor)。  


## 第6题 ##

【问题1】  
（1）:public Item  
（2）this-&gt;price=price  
（3）visitor-&gt;visit(this)  
（4）:public visitor  
（5）void visit(Book\*book)  
（6）items.at(i)-&gt;accept(visitor)或items  
  
本题考查C++语言程序设计能力，涉及接口、类、对象、函数的定义和使用。本题也是典型的访问者（Visiter)设计模式的实现示例。访问者设计模式的典型类图如下所示。该模式中最核心的部分当属Visitor接口，其为元素对象结构中每一种具体元素（ConcreteElement)定义了visit操作。  
![566855af512a4fd185fd050cb8386742.jpg][]  
先考查题目说明，实现一个超市简单销售系统中的部分功能，顾客选择图书等物品(Item)加入购物车（ShoppingCart),到收银台（Cashier)对每个购物车中的物品统计其价格进行结账。具体物品有图书（Book)、CD和DVD等。  
根据题目说明进行设计，给出图6-1的类图，定义相关的接口L类及其之间的关系。其中ShoppingCart购物车中持有各种物品，物品（Item)定义为接口，声明两个纯虚函数，一个是getPrice()可以获得物品价格，另一个accept(visitor:Visitor)接受由visitor对象进行价格统计，方法由子类实现。Book、CD和DVD三个具体类继Item，需要具体定义getPrice()和accept()函数的实现Visitor定义为访问每个物品的接口，具体访问者即其实现类Cashier对ShoppingCart中的每个物品进行统计。  
元素对象结构中，Item接口定义为C++中的抽象类，函数定义为纯虚函数，通过用virtual关键字修饰方法声明，并在声明中使用”=0”来指定，只有函数的声明，没有具体函数实现，即：  
public:  
virtual void accept(Visitor\*visitor)=0;  
virtual double getPrice()=0;  
抽象类无法直接创建对象，需要由具体实现类Book、CD和DVD实现Item中的声明的纯虚函数后，才能创建对象。在C++中，采用：加父类名，如下所示：  
class Book:public Item\{...\}  
class CD:public Item\{...\}  
class DVD:public Item\{...\}  
在具体实现类的构造器中，对象的属性与构造器参数price同名，用this关键字加以区分。其中this关键字用来指向当前对象或类实例，可以用-&gt;取属性或行为，即:  
this-&gt;price=price;  
其中，this-&gt;price表示当前对象的price属性，price表示参数。  
void accept(Visitor\*visitor)函数用于具体的收银员访问本元素以统计价格，即visitor对象使用其visit方法访问当前的物品对象：visitor-&gt;visit(this);。  
这一类图中的另一个核心是Visitor接口，该接口定义了一个访问Item对象结构中的每种具体物品元素的操作即，仍然采用抽象类定义：class Visitor\{\}，即：  
public:  
virtual void visit(Book\*book)=0;  
virtual void visit(CD\*cd)=0;  
virtual void visit(DVD\*dvd)=0;  
整个系统的在使用时先创建ShoppingCart对象，向其中添加物品，结账离开时调用calculatePrice()统计总价，在main()函数中定义如下：  
int main()\{  
ShoppingCart\*cart=new ShoppingCart();  
Book\*b=new Book(20);cart-&gt;add(b);  
CD9\*c=new CD(10);cart-&gt;add(c);  
double total=cart-&gt;calculatePrice()/cont&lt;&lt;"total:"total endl;delete cart; .  
\}  
综上所述，空（1）需要标识实现接口Item,即用：public Item继承Item类；空(2)要表示将参数price赋值给当前对象的price,即this-&gt;price=price;空(3)处需要使visitor对象调用visit当前对象来统计价格，即visitor-&gt;visit(this);空(4)为实现接口Visitor，即:public Visitor继承Visitor类；空(5)处为具体类中实现接口中声明的方法void visit(Book\*book)；空（6）处为物品对象接受收银员对当前对象进行统计，items.at(i)-&gt;accept(visitor)或items\[i\]-&gt;accept(visitor)。  



[445071bfc5c946308543fad366524771.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第3题/445071bfc5c946308543fad366524771.jpg
[91f92d0d638a4210bf8e1475f998c41a.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第3题/91f92d0d638a4210bf8e1475f998c41a.jpg
[1d99ff57cb0f4f758826df91f70b64f9.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第3题/1d99ff57cb0f4f758826df91f70b64f9.jpg
[61bc38c9802943c5971ced63d54eca71.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第5题/61bc38c9802943c5971ced63d54eca71.jpg
[566855af512a4fd185fd050cb8386742.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第6题/566855af512a4fd185fd050cb8386742.jpg
