---  
title: 2011年上半年  
# icon: gears  
order: 996  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
(1) L-m+1或等价表示  
(2) i+m-1或等价表示  
(3) j+1或等价表示  
(4) n+1或等价表示  
(5) A(j)=K(j)或等价表示  
  
根据题意，正文字符串中的各个字符依次存放在T(1)，T(2)，…，T(L)中，关键词字符串中的各个字符依次存放在K(1)，K(2)，…，K(m)。显然i是字符数组T的动态下标指针。 为了与关键词字符串进行比较，题中需要每次从数组T中连续取出m个元素放在数组A 中。第1次将T(l:m)存入A(1:m)，第2次将T(2:m+1)存入A(1:m),…，第i次就应将T(i:m+i-1)存入A(1:m)，最后一次应将T(L-m+1:L)存入A(l:m)。因此，流程图的（2）中 应填m+i-1，由于m+i-1必须小于或等于L。当m+i-1&gt;L时，即当i&gt;L-m+1时，就不应该再取子串了。因此流程图的（1）处应填L-m+1。  
流程图右下方一片描述了字符数组A(i),A(i+1)，…，A(i+m-1)与字符数组K(1)，K(2)，…， K(m)的比较过程。题中用j表示数组K的动态下标指针，j=1,2，……，m。显然，数组A的动态下标指针为i+j-1（j=1，2,…,m)。两个字符数组都从左到右逐个字符地进行比较，如果发现有不一致的字符，就结束比较，将i增1后准备继续从数组T中取新的子串放在A中。 如果一直到比较结束，发现两个数组中对应的各个字符都是一致的，那么，就找到了一处关键词。此时，找到关键词的计数器n应增l(n+1—n)。因此，流程图的（4）处应填n+1。  
字符数组A与K的比较过程关键是逐个字符A(j)与K(j)的比较。由于允许模糊査找，即K(j)中的字符 "？" 可以与任何字符匹配。因此，可以写成判断“A(j)=K(j) or K(j)= "?""是否为真。只要K(j)= "?""，比较结果就一定为真。因此，流程图的（5）处应填 A(j)=K(j)。如果比较结果为真，则还需要执行j+1→j，准备继续往下比较。因此流程图的（3）处应填 j+1。  


## 第2题 ##

【问题1】  
![45550b98b1474f2f9751e9ca98f4da91.jpg][]  
  
本问题考查字符串运算及常见编程错误的处理。  
求子串运算substring的原型如下：  
![7d5c806a94e44bda9474d05c9958d933.jpg][]  
根据题目说明，参数index为子串的位置序号（从1开始)，length为子串的长度。 显然，在函数substring中，首先应判断参数的合理性，即index应不小于1，length应不小于0，同时，从index开始可以得到长度为length的子串，即index+length-1应不大于 最后一个字符的序号。因此，第6行的代码是正确的。  
第7行申请动态内存块的语句是正确的。第9行的代码判断内存申请是否成功，其中，判断指针tptr的表达式tptr = 0有错误，即误用了 “==”与“=”，导致无论内存申请操作是否成功，在此都将tptr赋值为空指针，造成内存泄漏。  
第10、11行代码用于从字符串str中复制子串，代码是正确的。第12行的代码设置 字符串的结束标志，为错误代码。由于所获得字符串的长度为length，其在动态数组tptr 的下标从0开始，因此，下标length-1为最后一个字符的下标，tptr\[length-l\] = ’\\0’会导致 丢失最后一个字符，因此该语句中tptr的下标应为length。  
  
【问题2】  
(1) n!=0 或 n&gt;0  
(2) n/10  
  
本问题考查整数运算。  
从题中给出的运算过程可知，在所运算的整数不为0时，运算过程会继续，因此空  
(1)处应填入“11!=0”。除以10后要丢掉个位数的处理则由空（2）处进行，即填入“n/10”。  
  
【问题3】  
运算结果溢出（或超出范围，或其他含义相近的描述)。  
  
本问题考查溢出问题。由于程序语言提供的基本数据类型都有其表示范围的限制，因此在运算过程中需要 注意是否发生溢出。通过分析，上面的运算过程并没有问题，而且前三个数据的处理结果都是正确的，因此最后一个数据出错的原因是其超出整型的表示范围造成的。  


## 第3题 ##

【问题1】  
(1) sizeof(int)  
(2) temp\[k++\] 或 \*(temp+k++)或等价表示  
(3) i&lt;k 或等价表示  
(4) a\[k++\] 或\*(a+k++)或等价  
  
本问题考査C程序结构、数组及运算的应用知识。  
根据题目中对函数CompactArr\_vl的处理思路描述，空（1）处应填入sizeof(int)。 以下代码将数组a中的非0元素复制到动态数组temp中。  
![624887dea52a41f399b8991b02f8100e.jpg][]  
显然，k应作为temp的下标索引变量使用，因此空（2）处应填入temp\[k++\]，当该 循环语句结束后，k的值也就是a中非0元素的个数。据此，空（3）处应填入i&lt;k。  
  
【问题2】  
可能由于动态内存申请操作失败而导致函数功能无法实现，没有释放动态数组空间 (存在内存泄漏问题)，时间和空间效率低。  
  
本问题考查程序分析基本能力。  
解决同一个问题会有多种不同的方法，务种方法都有其特点。在本问题中，相比于函数CompactArr\_v2, CompactArr vl的处理思路容易理解，由于数组a的数据需要复制 给temp,然后再复制回来，因此需要更多的空间支持，处理速度时间也更长。另外，其 代码执行时也可能由于申请内存空间的要求得不到满足，从而导致函数的功能不能实现， 虽然发生这种情况的概率很低，但也有可能发生。此外，数结束前也没有释放所申请 的内存块。  


## 第4题 ##

【问题1】  
(1) cptrH- 或 ++cptr 或 cptr +=1 或 cptr = cptr+-l  
(2) Push(&S, \*cptr)  
(3) Top(S)  
(4) Pop(&S)  
(5) IsEmpty(S)  
  
  
本题考查c程序设计基本能力。  
由于已经将表达式以字符串的形式存入字符数组expr,因此指针cptr就用于指示表 达式中的每个字符。显然，以下for语句用于扫描expr中的每个字符：  
for (cptr = expr; \*cptr!= 1\\0'; (1))  
  
因此，空（1）处应填入cpti++或其等价形式。  
空（2）处进行处理的前提是遇到了左括号，因此，根据题目中对函数ifMatched的 处理思路描述，这时应进行压栈操作，即应填入Push(&S，\*cptr),这里要注意函数调用 时实参的形式。  
由于弹栈操作不能返回栈顶元素，因此根据注释，空（3）处需要读取栈顶元素， 即应填入Top(S)，空（4）处填入Pop(&S)。  
由于表达式扫描结束且同时栈变为空，才说明表达式中的括号能完全匹配，因此， for语句的条件表达式\*cptr!=W不成立时表达式结束，此时控制流可以到达空（5）所在 语句，在此需要判断栈的状态来决定括号是否完全匹配，即空（5）处应填入IsEmpty(S)。&lt;  


## 第5题 ##

【问题1】  
(1) virtual  
(2) : public Shape  
(3) : public Ellipse  
(4) new Diagram  
(5) delete  
  
本题考查C++语言程序设计的能力，涉及类和抽象类、对象、函数和虚函数的定义和相关操作，以及继承关系。要求考生根据给出的案例和执行过程说明，认真阅读理清程序思路，然后完成题目。  
先考查类图整体结构。本题中根据类图定义了类：Diagram、Shape、Box、Ellipse、 Line和Circle。其中Shape为抽象类，表示通用图形，抽象类中应至少包含一个纯虚拟 (virtual)函数。Box表示矩形，Ellipse表示椭圆，Line表示线条，三者都是Shape的子类，继承了 Shape类，Circle表示圆（即特殊的椭圆），继承了 Ellipse。  
抽象类Shape的定义中，需要通过使用virtual标识虚函数，void paintO = 0;表示 paint()是纯虚函数，其定义前必须添加virtual进行表示。类Ellipse为Shape的子类，Circle 为Ellipse的子类，需要在代码中体现出继承。另外，在子类的构造函数中，调用父类的 构造函数，所以继承的权限为public。其语法为：public后加类名。  
类Diagram中没有定义构造函数，编译器生成一个缺省的构造函数，调用是釆用new 关键字加类名。使用完成之后，通过delete进行释放。  
因此空（1）需要表现出paint()函数为纯虚函数，即为virtual;空（2）和空（3）处 添加继承父类，并且权限为public,即为：public Shape和:public Ellipse ；空(4)处补 充通过使用编译器生成的缺省构造函数创建对象，即new Diagram;空（5）处通过delete 释放new创建的对象diagram。  


## 第6题 ##

【问题1】  
(1) abstract 或 public abstract  
(2) abstract 或 public abstract 或 protected abstract  
(3) extends Shape  
(4) extends Ellipse  
(5) eraseAShape(shapes\[i\])  
(6) new Diagram()  
  
本题考查Java语言程序设计的能力，涉及类和抽象类、对象、方法和抽象方法的定义和相关操作，以及继承关系。要求考生根据给出的案例和执行过程说明，认真阅读理 清程序思路，然后完成题目。  
先考查类图整体结构。本题中根据类图定义了类：Diagram、Shape、Box、Ellipse、 Line和Circle。其中Shape为抽象类，表示通用图形，抽象类中应至少包含一个抽象 (abstract)方法。Box表示矩形，Ellipse表示椭圆，Line表示线条，三者都是Shape的 子类，继承了 Shape类，Circle表示圆（即特殊的椭圆），继承了 Ellipse。  
抽象类Shape的定义中，需要通过使用abstract标识抽象方法，方法void paintO;没 有实现体，表示paintO是抽象方法，其定义前必须添加abstract进行表示。类Ellipse为 Shape的子类，Circle为Ellipse的子类，需要在代码中体现出继承。另外，在子类的构 造方法中，需调用父类的构造方法,而在父类中没有不带参数的构造方法，必须使用super 关键字显式地进行调用。在Java中，继承的语法为extends后加类名。  
类Diagram中没有定义构造方法，编译器生成一个缺省的构造方法,调用时釆用new 关键字加缺省构造器方法。  
因此空（1）和(2)需要表现出Shape为抽象类，paint()方法为抽象方法，即为abstract; .和（3）处添加继承父类Shape,即extends Shape；空（4）处补充继承父类Ellipse,即 extends Ellipse；空（5）处删除图形，即 eraseAShape(shapes\[i\])，调用空（6）通过使用 编译器生成的缺省构造方法创建对象，即newDiagram()  



[45550b98b1474f2f9751e9ca98f4da91.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第2题/45550b98b1474f2f9751e9ca98f4da91.jpg
[7d5c806a94e44bda9474d05c9958d933.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第2题/7d5c806a94e44bda9474d05c9958d933.jpg
[624887dea52a41f399b8991b02f8100e.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第3题/624887dea52a41f399b8991b02f8100e.jpg
