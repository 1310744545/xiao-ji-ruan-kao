---  
title: 2013年上半年  
# icon: gears  
order: 992  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
(1) 0或任意一个负数  
(2) (u(ij+1)+u(ij-1)+u(i-1j)+u(i+1j))/4或等价表示  
(3) max  
(4) new或（(u(i,j+1)+u(i，j-1)+u(i-1j)+u(i+1，j))/4或等价表示  
(5) max（共15分）  
  
本题考查算法（数值计算）流程的描述。  
封闭区域内稳定（没有奇异点）的温度场、磁场等都是调和函数。已知边界上的值，就可以近似计算区域内各点的值。对于网格化后的矩形区域\{0≤i≤m；0≤j≤n\},其边界点为\{(0，j)丨j=0，..，n\}、\{((i，0)丨i=0，..，m\}、\{(m，j)丨j=0,..,n\}、\{((i,n)|i=0,..,m\}，其内点为\{(i，j)|i=1，...，m-1;j=1，...，n-1\}。  
本题采用迭代法进行近似计算。初始时，设矩形每个内点处的u(ij)均等于常数u(0,0)。每次迭代需要再计算出所有内点处的u(ij)新值。为了检查迭代能否结束，需要算出所有内点处函数u的新值与旧值之差的绝对值是否都小于0.01(或判断其最大值是否小于0.01)。为此，每次算出的新值需要先暂存于一个临时变量new。它应是点(ij)上下左右四个点处u值的算术平均值，因此（2）处应填(u(i，j+1)+u(i，j-1)+u(i-1，j)+u(i+1，j))/4。  
为了计算本次迭代中新老值之差的绝对值|u(ij)-new|的最大值max,需要先对max赋一个不可能再低的值（由于绝对值总是非负，所以max常先存0)。因此（1）处可以填0(填任何一个负数也是可以的）。  
当某个内点处新老u值之差的绝对值超过max时，就需要将该值赋给max。因此，(3)处应填max。不管是否更新了max，此后新值就可以替代老值了。因此（4）处应填new。  
(5)处应填本次迭代求出的最大值max,以判断它是否小于0.01，是否达到了近似要求。如果已经达到误差要求，则计算结束，所有的u(ij)就是计算结果。否则，还需要继续进行迭代。  


## 第2题 ##

【问题1】  
(2) date.month&gt;2或其等价形式  
(3) DATE  
(4) theyear  
(5) days\_month\[i-1\]或其等价形式  
  
本题考查c程序的基本语法和运算逻辑。  
函数GetDateId(DATE date)的功能是计算并返回指定合法日期date是其所在年份的第几天。处理思路是：先将1月~date.month-l月的天数累加起来，然后加上date.month的天数date.day即可。若date.month&gt;2，则需要考虑特殊情况2月份，在闰年为29天而不是28天。因此，空（1）处应填入date.month，空（2）处应填入date.month&gt;2。  
函数Kday\_Date(int theyear,int k)的功能是计算并返回指定合法年份theyear (theyear≥1900)的第k天（1≤k≤365)所对应的日期。根据说明，显然空（3）应填入“DATE”。  
当k&lt;32时，计算出的日期一定在1月份；当k大于31而小于60(闰年时为61)时，计算出的日期一定在2月份；以此类推。函数中的处理思路是：先将k的值减去1月份的天数，若仍大于0,则继续减去2月份的天数，以此类推，直到k的值小于或等于0。此时将多减去的最后1个月的天数加上即可。因此，空（4）应填入“theyear”，空(5)应填入“days\_month\[i\]”。  


## 第3题 ##

【问题1】  
(1) i&lt;N+1或其等价形式  
(2) k++或++k或其等价形式  
(3) k&gt;N或k&gt;N+1或其等价形式  
(4) i+k或其等价形式  
(5) sieve\[i\]=0或其等价形式  
  
本题考査c程序的运算逻辑，应用案例是埃拉托斯特尼筛法求素数。  
显然，空(1) 所在的for语句用于设置Sieve\[\]的初始值，根据题目描述，一开始1~N范围内的自然数i都在序列中，因此对应的数组元素sieve\[i\]都要设置为1。因此，空（1）处应填入“i&lt;N+1”或其等价形式。  
根据注释，空（2）所在的for语句要找出剩下数中的最小者，也就是要找出sieve中第一个值不等于0的数组元素sieve\[k\]，顺序地考查sieve的元素即可，因此空（2）处应填入“k++”。  
空（3）应填入“k&gt;N”或其等价形式，表示要找的最小素数已经大于N，应结束处理。  
空（4）和（5）所在for语句用于将刚找出的素数k及其倍数从序列中去掉，用i表示k的倍数（包括k自己）时，i的取值为k，2k,3k在i的初值己设置为k的情况下，i的迭代方式为i=i+k，因此空（4）处应填入“i+k”，空（5）处应填入“sieve\[i\]=0”  


## 第4题 ##

【问题1】  
(1) 1  
(2) q-&gt;next或p-&gt;next-&gt;next  
(3) 0  
(4) p-&gt;next  
(5) p-&gt;code  
  
本题考查数据结构的应用和C程序的运算逻辑，主要涉及指针和链表。  
由于游戏最后剩一人时结束，因此空（1）处应填入“1”，表示N&gt;1时游戏过程要继续。  
当c等于2时，p所指结点的后继表示为q(q=p-&gt;next)，q所指结点即为要删除的结点，即如下图所示。  
![674130d54771451b9da32a50adca9f5d.jpg][]  
此时，需要修改p所指结点的指针域，令其指向q所指结点的后继结点，对应的操作为p-&gt;next=q-&gt;next(等同于p-&gt;next=p-&gt;next-&gt;next)，因此空（2）处应填入“q-&gt;next”或“p-&gt;next-&gt;next”。将q所示结点删除后的相关指针如下图所示。  
![8665de96fa4842cdb8c76b546b6b5ccb.jpg][]  


## 第5题 ##

【问题1】  
(1) virtual double  getGPA()=0  
(2) Student (stuNo,name,gs)  
(3) computeWg()+Apoints 或 Studen t::computeWg()+Apoints  
(4) Student(stuNo,name,gs)  
(5) computeWg()+Awards或Student::computeWg()+Awards  
(6) students\[i\]-&gt;getGPA()  
  
本题考查C++语言程序设计的能力，涉及类、对象、函数的定义和相关操作。  
以学校计算综合成绩(GPA)为背景。本题目中综合成绩除了考虑基础课程加权平均成绩（Wg）之外，还有附加分（Ag），程序的主要任务是计算加权平均成绩和附加分，并根据情况选择社会活动或学科竞赛获得的不同附加分：活动分(Apoints)或竞赛分（Jwarcfa)。每种成绩计算方式如题中所述。  
根据说明，将学生设计为一种类型，设计为类Student,学号（stuNo)、姓名（name)、课程成绩学分（grades)和综合成绩（GPA)分别作为其数据属性，构造函数中对stuNo、name,grades进行初始化，用相应的get函数获取相关属性值。对于GPA的获取值的函数，因为不同附加分的计算方法不同，设计为纯虚函数，具体实现由子类完成。将计算加权平均成绩设计为doublecomputeWg()。将有活动附加分的学生设计为ActStudent,有竞赛附加分的学生设计为CmpStudent,都作为Student的子类。  
子类中，继承父类中访问属性为protected的属性，其构造函数进行初始化时，调用父类Student中的构造函数对学号、项目和学分成绩进行初始化，并对活动分或竞赛分进行初始化。  
ActStudent(constint stuNo,conststring &name,intgs\[\]\[2\],intApoints)  
:Student(stuNo,name,gs)  
或  
CmpStudent(constint stuNo,conststring&name,intgs\[\]\[2\],intawards\[\]\[2\])  
:Student(stuNo,name,gs)  
在子类中，实现了获取GPA的函数getGPA，根据题目描述，GPA的计算方式为加权平均成绩（Wg)和附加分（Ag）之和，所以返回值就是：  
computeWg()+Apoints或computeWg()+Awards  
其中，computeWg()在父类Student中定义，子类直接可以作为自己的函数一样使用。  
主控逻辑代码在main函数中实现。初始化学生的各科学分和成绩，用数组gi表示，学生的竞赛分用数组ci表示。用Student\*student定义学生数组，而每个具体的学生是ActStudent或CmpStudent类型的对象，这里会自动向上转型成为Student类型。用for循环对每个学生的综合成绩进行输出，调用时会继续动态绑定每个数组元素的实际类型，并调用其getGPA函数，即:  
cout&lt; 使用完指针数组对象之后，需要用delete操作进行释放，即：delete\*students;0  
因此，空（1）需要指向定义纯虚函数getGPA()，即为virtualdoublegetGPA()=0；空（2）和空(4)需要调用父类的构造函数，即Student(stuNo,name,gs)；空（3）处计算附加分为活动分的GPA,调用computeWg()计算加权平均分，再加上附加分Apoints,即空（3）为computeWg()+Apoints；空（5）处计算附加分为竞赛分的GPA,调用computeWg()计算加权平均分，再加上计算出来的总竞赛分Awards，即空（5）为computeWg()+Awards；空（6）处为在循环中根据数组下标所表示的每个学生对象调用getGPA()输出每个学生的GPA,即students\[i\]-&gt;getGPA()。  


## 第6题 ##

【问题1】  
(1) abstract double get  GPA()  
(2) super(stuNo,name,grades)  
(3) compute Wg ()+Apoints或super.computeWg()+Apoints  
(4) super(stuNo,name,grades)  
(5) computeWg()+totalAwards或super.computeWg()+totalAwards  
(6) studentsfi\].getGPA()  
  
本题考査Java语言程序设计的能力，涉及类、对象、方法的定义和相关操作。  
以学校计算综合成绩(GPA)为背景。本题目中综合成绩除了考虑基础课程加权平均成绩（Wg)之外，还有附加分（Ag)，其主要任务是计算加权平均成绩和附加分，并根据情况选择社会活动或学科竞赛获得的不同附加分：活动分(Apoints)或竞赛分（Awards)。每种成绩计算方式如题中所述。  
根据说明，将学生设计为一种类型，设计为类Student，学号（stuNo)、姓名（name)、课程成绩学分（grades)和综合成绩（GPA)分别作为其数据属性，构造方法中对stuNo、name、grades进行初始化，用相应的get方法获取相关属性值。对于GPA的获取值的方法，因为不同附加分的计算方法不同，设计为抽象方法，实现由子类完成。因为类中包含抽象方法，所以Student必须设计为抽象类。将计算加权平均成绩设计为方法double compute Wg()。将有活动附加分的学生设计为ActStudent,有竞赛附加分的学生设计为CmpStudent,都作为Student的子类。  
子类中，继承父类中访问属性为protected的属性，其构造方法进行初始化时，调用父类Student中的构造方法对学号、项目和学分成绩进行初始化，并对活动分或竞赛分进行初始化。Java中，调用父类的构造方法在构造方法体内的第一条语句，即：Act Student(intstuNo,Stringname,int\[\]\[\]grades,intApoints)\{  
  
![4a6b2cfcb34949ecbaf5a655273205ff.jpg][]  
在子类中，实现了获取GPA的方法getGPA，根据题目描述，GPA的计算方式为加权平均成绩（Wg）和附加分（Ag)之和，所以返回值就是：  
compute Wg()+Apoints或computeWg()+totalAwards  
其中，compute Wg()在父类Student中定义，子类直接可以作为自己的方法一样使用。  
主控逻辑代码在GPASystem类中的main方法中实现。初始化学生的各科学分和成绩，用数组gi表示，学生的竞赛分用数组ei表示。用Student students\[\]定义学生数组，而每个具体的学生是ActStudent或CmpStudent类型的对象，这里会自动向上转型成为Student类型。用for循环对每个学生的综合成绩进行输出，调用时会动态绑定每个数组元素的实际类型，并调用其getGPA()方法，即:  
System.out.println(students\[i\].getGPA());  
因此，空（1）需要指向定义抽象方法getGPA(),即为abstractdoublegetGPA();空(2) 和空(4)需要调用父类的构造方法，即super(stuNo,name，grades);空(3)处计算附加分为活动分的GPA,调用computeWg()计算加权平均分，再加上附加分Apoints,即空(3)为computeWg()+Apoints;空(5)处计算附加分为竞赛分的GPA,调用computeWg()计算加权平均分，再加上计算出来的总竞赛分totalAwards,即空（5）为computeWg()+totalAwards；空（6）处为在循环中根据数组下标所表示的每个学生对象调用getGPA()输出每个学生的GPA，即students\[i\].getGPA()。  



[674130d54771451b9da32a50adca9f5d.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/674130d54771451b9da32a50adca9f5d.jpg
[8665de96fa4842cdb8c76b546b6b5ccb.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/8665de96fa4842cdb8c76b546b6b5ccb.jpg
[4a6b2cfcb34949ecbaf5a655273205ff.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第6题/4a6b2cfcb34949ecbaf5a655273205ff.jpg
