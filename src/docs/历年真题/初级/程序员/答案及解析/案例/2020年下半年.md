---  
title: 2020年下半年  
# icon: gears  
order: 978  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
(1)0  
(2)L+1或等效形式  
(3)0→L或等效形式  
(4)L&gt;M或L≥M或等效形式  
(5)M  
  
本题旨在考查程序设计（算法流程图设计）的能力。  
本流程图采用的算法是对二进制位串从左到右进行逐位判断，并累计连续遇到数字1的个数L，再以“打擂台”的方式动态地得到当前L的最大值M。  
初始时，L和M都应该是0，即尚未遇到数字1，数字1的连续长度L为0, L的“擂台”最大值M也是0,因此，流程图的空(1)处应填0。  
接着开始对i=1，2，...，n循环，依次判断二进制数位A\[i\]是否为1。如果A\[i\]=1，就应该将L增1，即执行L+1→L，因此流程图的空(2)处应填L+1;如果A\[i\]=0,则应该将数字1的累计长度L清0,重新开始累计，因此，流程图的空(3)处应填0→L。  
当遇到数字1进行累计L后，应将L与现行的擂台值M进行比较。如果L&gt;M，则显然应该以新的L值代替原来的M值，即执行L→M;如果L&lt;M，则不能更新M值；如果L=M，则可以更新也可以不更新M值，对计算结果没有影响（当然更新M值浪费了一些计算量)。 为此，流程图的空(4)处可填L&gt;M或L≥M (填前者更好)，而空(5)处应填M。  


## 第2题 ##

【问题1】  
(1)fabs(x)&lt;=1e-6或fabs(x)&lt;=0.000001x==0.0或等效形式  
(2)x2  
(3)x/(x1\*x1) 或等效形式  
(4)(x2-x1)/xl或等效形式  
(5)x+=0.1或x=x+0.1或等效形式  
  
本题考查c程序基本运算和流程控制的应用。  
函数cubeRoot(x)根据给定的公式计算x的立方根。  
根据精度要求，绝对值小于1e-6的数，其立方根为0,因此，空(1)处应填入“fabs(x)&lt;=1e-6”或其等效形式。  
分析函数cubeRoot中的代码，可知xl对应公式中的xn，x2对应公式中的xn+1，每次循环时，需要将x2传给x1，再计算出新的x2，因此空(2)处应填入“x2”，空(3)处应填入“x/(x1\*x1)”。在满足精度要求时结束循环，即空(4)处应填入“(x2-x1)/X1”。  
根据题干部分的说明，显然空(5)处应填入“x+=0.1”或其等效形式。  


## 第3题 ##

【问题1】  
(1)\*c-'0'或 c\[0\]- '0'或 \*c-48 或 c\[0\]-48或等效形式  
(2)isUpper(\*p)或isUpper(p\[0\])  
(3)isLower(\*p)或isLower(p\[0\])  
(4)isDigit(\*p)或isDigit(p\[0\])  
(5)p++或++p或p=p+1或p+=1或等效形式  
  
本题考查C程序流程控制和函数定义与调用的应用。  
观察代码中定义的函数，isUpper(char c)、isLower(char c)、isDigit(char c)的形参为传值方式的字符型参数，调用这些函数时实参为字符变量或常量。toUpper(char \*c)、toLower(char\*c) cDigit(char\*c)&gt; convertion(char\*p)的形参为字符指针类型，调用这些函数时实参应为指向字符的指针（字符变量的地址)。  
根据题干部分的描述，求解数字字符的伙伴字符时，需要进行算术运算，用9减去数字字符对应的数值（即数字字符-'0'),得到的值再加上'0'从而再次转换为数字字符，因此空(1)处应填入“\*c-'0'”或其等效形式。  
函数convertion(char\*p)根据题干描述的要求对字符进行转换，满足空(2)所给的条件时得要调用toLower(p)将字符转换为小写字母，因此空(2)处应判断字符是否为大写字母，应填入“isUpper(\*p)”或其等效形式；满足空(3)所给的条件时需要调用toUpper(p)将字符转换为大写字母，因此空(3)处应判断字符是否为小写字母，应填入“isLower(\*p)”或其等效形式；满足空(4)所给的条件时需要调用cDiglt(p)将数字字符转换为其伙伴字符，因此空(4)处应判断字符是否为数字字符，应填入“isDigit(\*p)”或其等效形式。  
在while循环中还需要对指针变量p进行递增，处理完p指向的当前字符后再指向下一字符，因此空(5)处应填入“p++”或其等效形式。  


## 第4题 ##

【问题1】  
(1)tail  
(2)p-&gt;key或（\*p).key或等效形式  
(3)p-&gt;next或（\*p).next或等效形式  
(4)!tail 或tail==NULL或等效形式  
(5)p-&gt;next或（\*p).next或等效形式  
  
本题考查c程序流程控制和指针的应用。  
函数createList()中首先创造链表的第一个结点，然后通过循环来创建其余的n-l个结点。显然，创建第一个结点后，该结点是表尾结点，因此空(1)处应填入“tail”，来设置表尾指针。通过运算p-&gt;next=p，形成只有1个结点的单循环链表，如下图所不。  
![a3b656d7f87f4b70a652d4612d00d63c.jpg][] 对于for循环中创建的每一个结点（p所指)，首先通过运算p-&gt;key=a\[i\]设置其数据域的值，因此空(2)处应填入“p-&gt;key”或其等效形式，如下图（a）所示，然后设置新结点的指针域（p-&gt;next)，使其指向第一个结点（tail-&gt;next所指），即p-&gt;next=tail-&gt;next,如下图（b）所示，再将结点链接进入链表，即tail-&gt;next=p，如下图（c）所示，最后更新表尾指针，即tail=p。因此空(3)处应填入“p-&gt;next”。  
![e87d086cbb4f492da2b6f1bbf9c7e6af.jpg][]  
函数display(NodePtr tail)输出链表中结点数据域的值，参数为表尾指针。当链表为空时，该函数可以直接结束，因此空(4)处通过tail指针进行判断，应填入“tail==NULL”或其等效形式。该函数中通过变量p遍历链表中的结点，因此空(5)处需要修改p，使其指向下一个结点，应填入“p-&gt;next”。  


## 第5题 ##

【问题1】  
(1)extends  
(2)this.order  
(3)super(order)  
(4)super(order)  
(5)super.print()rder()  
(6)extends  
(7)this.order  
  
本题考査Java语言程序设计的能力，涉及类、对象、方法的定义和相关操作。要求考生根据给出的案例和代码说明，阅读并完成程序填空。  
本题目中涉及打印订单内容、打印抬头和打印脚注。根据说明进行设计，题目给出了类图（图5-1类图所示）。  
图中类Onier有PrintOrder和Decorator两个子类。Decorator与Order之间是聚合关系。Decorator有两个子类HeadDecorator和FootDecorator,分别实现打印抬头和打印脚注的功能。java语言中，子类继承父类采用关键字extends实现。Order类中定义printOrder()方法，实现打印“订单内容”。Decorator中定义私有Order类型成员order,即：  
private Order order;  
并且定义带参数构造器：  
public Decorator(Order order)\{…\}  
其中对order进行初始化。  
Java中，一个类有显式定义带参数构造器，那么，编译器就不会自动生成缺省的构造器，而子类构造器中首先调用父类的构造器，缺省的情况下调用父类的缺省无参数构造器，带参数构造器需要显式调用，形式为super(参数)。对象的属性若为引用类型，自动初始化为nmll， 所以需要在构造器中对order如以显式初始化。其构造器接收order，参数名称与对象的属性名均为order,需要用this关键字来引用当前对象或类实例，可以用点取属性或行为，即：  
this.order=order;  
Decorator覆盖父类的printOrder()方法。在print().order()方法中，order不为空引用时，用order.printOrder()调用Order的printOrder()方法，实现打印“订单内容”；而若order为空时，则不进行调用，即没有打印订单内容。  
HeadDecorator类和Fool Decorator类中均定义带Order类型参数的构造器。在Java中，构造器中自动调用父类中的缺省无参数构造器，而Decorator中只定义了带参数构造器，因此，需要显式调用父类Decorator中的构造器，形式为：super(参数)，即super(order)，对Decorator中私有成员order进行初始化。  
HeadDecorator覆盖父类的printOrder()方法。在printOrder()方法中，先打印“订单抬头”， 再使用super.printOrder()调用父类的printOrder()方法打印“订单内容”。FootDecorator覆盖父类的printOrder()方法。在print().order()方法中，先使用super.printOrder()调用父类的printOrder()方法打印“订单内容”，再打印“订单脚注”。  
在PrintOrder类中，实现整体订单的打印逻辑。其中定义Order成员变量order，构造器PrintOrder(Order order)中对order进行初始化，因为参数名称也是order，所以需要采用this.order区分对象的属性。在printOrder()方法中，实现的主要逻辑为打印“订单内容”的基础上，加上打印“订单抬头’和“订单脚注”。此时，order对象不为null时只可以打印“订单内容”，再执行如下语句:  
FootDecorator foot = new FootDecorator(order);  
实现在打印“订单内容”的®础上，加上打印“订单抬头”，再执行如下语句：  
HeadDecorator head = new HeadDecorator(foot);  
实现在打印“订单内容”和“订单抬头”的基础上，加上打印“订单脚注”。此时，head.printOrder()调用执行printOrder()方法即可打印出：  
“订单抬头”  
“订单内容”  
“订单脚注”  
若order对象为null时,则只打印出“订单抬头”和“订单脚注”。  
入口方法main()定义在PrimOrder类中。在main()方法中，先创建Order类的对象order，并作为参数传递给PrintOrder的构造器进行对象的创建，名称为print,之后print.printOrder()即调用PrintOrder中的printOrder()方法，执行主要打印逻辑。即：  
Order order=new Order();  
PrintOrder print=new PrintOrder(order);  
print.printOrder();  
综上所述，空(1)和空(6)表示继承Order类，即extends;空(2)需要表示Decorator对象的order属性，即this.order;空(3)和空(4)需要显式调用父类Decorator的带参数构造器，参数为order,即super(order)；空(5)处调用父类对象的printOrder()方法，即super.print()rder()；空(7)需要表示 PrintOrder对象的order属性，即this.order。  


## 第6题 ##

【问题1】  
(1):public Order  
(2)this-&gt;order或（\*this).order  
(3)Decorator(order)  
(4)Decorator(order)  
(5)Decorator::printOrder()  
(6):public Order  
(7)this-&gt;order或(\*this).order  
  
本题考查C++语言程序设计的能力，涉及类、对象、函数的定义和相关操作。要求考生根据给出的案例和代码说明，阅读并完成程序填空。  
本题目中涉及打印订单内容、打印抬头和打印脚注。根据说明进行设计，题目给出了类图（图6-1类图所示)。  
图中类Order有PrintOrder和Decorator两个子类。Decorator与Order之间为聚合关系。Decorator有两个子类HeadDecorator和FootDecorator,分别实现打印抬头和打印脚注的功能。C++语言中，子类继承父类使用冒号(：)加父类实现。Order类中定义虚函数virtual void printOrder()方法，实现打印“订单内容”。Decorator中定义私有Order成员，即：  
private: Order \*order;  
并且定义带参数构造器：  
public: Decorator(Order\*order)\{...\}  
其中对order进行初始化。  
C++中，一个类有显式定义带参数构造器时，编译器就不会自动生成缺省的构造器，而子类构造器中首先调用父类的构造器，缺省的情况下调用父类的缺省不带参数构造器，带参数构造器需要显式调用，形式为冒号（:）加上父类的带参数构造器。对象的属性若为引用类型，自动初始化为NULL,所以需要在构造器中对order加以显式初始化。其构造器接收order，参数名称与对象的属性名均为order,需要用this关键字来引用当前对象或类实例，可以用this-&gt;或(\*this)取属性或行为，即：  
this-&gt;order=order;或(\*this).order=order;  
Decorator覆盖父类的printOrder()方法。在printOrder()方法中，实现order不为空引用时，采用order-〉printOrder()调用Order的printOrder()方法，实现打印“订单内容”；而若order为空时，则不进行调用，即没有打印订单内容。  
HeadDecorator类和FootDecorator类中均定义带Order类型的参数的构造器。在C++中， 构造器中自动调用父类的缺省无参数构造器，而Decorator中只定义了带参数构造器，因此，需要显式调用父类Decorator中的带参数构造器，形式为：构造器名(参数)，即Decorator(order), 对Decorator中私有成员order进行初始化。  
HeadDecorator覆盖父类的printOrder()方法。在printOrder()方法中，先打印“订单抬头”，再使用Decorator::printOrder()调用父类的printOrder()方法打印“订单内容”。FootDecorator覆盖父类的printOrder()方法。在printOrder()方法中，先使用Decorator::print:Order()调用父类的printOrder()方法打印“订单内容”，再打印“订单脚注”。  
在PrintOrder类中，实现整体订单的打印逻辑。其中定义Order属性变量order，构造器Print()rder(Order order)中对order进行初始化，因为参数名称也是order，所以需要采用this-&gt;order或(\*this).order区分对象的属性。在printOrder()方法中，实现的主要逻辑为打印“订单内容”的基础上，加上打印“订单抬头”和“订单脚注”。此时，order对象不为NULL时只可以打印“订单内容”，再执行如下语句：  
FootDecorator \*foot=new FootDecorator(order);  
实现在打印“订单内容”的基础上，加上打印“订单抬头”，再执行如下语句：  
HeadDecorator \*head=new HeadDecorator(foot);  
实现在打印“订单内容”和“订单抬头”的基础上，加上打印“订单脚注”。此时，head-&gt;print()rder()调用执行printOrder()方法即可打印出：  
“订单抬头”  
“订单内容”  
“订单脚注”  
若order对象为NULL时，则只打印出“订单抬头”和“订单脚注”。  
入口函数main()中，先用new关键字创建Order类的对象，即对象指针order,并作为参数传递给PrintOrder的构造器进行创建PrintOrder对象，即对象指针print,之后pirint-&gt;printOrder()即调用PrintOrder中的printOrder()方法，执行主要打印逻辑。即:  
Order \*order=new Order();  
PrintOrder \*print=new PrintOrder(order);  
print-&gt;printOrder();  
综上所述，空(1)和空(6)表示继承Order类，即:public Order；空(2)需要表示Decorator对象的order属性，即this-&gt;order或(\*this).order;空(3)和空(4)需要显式调用父类Decorator的带参数构造器，参数为order，即Decorator(order);空(5)处调用父类对象的print()rder()方法，即Decorator::printOrder();空(7)需要表示PrintOrder对象的order属性，即this-&gt;order或\*this).order。  



[a3b656d7f87f4b70a652d4612d00d63c.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/a3b656d7f87f4b70a652d4612d00d63c.jpg
[e87d086cbb4f492da2b6f1bbf9c7e6af.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/e87d086cbb4f492da2b6f1bbf9c7e6af.jpg
