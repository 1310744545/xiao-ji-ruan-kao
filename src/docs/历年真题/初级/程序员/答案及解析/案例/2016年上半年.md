---  
title: 2016年上半年  
# icon: gears  
order: 986  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
（1）A\[i\]  
（2）C\[k\]+1  
（3）1  
（4）k，C\[k\]  
（5）  
4，0  
5，2  
  
本题考查程序设计算法即流程图的设计。  
先以问题中的简例来理解算法过程。  
已知A\[1：5\]=\{3，2，5，5，1\}。初始时计数数组c\[1：5\]=\{0，0，0，0，0\}。  
再逐个处理数组A的各个元素（根据A\[i\]的值在c\[A\[i\]\]中计数加1）：  
A\[1\]=3，计数c\[3\]=1；A\[2\]=2，计数c\[2\]=1；A\[3\]=5，计数c\[5\]=1；A\[4\]=5，计数c\[5\]=2；A\[5\]=1，计数c\[1\]=1。最后，计算得到c\[1：5\]=\{1，1，1，0，2\}，即表明A\[：5\]中数4缺失，数5有2，其他数都只有1个。  
再看流程图。左面先对数组C初始化（赋值都是0）。再对A\[i\]各个元素逐个进行处理。将A\[i\]送k，再对c\[k\]计数加1。因此，（1）处应填A\[i\]，（2）处应填c\[k\]+1→c\[k\]。  
流程图右面需要输出计算结果。对于k的循环，当c\[k\]=1时（非缺非重）不需要输出；否则，应按要求的格式输出：缺或重的数，以及出现的次数。为此，（3）处应填1（与1比较），（4）处应填k,c\[k\]。  
再看简例的输出，先输出4，0（数4缺失）；再输出5，2（数5有2个）。  


## 第2题 ##

【问题1】  
(1)set\[0\]==ch或\*set==ch或等价形式  
(2)ch，set+1或ch，++set或等价形式  
(3)lenA或等价形式  
(4)!is\_elem（setB\[i\]，setA）或等价形式  
(5)setC\[lenC\]或\*（setC+lenC）或等价形式  
  
本题考查C程序设计的基本结构和运算逻辑。  
函数is\_elem（char ch，char\*set）的功能是判断给定字符是否在一个字符串中，其运算逻辑是：若ch所存的字符等于字符数组set的第一个字符，则结束；否则再与set中的第二个字符比较，依此类推，直到串尾。因此空（1）处应填入“set\[0\]==ch”或其等价表示。题目要求该函数以递归方式处理，并在空（2）处填入递归调用时的实参，显然，根据函数is\_elem的首部信息，递归调用时第一个参数仍然为“ch”，第二个参数是需给出set中字符串的下一个字符的地址（第一次递归时为字符串第二个字符的地址，第二次递归时实际为字符串第三个字符的地址，由于传进来时与ch进行比较的字符都是\*set，那么下一个字符就都表示为set+1），即为&set\[1\]，或者为set+1，所以空（2）处应填入参数“ch，set+1”或其等价表示。  
函数combine（char\*setA，char\*set.B）的功能是将字符集合A和字符集合B合并，并返回合并后的字符集合，处理思路是：现将A集合的元素全部复制给集合C(stmcpy（setC，setA，lenA）），然后按顺序读取集合B中的字符，判断其是否出现在A中。如果来自集合B的字符已经在A中，则忽略该字符，否则，将其加入集合C。  
变量lenC表示集合C的元素个数，其初始值应等于lenA，因此空（3）应填入“lenA”。  
根据注释，空（4）应填入“!is\_elem（setB\[i\]，setA）”，判断来自集合B的元素setB\[i\]是否在集合setA中。空（5）处的代码作用是设置字符数组setC的尾部字符“\\0”，j由于lenC的值跟踪了该集合中元素数目的变化，其最后的值正好表示了setC的元素个数，所以该空应填入“setC\[lenC\]”或其等价表示。  


## 第3题 ##

【问题1】  
(1)d&gt;30或d&gt;=31或等价形式  
(2)d&lt;=29或d&lt;30或等价形式  
(3)t1&lt;=t2或等价形式  
(4)!fp或fp==0或fp==NULL  
(5)!isLegal（date）  
(6)Lteq（start，date）&&Lteq（date，end）或等价形式  
  
本题考查C程序设计的基本结构和运算逻辑。阅读程序时需先理解程序的结构，包括各函数的作用，然后确定主要变量的作用。本题中，函数isLegal（DATE date）的作用是判断date表示的日期是否合法。对一个日期数据，需要分别判断年、月、日的合法性。基本的规则是月份只能在整数区间\[1，12\]，日只能在整数区间\[1，31\]，还需结合大、小月及2月份的特殊性。按照题目要求，满足条件（y&lt;1985||y&gt;2010||m&lt;1||m&gt;12||d&lt;1||d&gt;31）的日期先排除，接下来考虑小月份，即4、6、9、11这四个月份不存在31日，所在这几个月中若出现31日或更大值，就是非法日期，即空（1）处应填入“d&gt;30”或其等价形式。当月份为2时，需要考虑是否闰年，闰年的2月是29天、平年是28天，因此空（2）处应填入“d&lt;30”或其等价形式。  
函数Lteq（DATE d1，DATE d2）的功能是比较日期d1和d2的前后，若d1在d2之前或相同则返回1，否则返回0。通过将日期数据转换为整数来比较日期的先后，显然，日期靠前时其对应的整数就小，因此空（3）处应填入“t1&lt;=t2”或其等价形式。  
在main函数中，从文本文件中读取日期数据，因此文件指针fp与文件的关联失败时，应结束程序，空（4）处应填入“fp==NULL”或其等价形式。  
根据题意，非法日期不输出，因此空（5）处应填入“!isLegal（date）”或“isLegal（date）==0”。  
根据注释，空（6）处应填入“Lteq（start，date）&&Lteq（date，end）”或其等价j形式。  


## 第4题 ##

【问题1】  
(1) father=NULL或father=0或等价形式  
(2) p-&gt;key!=kword或等价形式  
(3) p或p!=0或p!=NULL  
(4) sizeof（BSTNode）或等价形式  
(5) \*rootptr  
(6) father-&gt;left=p  
(7) father-&gt;right=p  
  
本题考查C程序设计的基本结构和数据结构的实现。  
根据二叉查找树的定义，其左子树中结点的关键码均小于树根结点的关键码，其右子树中结点的关键码均大于根结点的关键码，因此，将一个新关键码插入二叉查找树时，若等于树根或某结点的关键码，则不再插入，若小于树根，则将其插入到左子树中，否则将其插入到右子树中。  
根据注释，空（1）处需将father设置为空指针，应填入“father=NULL”或其等价形式。  
空（2）所在语句用于查找新关键码的插入位置，p指向当前结点。查找结果为两种：若找到，则p指向的结点的关键码等于新关键码，若没有找到，则p得到空指计值。因此空（2）处应填入“p-&gt;key!=kword”或其等价形式，在得到结果前使得查找过程可以继续，并且用father记录新插入结点的父结点指针。  
空（3）处应填入“p”或其等价形式，表明查找到了与kword相同的结点，无须再插入该关键码。   
空（4）处应填入“sizeof（BSTNode）”在申请新结点空间时提供结点所需的字节数。  
空（5）处应填入“\*rootptr”，使得新结点作为树根结点时，树根结点的指针作为二叉链表的标识能得到更新。  
根据注释，空（6）应填入“father-&gt;left=p”、空（7）应填入“father-&gt;right=p”。  


## 第5题 ##

【问题1】  
（1）extends Vehicle  
（2）static int  
（3）extends Vehicle  
（4）static int  
（5）v.get（i）.book  
（6）212  
（7）2010  
（8）2005  
  
本题考查Java语言程序设计，涉及类、继承、对象、方法的定义和相关操作。要求考生根据给出的案例和代码说明，认真阅读理清程序思路，然后完成题目。  
先考查题目说明，实现两类交通工具（night和Train）的简单订票处理，根据说明进行设计。题目说明中图5-1的类图给出了类Vehicle、Flight、Train之间的关系。涉及到交通工具类Vehicle、其子类Flight和Train两类具体交通工具。简单订票就针对这两类具体的交通工具，每次订票根据所选订票的交通工具和所需订票数进行操作。  
不论哪类交通工具，订票操作book在余票满足条件的情况下将余票减少所订票数，不足时则给出“余票不足”提示，所以在父类Vehicle中定义并实现voidbook（int n）方法。每类具体交通工具获取自身类型的票数（getTicket），订票也只减少自身类型票数（decreaseTicket（int n））等类以及相关操作。因此，在父类Vehicle中，分别定义针对上述两个操作的抽象方法：  
abstract int getTicket ()；  
abstract void decreaseTicket（int n）；  
在Java中，abstract作为抽象方法的关键字，包含抽象方法的类本身也必须是抽象类，因此，类Vehicle前需要有abstract关键字修饰，即：  
abstract class Vehicle\{……\}  
而且，抽象方法必须由其子类实现。从题目说明给出的类图（图5-1）也可以看出，Vehicle的两种具体类（子类）为Flight和Train。Java中，子类继承父类用关键字extends，不  
论父类是抽象类还是具体类，即：  
class 子类名 extends 父类名  
因此，Flight和Train的定义分别为：  
class Flight extends Vehicle  
class Train extends Vehicle  
Flight类和Train类中必须实现getTicket和decreaseTicket方法才能进行获取票数和减少余票的操作。因此，这两个类中都实现了getTicket和decreaseTicket方法。  
Flight和Train两类具体交通工具的票数需要分别记录，并且每次订票操作需要对总数进行操作，所以需要定义为类变量，同一类的所有对象共享此变量。在Java中，定义类变量的方式是将变量定义为静态变量，即用static关键字修饰。同时分析对票数的使用，getTicket和decreaseTicket两个方法的返回值和参数都用类型int，因此，票数tickets也定义为int。综合上述两个方面知，tickets定义为static int类型。  
测试类Test中实现了订票系统的简要控制逻辑，主控逻辑代码实现在main()方法中其中创建欲进行订票的对象、持有对象的集合、订票逻辑等。定义表集合类型变量v，此处采用泛型集合，在v中，可以持有Vehicle类型及其子类型的对象。ArrayList&lt;E&gt;链表集合中的方法add（E e）用于给链表集合的最末端添加元素，get（int index）用以获取链表集合中索引位置为index的元素，size()用以获取链表集合的元素个数。主控逻辑中创建Flight和Train两个具体类的一些订票请求对象加入v中，因Flight和Train均为Vehicle的子类型，而已是具体类，所以满足加入元素的要求，故\#用new Flight()和new Train()来创建相应的对象加入v中；然后通过for循环使每个订票请求对象进行订票，并输出剩余票数：  
![3da2ff60129f47e68e920a9c13ee9d4f.jpg][]  
即从v中取每个对象，调用book方法进行订票操作。v.get（i）获得v中位置为i的元素，即Vehicle类型的对象，Java中，动态绑定机制使得不同对象接收同一消息后发生不同的响应，即具体行为由位置为i的对象决定。此处无须类型转换，这是因为在父类Vehicle中，已经定义了book方法，并且中明了book所调用的getTicket和decreaseTicket方法接口，子类分别加以实现。另外，在上述getTicket和decreaseTicket两个方法执行时，因为每次操作tickets为static静态类型，所以，每个操作均作用在当前类变量的剩余票数，即具体子类型的有唯一一个当前剩余票数，每次操作都是上次对象修改之后的值的基础上继续更新。  
在main()方法中，依次新建并加入了5个对象，按顺序类型分别为：Flight、Train、Flight、Train，Train，加入v中的index分别为0、1、2、3、4。在for循环中，按顺序获取链表集合中的对象元素，并进行订票，数量为i+1张，然后输出剩余票数。因此，采用v.get（i）.book（i+1）进行订票，采用v.get（i）.getTicket()获得当前对象元素所属类的剩余票数。其中Flight的剩余票数216-1=215、215-3=212；Train的剩余票数为2016-2=2014、2014-4=2010、2010-5=2005。按对象顺序则为：215、2014、212、2010、2005，  
综上所述，空（1）和（3）需要表示继承Vehicle抽象类，即extends Vehicle；空（2）和（4）需要分别表示Flight和Train中tickets变量为静态整型变量，即static int；空（5）处为调用获取v中对象元素并订票的v.get（i）.book；空（6）为212；空（7）为2012；空（8）为2005。  


## 第6题 ##

【问题1】  
(1)public Vehicle  
(2)static int  
(3)public Vehicle  
(4)static int  
(5)（\*v\[i\]）.book  
(6)212  
(7)2010  
(8)2005  
  
本题考查C++语言程序设计，涉及类、继承、对象、函数的定义和相关操作。要求考生根据给出的案例和代码说明，认真阅读理清程序思路，然后完成题目。  
先考查题目说明，实现两类交通工具（Flight和Train）的简单订票处理，报据说明进行设计，题目说明中图6-1的类图给出了类Vehicle、Flight、Train之间的关系。涉及到交通工具类Vehicle、其子类Flight和Train两类具体交通工具。简单订票就针对这两类具体的交通工具，每次订票根据所选订票的交通工具和所需订票数进行操作。  
不论哪类交通工具，订票操作book在余票满足条件的情况下将余票减少所订票数，不足时则给出“余票不足”提示，所以在父类Vehicle中定义并实现voidbook（int n）函数。每类具体交通工具获取自身类型的票数（getTicket），订票也只减少自身类型票数（decreaseTicket（int n））等类以及相关操作。因此，在父类Vehicle中，分别定义针对上述两个操作的虚函数：  
virtual int getTicket ()=0；  
virtual void decreaseTicket（int）=0；  
在C++中，virtual作为虚函数的关键字，“=0；”表示为纯虚函数，包含虚函数的类本身也是虚拟类，而且，虚函数必须由其子类实现。从题目说明给出的类图（图6-1）也可以看出，  
Vehicle的两种具体类（子类）为Hight和Train。C++中，子类继承父类用“：”，即：  
class 子类名：继承的方式 父类名  
考查主控函数mam()，需要将Flight和Train类型的对象加入模板类型为Vehicle的向量中，因此，Flight和Train的实现分别为：  
class Flight：public Vehicle  
class Train：public Vehicle  
Flight类和Train类中必须实现getTicket和decreaseTicket函数才能进行获取票数和减少余票的操作。因此，这两个类中都实现了getTicket和decreaseTicket函数。  
Flight和Train两类具体交通工具的票数需要分别记录，并且每次订票操作需要对总数进行操作，所以需要定义为类变量，同一类的所有对象共享此变量。在C++中，定义类变量的方式是将变量定义为静态变量，即用static关键字修饰。同时分析对票数的使用，getTicket和decreaseTicket两个函数的返回值和参数都用类型int，因此，票数tickets也定义为into综合上述两个方面知，tickets定义为static int类型。而且，在C++中，static int类型的变量必须在类外进行初始化，即：  
int Train：：tickets=2016；//初始化Train的票数为2016  
int Flight：：tickets=216；//初始化Flight的票数为216  
主函数main()中实现了订票系统的简要控制逻辑，其中创建欲进行订票的对象、持有对象的集合、订票逻辑等。定义vector&lt;Vehicle&gt;向量类型变量v，此处采用模板类集合，在v中，可以持有Vehicle类型及其子类型的对象指针。vector&lt;E&gt;向量中的函数push\_back（E e）用于给向量的最末端添加元素，采用向量元素下标index获取向量中索引位置为index的元素，即对象指针，size()用以获取向量的元素个数。主控逻辑中创建Flight和Train两个具体类的一些订票请求对象加入v中，因为Flight和Train均为Vehicle的子类型，而且是具体类，所以满足加入元素的要求，故采用new Flight()和newTrain()来创建相应的对象加入v中；然后通过for循环使每个订票请求对象进行订票，并输出剩余票数：  
![1f7dc0479fca40888714b3d144b51f1f.jpg][]  
即从V中取每个对象指针，用其指向的对象调用book函数进行订票操作。v\[i\]获得V中位置为i的元素，（\*v\[i\]）则是Vehicle类型的对象，由于面向对象的多态机制使得不同对象接收同一消息后发生不同的响应，即具体行为由位置为i的对象指针所引用的对象决定。此处无须类型转换，这是因为在父类Vehicle中，已经定义了book函数，并且声明了book所调用的  
getTicket和decreaseTicket函数接口，子类分别加以实现。另外，在上述getTicket和decreaseTicket两个函数执行时，因为每次操作tickets为static静态类型，所以，每个操作均作用在当前类变量的剩余票数，即具体子类型的有唯一一个当前剩余票数，每次操作都是上次对象修改之后的值的基础上继续更新。  
在main()函数中，依次新建并加入了5个对象，按顺序类型分别为：Flight、Train，Flight、Train、Train，加入v中的index分别为0、1、2、3、4。在for循环中，按顺序获取向量中的对象元素，并进行订票，数量为i+1张，然后输出剩余票数。因此，采用（\*v\[i\]）.book（i+l）进行订票，采用（\*v\[i\]）.getTicket()获得当前对象元素所属类的剩余票数。其中Flight的剩余票数216-1=215、215-3=212；Train的剩余票数为2016-2=2014、2014-4=2010、2010-5=2005，按对象顺序则为：215、2014、212、2010、2005。  
综上所述，空（1）和（3）需要表示继承Vehicle虚类，即public Vehicle；空：（2）和（4）需要分别表示Flight和Train中tickets变量为静态整型变量，即static int；空（5）处为调用获取v中对象元素并订票的（\*v\[i\]）.book；空（6）为212；空（7）为2010；空（8）为2005。  



[3da2ff60129f47e68e920a9c13ee9d4f.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第5题/3da2ff60129f47e68e920a9c13ee9d4f.jpg
[1f7dc0479fca40888714b3d144b51f1f.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第6题/1f7dc0479fca40888714b3d144b51f1f.jpg
