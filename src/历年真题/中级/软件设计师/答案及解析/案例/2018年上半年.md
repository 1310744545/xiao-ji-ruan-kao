---  
title: 2018年上半年  
# icon: gears  
order: 982  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1：客户  
E2：医生  
E3：主管  
  
本题考查采用结构化方法进行软件系统的分析与设计，主要考查数据流图（DFD)的应用，考点与往年类似。DFD是结构化分析与设计方法中面向数据流建模的工具，它将系统建模成输入、加工（处理)、输出的模型，并采用自顶向下分层且逐层细化的方式，建模不同详细程度的数据流图模型。  
首先需要建模上下文数据流图（顶层DFD)来确定系统边界。在上下文DFD中，待开发软件系统被看作一个加工，为系统提供输入数据以及接受系统输出数据的外部实体，外部实体和加工之间的输入输出即为流入和流出系统的数据流。  
在上下文DFD中确定的外部实体以及与外部实体的输入输出数据流的基础上，将上下文DFD中的加工分解成多个加工，分别识别这些加工的输入数据流以及经过加工变换后的输出数据流，建模0层DFD。根据0层DFD中加工的复杂程度进一步建模加工的内容。  
在建模分层DFD时，根据需求情况可以将数据存储建模在不同层次的DFD中。建模时，需要注意加工和数据流的使用原则，一个加工必须既有输入又有输出；数据流须和加工相关，即数据流至少有一头为加工。注意要在绘制下层数据流图时保持父图与子图之间的平衡，即：父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流并集。  
本题题下描述清晰，易于分析，分析题目中所描述的内容，完成对应题目。  
本题考查上下文DFD，要求确定外部实体。在上下文DFD中，待开发系统名称“医疗管理系统”作为唯一加工的名称，外部实体为这一加工提供输入数据流或者接收其输出数据流。通过考查系统的主要功能发现，系统中涉及客广、医生、主管。根据描述（1） 中“客户提交通用信息查询请求”，描述（2）中“医生提出应聘/辞职申请，交由主管进行聘用/解聘审批”、描述（3）中“医生安排出诊时间”、描述（5）中“根据主管提交的报表查询请求”和“生成报表返回给主管”等信息，对照图1-1中E1、E2和E3相关的数据流，即可确定E1为“客户”实体，E2为“医生”实体，E3为“主管”实体。  
  
【问题2】  
D1：通用信息  
D2：预约数据  
D3：医生  
D4：医生出诊时间  
D5：药品  
(注：名称后面可以带有“文件”或“表”）  
  
本题要求确定图1-2 0层数据流图中的数据存储。重点分析说明中与数据存储有关的描述。说明（1）中“查询通用信息表”，可知加工“通用信息查询”需要从存储D1 中根据相关检索条件查询相关通用信息，由此可知D1为“通用信息”。说明（2）中“更新医生表……删除解聘医生的出诊安排”，可知加工“医生聘用”需要向D3更新医生列表，由此可知D3为“医生”。说明（3）中“存入医生出诊时间表”、“查询在职医生及其出诊时间等预约所需数据并返回”、“在预约表中新增预约记录”,可知加工“预约处理”向存储“医生出诊时间”新增出诊时间，向“预约数据”中新增预约，从“医生”表中查询在职医生相关信息。再对应图1-2中这几个数据存储所关联的数据流名称，可知D2为“预约数据”，D4为“医生出诊时间”。说明（4）中“根据药品名称从药品数据中査  
询相关药品库存信息，开出药品，更新对应药品的库存……”，可知D5为“药品”。  
  
【问题3】  
![80b48eb4ffe040d6978d5dffc0d7464d.jpg][]  
  
本题要求补充缺失的数据流及其起点和终点。对照图1-1和图1-2的输入、输出数据流，并未缺少外部实体和加工之间的数据流。再考查题干中的说明判定图1-2中是否缺失内部的数据流，不难发现图中缺失的数据流，具体分析如下。  
根据说明（2）中“更新所约医生出诊时间并给医生发送预约通知”可知加工预约处理（P3)发给D4 (医生出诊时间）的“更新的出诊时间”；根据说明（2）中“删除解聘医生的出诊安排”可知医生聘用（P2)向存储D4提交“删除的医生出诊安排”；根据说明（4）中“根据药品名称从药品数据中查询相关药品库存信息”可知药品管理（P4) 从D5 (药品）获取“药品库存信息”，并“更新对应药品的库存以及预约表中的治疗信息”，可知从P4向D2 (预约数据）中更新“治疗信息”。  
预约处理分解为：安排出诊时间、预约查询、创建预约、预约反馈。  
图1-1 (或父图）中某加工的输入输出数据流必须与图1-2 (或子图）的输入输出数据流在数量和名字上相同；图1-1 (或父图）中的一个输入（或输出）数据流对应于图1-2 (或子图）中几个输入（或输出）数据流，而图1-2 (或子图）中组成这些数据流的数据项全体正好是父图中的这一条数据流。  
  
【问题4】  
在自顶向下建模分层DFD时，根据功能的粒度，可以进一步进行分解。在图1-2所示的0层数据流中，“预约处理”对应于说明（3），从中分析出需要执行的加工，进行分解，可以分为4个主要子加工—安排出诊时间、预约查询、创建预约、预约反馈。自顶向下进行建模时，需要保持数据流平衡，具体为父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流并集。  


## 第2题 ##

【问题1】  
![7c202bc1a8d548e997bcbfaa52c402df.jpg][]  
本题考査数据库概念结构设计及向逻辑结构转换的应用。  
此类题目要求考生认真阅读题目，根据题目的需求描述，给出实体间的联系。  
根据题意由“采购完的商品交由配送员根据顾客订单组合装箱，然后交给托运公司运送。托运公司按顾客订单核对商品名称和数量，然后按顾客的地址进行运送”可知配送员、托运公司和订单三方参与运送联系，三方之间为\*:\*:\*联系。  
  
【问题2】  
(a) 顾客编号，商品条码  
(b) 订单ID，商品条码  
  
根据需求描述（3）可知顾客信息包含收货地址，所以在顾客关系里应该包括“收货地址”。  
根据需求描述（2）和（6）可知顾客关系和商品关系是\*:\*联系，订单应该包含顾客所购商品的条码和数量，所以需要在订单关系模式中包含“商品数量”。  
根据需求描述（6）可知“根据顾客的订单在超市采购对应商品”，所以在代购关系里应该包括“商品条码”。  
  
【问题3】  
![423e5e762ee04336a7231c0d5223cd29.jpg][]  
关系模式：运送(运送ID, 配送员工号，托运公司编号，订单ID，顾客地址，发运时间）或者说明：增加属性“顾客地扯”  
  
根据题意由“允许顾客在系统中保存多组收货地址”，可知增加的“顾客地址”弱实体与顾客关系构成\*:1联系。另外，增加了顾客地址后，运送的时候要选择顾客地址，所以运送关系模式中应增加“顾客地址”。配送员、托运公司、订单和顾客地址之间构成\*:\*:\*:\*联系。  


## 第3题 ##

【问题1】  
A1: Driver  
A2: Central system  
A3: Traffic advice center  
A4: Regional center  
  
本题主要考查面向对象分析与设计的基本概念及应用。在建模方面，本题涉及了UML的用例图和类图，考査的模式是根据需求说明将模型补充完整。题目难度不大，属于经典考题。  
这两个问题都是针对图3-1所示的用例图，分别补充图中缺失的参与者和用例。  
在UML用例图中，参与者（actor)表示要与本系统发生交互的一个角色单元（人或其他系统）。用例（usecase)表示由本系统提供的一个业务功能单元。题目中已经给出了用例列表，可以根据这些用例在需求描述中寻找相关的参与者。  
表3-1中给出了5个用例。经过简单的分析，可以把这5个用例分成三类：①Create transaction、Underpaid transaction、Record Illegal use。这三个用例都跟通行收费相关，这也暗示着这个用例之间必定是有关联关系的；②Charge card,这个用例与通行收费有 着间接关联，因为磁卡中记录了驾驶员账户的信用记录；③Record traffic event,这是个独立于收费的用例。所以可以把用例“记录交通事件”作为解题的突破点。  
对于“Record traffic event”用例，说明中的第（5）条：“区域系统会获取不停车收费设备所记录的交通事件(Traffic events)；交通广播电台(Traffic advice center)根据这些交通事件进行路况分析并播报路况。”由此可以看出，在这个用例中，区域系统做的是写操作记读交通事件；交通广播电台（Traffic advice center)做的是读操作一路况分析。所以区域系统、交通广播电台这个用例的两个参与者。同时，也可以跟3-1所示的用例图对号入座了。从图中可以看出A3、A4和U4组成了一个相对独立的子用列图。根据前文的分析，可以确定U4对应的就是用例“Record traffic event”，A3和A4分别对应着参与者“区域系统”和“交通广播电台”。  
“Charge card“”用例，说明中的第（3）条：“车载器中的磁卡可以使用邮局的付款机进行充值”。虽然这里没有明确的说明充值的主语，但是磁卡的拥有者是驾驶员，因此可以推断出，用例“磁卡充值”的参句者就是驾驶员。现在可以与用例图进行对应，根据前文分析可以看出，U5对应着“Charge card”。另外充值信息会传送至中心系统，所以“charge card”用例还有另外一个参与者，就是中心系统。  
现在4个参与者已i经全部识别出来：驾驶员、中心系统、区域系统和交通广播电台。区域系统和交通广播电台已经对应A3和A4。目前需要确定的是A1和A2以及U1-U3的对应关系。  
  
【问题2】  
U1：Underpaid transaction  
U2：Record Illegal use  
U3：Create transaction  
U4：Record traffic event  
U5：Charge card  
其中U1、U2可以互换，用例名称必须为英文，因为表中的汉字是对用例的说明。  
  
从图3-1中可以看出，U3和U1、U2之间是extend (扩展关系）。扩展关系是对基础用例的扩展，基础用例是一个完整的用例，即使没有扩展用例的参与，也可以完成一个完整的功能。基础用例提供了一组扩展点，在这些新的扩展点中可以添加新的行为，而扩展用例提供了一组片段，这些片段能够被插入到基本用例的扩展点上。一般情况下，基础用例的执行不会涉及扩展用例，只有扩展点被激活时，扩展用例才会执行。因此扩展关系通常用来描述事件流的异常或者可选事件。用例“Create transaction"、“Underpaid transaction"和“Record Illegal use”中，“Underpaid transaction"和“Record Illegal use”是正常事件流中的特殊情况，可以作为扩展用例。这样就可以确定出，U3对应着用例“Create transaction”U1 和U2 分别对应着用例Underpaid transaction"和“Record Illegal use”A1和A2分别对应着参与者驾驶员和中心系统。  
  
【问题3】  
C1：Center system  
C2：Toll gantry   
C3：Traffic lanes  
C4：Radar sensor  
C5：Radio transceiver  
C6：Digital Camera  
其中C4、C5、C6可以互换。  
  
本问题要求将图3-2中的类补充完成。解答此类题目时应先观察和分析类图，特别要注意类图中出现的一些特殊关系，如继承、聚集、组装等，以及关系的多重度。在图3-2中出现了多个组装关系。组装表达的是一种“部分-整体”关系，在使用组装关系时，区分清楚哪个类代表整体，哪个类代表部分。由图3-2可见，C2和C3的聚集关系的多重度为“6”。在说明中“龙门架下包括6条车道（Traffic lanes)”，也就是说这6条车道是龙门架的一个组成部分，所以可以初步推断C2对应着龙门架（Toll gantry)、C3对应着车道（Traffic lanes)。再看说明中：“每条车道上安装有雷达传感器（Radar sensor), 无线传输器（Radio transceiver)和数码相机（Digital Camera)等用于不停车收费的设备”，即雷达传感器（Radar sensor)、无线传输器（Radio transceiver)和数码相机（Digital Camera) 与车道之间构成了“部分-整体”关系，符合图中C3与C4与C6之间的关系。由此可以完全确定C3为车道（Traffic lanes)。C4与C6分别对应着雷达传感器（Radar sensor)、无线传输器（Radio transceiver)和数码相机（Digital Camera)。  
最后来确定C1，由与C1有关联关系的类“Regional Center”可以得出，C1应该对应着Central system。根据在补充用例图时对需求的深入分析，也可以确定这一点：Central system和Regional Cente共同完成通行收费的行为。  


## 第4题 ##

【问题1】  
(1)：i&lt;=n  或其等效形式  
(2)：i&lt;=j   或其等效形式  
(3)：temp&gt;=p\[i\]+r\[j-i\])?temp:p\[i\]+r\[j-i\] 或其等效形式  
(4)：r\[j\]=temp  
  
本题考查算法设计与分析技术的基础知识和应用能力。  
解答该类题目，首先需要理解问题和求解问题的算法思想，一般在题干中已经清晰地描述了算法的基本思想。  
钢条切割问题是一个最优化问题。求解的思路非常简单，考虑最优方案中最左边的切割，此时将一个大问题转化为一个小问题。题干已经给出了最关键的递归式。C程序根据递归式，给出自顶向下和自底向上两种实现方法。  
在自顶向下的实现中，直接用递归方法实现递归式，因此空（1）填“i&lt;=n”。  
在自底向上的实现中，采用迭代方法实现递归式，这里采用了两重循环。外重循环j表示问题的规模，内重循环计算规模为j的钢条切割的最优解的值，因此空（2）填“i&lt;=j”。空（3）其实就是算法的核心，判断当前的最优解对应的价值temp大，还是当前的i对应的最优解的价值p\[i\]+r\[j - i\]更大，如果temp小，则更换当前最优解对应的价值。因此，空（3）填入  
if(temp&lt;p\[i\]+r\[j-i\])\{  
temp=p\[i\]+r\[j-i\]  
\}  
也可以参考自顶向下的实现方法中的语句“r= (r&gt;= tmp) ? r: tmp?，答案为temp &gt;= p\[i\] + r\[j-i\]?temp:p\[i\] + r\[j-i\]。  
对某个j计算得到其最优解之后，将其存到r\[j\]中，即空（4）填“r\[j\]=temp”。  
  
【问题2】  
(5) 动态规划法  
(6) O(2n)  
(7) O(n2)  
  
根据题干说明和C程序，应该比较清晰看出算法是基于动态规划策略设计的。在自顶向下的实现中，因为是递归实现，可以列出递归式如下  
![00563c3866094845bc049fa3781fe567.jpg][]  
求解该式子，得到时间复杂度为O(2n)。那么高的时间复杂度主要是因为相同的子问题会多次重复的被调用。另外，若不会求解该式子，可以画出递归树求解。  
而在自底向上的实现方法中，采用了两重循环，因此算法的时间复杂度为O(n2)。  


## 第5题 ##

【问题1】  
(1) virtual void buildPartA()=0  
(2) virtual Product \* getResult()=0  
(3) product-&gt;setPartA  
(4) product-&gt;setPartB  
(5) builder-&gt;buildPartA() 或builder-&gt;buildPartB();  
  
本题考查设计模式中生成器（Builder)模式的基本概念和实现。  
生成器模式是一种典型的创建型模式。创建型模式抽象了实例化过程，它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。  
在这些模式中有两个不断出现的主旋律。第一，它们都将关于该系统使用哪些具体的类的信息封装起来。第二，它们隐藏了这些类的实例是如何被创建和放在一起的。整个系统关于这些对象所知道的是由抽象类所定义的接口。因此，创建型模式在什么被创建，谁创建它，它是怎样被创建的，以及何时创建这些方面给予了很大的灵活性。它们允许用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的（即在编译时指定），也可以是动态的（在运行时）。  
生成器模式的意图是，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的标识。生成器模式的结构如图5-2所示。  
![348b23f1a2d04f9ab5d0b90901d26780.jpg][]  
其中：  
Builder为创建一个Product对象的各个部件制定抽象接口。  
ConcreteBuilder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口。  
Director构造一个使用Builder接口的对象。  
Product表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成组件的类，包括将这些组件装配成最终产品的接口。  
生成器模式适用于：当创建复杂对象的算法应该独立与该对象的组成部分以及它们的装配方式时：当构造过程必须允许被构造的对象有不同的表示时。  
图5-1中的类Product包含两个组成部分：partA和partB，因此在类Builder中需要为这两个组成部分创建抽象接口。在C++中，抽象接口通常采用纯虚拟函数来实现。纯虚拟函数是没有实现体的虚拟函数，它在基类中定义，在派生类中重置。构造partB的接口在代码中已经给出，因此第（1）空应填写“virtual void buildPartA() = 0”。  
第（2）空的内容可以从Builder的派生类ConcreteBuilder1来进行推断，在ConcreteBuilder1中出现了方法getResult，根据上下文，可以判定该方法可能继承自其基类Builder，并在派生类中重置。因此第（2）空填写“virtual Product \* getResult() = 0”。  
第(3)、(4)空用于创建产品的内部表示。Product包含两部分partA和partB，分别调用类Product中提供的方法setPartA和setPartB来实现。因此(3)、(4)空分别填入“product-&gt;setPartA ” 和“product-&gt;setPartB”。  
第(5)空是对Bulider中接口的使用，这里应填入“builder-&gt;buildPartA()”或“builder-&gt;buildPartB()”。  


## 第6题 ##

【问题1】  
(1) void buildPartA()  
(2) Product\*getResult()  
(3) product.setPartA  
(4) product.setPartB  
(5) builder.buildPartA()或builder.buildPartB();  
  
本题考查设计模式中生成器（Builder)模式的基本概念和实现。  
生成器模式是一种典型的创建型模式。创建型模式抽象了实例化过程，它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。  
在这些模式中有两个不断出现的主旋律。第一，它们都将关于该系统使用哪些具体的类的信息封装起来；第二，它们隐藏了这些类的实例是如何被创建和放在一起的。对于整个系统来说，这些对象是由抽象类所定义的接口。因此，创建型模式在什么被创建，谁创建它，它是怎样被创建的，以及何时创建这些方面给予了很大的灵活性。它们允许用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的（即在编译时指定），也可以是动态的（在运行时）。  
生成器模式的意图是，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的标识。生成器模式的结构如图6-2所示。  
![47f22f5a8525450682af1ba6902e3559.jpg][]  
其中：  
Builder为创建一-个Product对象的各个部件指定抽象接口。  
ConcreteBuilder实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供-个检索产品的接口。  
Director构造个使用Builder接口的对象。  
Product表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口。  
生成器模式适用于：当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时；当构造过程必须允许被构造的对象有不同的表示时。  
图5-1中的类Product包含两个了两个组成部分：partA和partB，因此在类Builder中需要为这两个组成部分创建抽象接口。这里使用了Java中的Interface来实现。构造partB的接口在代码中已经给出，因此第（1）空应填写“ void buildPartA()”。  
第（2）空的内容可以从类ConcreteBuilder 1来进行推断。在ConcreteBuilder 1中出现了方法getResult，该类实现了Builder中定义的接口。根据上下文，可以判定该方法也应该是Builder中定义的接口。因此第（2）空应填写“Product\*getResult()”。  
第（3）、(4)空用于创建产品的内部表示。Product包含两部分partA和partB，分别调用类Product中提供的方法setPartA和setPartB来实现。因此（3）、(4)空分别填入“product.setPartA”和“product.setPartB”。  
第(5)空是对Bulider中接口的使用，这里应填入“builder.buildPartA() ”或“Builder.buildPartB() ”。  



[80b48eb4ffe040d6978d5dffc0d7464d.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/80b48eb4ffe040d6978d5dffc0d7464d.jpg
[7c202bc1a8d548e997bcbfaa52c402df.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/7c202bc1a8d548e997bcbfaa52c402df.jpg
[423e5e762ee04336a7231c0d5223cd29.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/423e5e762ee04336a7231c0d5223cd29.jpg
[00563c3866094845bc049fa3781fe567.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/00563c3866094845bc049fa3781fe567.jpg
[348b23f1a2d04f9ab5d0b90901d26780.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/348b23f1a2d04f9ab5d0b90901d26780.jpg
[47f22f5a8525450682af1ba6902e3559.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/47f22f5a8525450682af1ba6902e3559.jpg
