---  
title: 2012年上半年  
# icon: gears  
order: 994  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1：借阅者  
E2: 图书管理员  
E3/E4: 学生数据库/职工数据库  
注：E3和E4不分顺序，但必须不同。  
本题考查顶层DFD。顶层DFD—般用来确定系统边界，将待开发系统看作一个加工，图中只有唯一的一个处理和一些外部实体，以及这两者之间的输入输出数据流。题目要求根据描述确定图中的外部实体。分析题目中描述，并结合已经在顶层数据流图中给出的数据流进行分析。从题目的说明中可以看出：和系统的交互者包括图书管理员、借阅者两类人，图书管理员需要维护图书信息、得到查询所得的图书信息，借阅者提供借阅者ID、借阅与归还的图书。还有通过与教务处维护的学生数据库、人事处维护的职工数据库中的数据进行比对以验证借阅者ID是否合法的两个数据库作为外部实体。  
对应图1-1中数据流和实体的对应关系，可知E1为借阅者，E2为图书管理员，E3 和E4为学生数据库和职工数据库。  
  
【问题2】  
D1：图书表  
D2: 借出图书表  
D3: 逾期未还图书表  
D4: 罚金表  
本题考查0层DFD中数据存储的确定。说明中描述维护图书信息主要存储或者更新图书表；借阅时需要检查逾期未还图书表，确定是否有逾期未还图书以及罚金表中的罚金限额，归还时出现缺失和损坏需要处以罚金并存入罚金表；借阅与归还图书时需要存入借出图书表和更新借出图书表。在处理逾期时需要将罚金记入罚金表，要检査和更新罚金限额。根据描述和图1-2中的数据存储的输入输出数据流提示，可知D1为图书表，D2为借出图书表，D3为逾期未还图书表，D4为罚金表。  
  
【问题3】  
检查借阅者身份或检查借阅者ID；检查逾期未还图书；检查罚金是否超过限额；借阅图书；归还图书。  
本题考查将0层DFD中的处理进一步精化建模，绘制下层数据流图。从说明中对“处理借阅”的描述和图1-2可知，处理借阅需要检查借阅者身份、检查逾期未还图书、检查罚金是否超过限额、借阅图书和归还图书。描述中：检查所还图书是否逾期，若是，执行“处理逾期”操作。这里处理逾期明确说明是一个操作，而且在描述（3）中单独描述，图1-2中已经建模为单独一个处理，所以在本问题中仍然不分解。  
  
【问题4】  
保持父图与子图平衡。父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名字上相同。如果父图的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一个数据流，那么它们仍然算是平衡的。  
本题考查在绘制下层数据流图时需要注意的问题。问题3明确给出是对复杂处理进行进一步精化，绘制下层数据流图，因此需要注意的问题是绘制下层数据流图时要保持父图与子图平衡。父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名字上相同。如果父图的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一个数据流，那么它们仍然算是平衡的。  


## 第2题 ##

【问题1】  
![2d5860e49a4e4f839c3ac57167642c11.jpg][]  
本题考查数据库的概念结构设计，题目要求补充完整实体联系图中的联系和联系的类型。  
根据题目的需求描述可知，一名病人在一次住院期间对应一张病床，而一个病床可以有多名病人曾经住过。所以，病床实体和病人实体之间存在“住院”联系，联系的类 型为多对一，表示为\*:1。  
根据题目的需求描述可知，一名病人在一次住院期间，由一名医生做出诊断，并给出一份诊断书。所以，病人实体和医生实体之间存在“诊断”联系，联系的类型为多对多，表示为\*:\*:\*。  
根据题目的需求描述可知，一名病人在一次住院期间可以进行多次手术，一次手术安排在一个手术室，由多名医生参与。所以，病人实体与医生实体和手术室实体三者之间'存在“手术”联系，三者之间联系的类型为多对多对多，表示为根据题目的需求描述可知，一名手术室护士负责多个手术室，每个手术室由多名护士负责。所以，护士实体和手术室实体之间存在“负责”联系，联系的类型为多对多，表示为\*:\*。  
  
【问题2】  
1：病区，护士号。2：手术室号，护士号，责任。3：病案号，病床号。4：病案号，医生编号。5：病案号，手术室号，手术时间，医生编号。  
本题考查数据库的逻辑结构设计，题目要求补充完整各关系模式，并给出各关系模式的主键。  
根据实体联系图和需求描述，每个病床护士负责护理一个病区内的所有病人，每个病区由多名护士负责护理。系统记录每个病床护士所负责护理的病区。所以，对于“病 床护士”关系模式需填写的属性为：病区，护士号。  
根据实体联系图和需求描述，每个手术室护士负责多个手术室，每个手术室由多名 护士负责，每个护士在手术室中有不同的责任。因此，对于“手术室护士”关系模式，需填写的属性为：手术室号，护士号，责任。  
根据实体联系图和需求描述，病案号唯一标识病人本次住院的信息。病人的住院信息包括病床信息。所以，对于“病人”关系模式需补充的属性为：病案号，病床号。  
根据实体联系图和需求描述，一名病人在一次住院期间，由一名医生做出诊断，并给出一份诊断书。所以，对于“诊断”关系模式需补充的属性为：病案号，医生编号。  
根据实体联系图和需求描述，一名病人在一次住院期间，可能需要进行一次或多次手术，每次手术安排在一间手术室，由多名医生(包括主刀医生)参与。所以，对于“手术医生安排”关系模式需补充的属性为：病案号，手术室号，手术时间，医生编号。  
病床护士关系模式的主键：病区，护士号  
手术室护士关系模式的主键：手术室号，护士号  
病人关系模式的主键：病案号  
诊断书关系模式的主键：病案号  
采购订单关系模式的主键：订单编码  
手术医生安排关系模式的主键：病案号，手术室号，手术时间，医生编号码  
  
【问题3】  
![9f09db56cc46407b9365d3191156591b.jpg][]  
本题考查数据库的概念结构设计，根据新增的需求新增实体联系图中的实体及联系和联系的类型。  
根据问题描述，系统需记录医生给病人开处方的药品信息，则需新增“药品”实体，并在病人实体与医生实体和药品实体三者之间存在“处方”联系，联系的类型是多对多对多(\*:\*:\*)。  


## 第3题 ##

【问题1】  
A1：顾客 A2: 订单处理人员 A3: 派送人员 U1：收货 U2: 派单  
本题要求将图3-1所给出的用例图补充完整。用例图的构成要素有参与者（Actor)、用例（Use Case)以及用例之间的关系。由图3-1可知，题目中“网上购物平台”的用例模型中共有3个参与者、7个用例。图中给出了其中的5个用例，需要补充所缺少的两个用例和三个参与者。解答此题时，应首先确定参与者，然后再找到与每个参与者对应的用例。  
参与者表示要与本系统发生交互的一个角色单元。与系统交互的外部人员、角色、其他的计算机系统、物理实体等通常都可以看作是参与者。从“说明”中可以看出，在本题的描述中出现了 “顾客”、“订单处理人员”、“派送人员”这三种角色。而用例图中恰好缺少了三个参与者，所以可以确定这三种角色就应该与A1~A3对应。接下来要确定的就是它们之间的对应关系，这就需要明确参与者与用例之间的关系了。解答时可以依据用例图逐个考查其中的参与者。  
先从A1开始。A1参与的用例分别为“创建订单”、“收货确认”以及需要补充的用例U1。用例总是由参与者启动的。以“创建订单”、“收货确认”为关键词，在“说明” 中查找出现这两个关键词的语句的主语。这个主语就是该用例的参与者。由“说明”可见，A1应该表示的是“顾客”。采用同样的方法，可以确定A2表示“订单处理人员”，A3表示“派送人员”。  
由于缺少的用例U1和U2与参与者A1和A3相关，因此重点考查“说明”中出现了 “顾客”和“派送人员”的语句。比对“说明”和用例图可知，功能“派单”、“收货”没有出现在用例图中。“订单处理人员”和“派送人员”都参与了“派单”功能，所以U2处应该是用例“派单”。而“收货”功能涉及了三种角色：派送人员、顾客（两者完成货物的交接)、订单处理人员（收回顾客签字后的运货单，此时一次完整的收货活动才算结束)，所以U1处应该是“收货”。  
  
【问题2】  
Cl：Customer C2：Order C3：Product  
  
![3274c9b4ef4b421e9407880f747bf566.jpg][]  
本题考查的是类图建模。解题的重点在于根据类图中提供的类、类的属性以及类之 间的关联关系推断出需要补充的类。  
先看类Cl，C1的关键属性都已经给出了。由“说明”可知，属性address表示的是“收货地址”。而收货地址的最初始来源是顾客，所以类C1代表的应该是Customer(顾客)。  
另外，从“说明”中可知，“订单”和“商品”是“网上购物平台”系统的关键概念，所以应该在类图上有相应的类来表示。由此可以推断出，C2和C3就应该与这两个概念相关。观察类图，在C2和C3之间存在着一个关联类Order Product,而C3和C2 之间又存在着一个聚集关系，C3是构成C2的部分对象。根据“说明”，订单中包含了订购的商品，所以C2应该是Order (订单)，C3应该是Product (商品）。  
三个类都确定之后，下面来识别它们之间的多重度。  
首先顾客（C1)和订单（C2)之间的关联，一名顾客可以在线创建多个订单，但是一个订单只能由一名顾客来创建。所以（1）处应填写“1”，(2)处应填写“0..n”。  
订单（C2)和商品（C3)，一个订单上可以订购多件商品，而一件商品可以出现在一个或多个订单中，也可能没有任何顾客订购某种商品。因此C2和C3之间是一种多对多联系。在图3-2中，采用了关联类的方法来表示多对多联系。这里（3）处应填写“0..n”，  
(4)处应填写“l..n”。这里下限1表示一个订单中至少应包含一件商品。  
  
【问题3】  
C2：volume、delivery date、form of payment  
C3: cubic volume、cost price、sale price  
本题考查类的关键属性的识别。由“说明”中给出的描述可知，类C2的属性至少应包括 volume、delivery date、form of payment；类C3的属性至少应包括 cubic volume、cost price、sale price。  


## 第4题 ##

【问题1】  
![6e5649b9c51f4288b63fd39340d21b55.jpg][]  
schedule函数计算p数组中元素的值。第一个三重for循环进行p数组的初始化，当k = 0 时，p\[i\]\[j\]\[k\] = 1;而当 k关0 时，p\[i\]\[j\]\[k\] = 0,因此(1)处应填 “p\[x\]\[y\]\[0\] = 1 ”。  
在接下来的三重for循环中，自底向上计算p\[i\]\[j\]M的值，计算根据题中定义来进行，（2）处应填 “p\[x\]\[y\]\[k\]=p\[x-a\[k-l\]\]\[y\]\[k-l\]”。对应于上一行的条件，(3)处应填“y- b\[k—1\]&gt;=0”。  
write函数中，已经计算出p数组元素的值，因此此时每一个p\[i\]\[j\]\[n\] = 1表示一个可行解，因次（4）处应填“p\[x\]\[y\]\[n\] = l”或等价的表达式。其中该解对应的处理时间为 i和j中的较大值，因此(5)处应填“(x&gt;=y)?x:y”。在所有的可行解中，确定最小的处理时间即为问题的最优解。  
  
【问题2】  
![7d20158b894f4164a0fe769dacad4f2f.jpg][]  
根据上述C代码，函数schedule有两处三重for循环，时间复杂度为O(m2n)。函数 write有一处两重for循环，时间复杂度为O(m2)。因此整个算法的时间复杂度为O(m2n + m2),由于m2在数量级上小于m2n,因此算法的时间复杂度可以表示为O(m2n)。  
  
【问题3】  
(7)(1,1,2,2,1,1)  
(8)15  
根据题意和算法，可以得到若作业1、2、5和6在处理机A，而作业3和4在处理 机B上处理，可以得到最优解。此时在处理机A上的处理时间为14,而在处理机B上的处理时间为15,因此最优解的值，即最短的处理时间为15,而最优解为（1,1,2,2,1,1)。  


## 第5题 ##

【问题1】  
1.protected  
2.virtual string getDescription  
3.virtual int cost() = 0  
4.Beverage\* beverage  
5.beverage  
6.beverage  
本题考查装饰器（Decorator)模式的概念及应用。  
Decorator模式动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式提供了比继承更有弹性的替代方案。  
Decorator模式的优点是有效避免了使用继承方式扩展对象功能而带来的灵活性差、子类无限制扩展的问题；装饰者与被装饰者之间虽然都是同一类型，但是它们彼此是完全独立并可以独立任意改变的。  
Decorator模式的适用场合是：想透明并且动态地给对象增加新的职责；给对象增加的职责，在未来存在增加或减少的可能。  
Decorator模式的类图如下所示：  
![a1efda5e07af4e0e9b31f48c3627e339.jpg][]  
题目利用Decorator模式来计算各种配料组合的咖啡的价格。Beverage相当于抽象的Component类，最终要计算出Beverage的价钱。Espresso和DarkRoast是4个具体的组件，代表一种咖啡类型。Macha和Whip是配料装饰者，可以添加到不同类型的咖啡中。CondimentDecorator相当于Decorator,是装饰者共同实现的接口。在本题中，确定装饰者共同实现的接口是什么，是一个重要的考查点。  
下面来分析程序。  
第（1）空要求给出类Beverage的数据成员description的访问控制。C++语言提供了3种访问控制private、public和protected。private成员只能在定义它的类中或其友元访问；public成员可以被任意访问；protected成员只能在定义它的类及其子类中访问。从程序上下文可知，在Beverage的子类Espresso和DarkRoast中都需要访问description, 所以第（1）空应填“protected”。  
第（2）、(3)空要求确定Beverage中提供的公共接口。解答时应全面阅读程序，通过子类的代码来推断父类所提供的接U是什么。  
首先来观察Beverage的两个子类。在Espresso和DarkRoat中都出现的成员函数是cost,其功能是给出咖啡的价格；而在这两个类中，cost的实现代码又不相同。这就提示我们这里采用了 C++语言的动态多态机制，意味着需要在这两个类的父类中定义一个虚拟函数，其函数原型就应该是intcostO。现在回到第（2）、(3)空。第（2）空给出了成员函数的实现体，说明（2）处的成员函数是与description相关的。也就是说，第（2） 空处的成员函数不可能是cost。这样就可以确定第（3）空应该是cost成员函数。仔细观察第（3）空，这条语句的结束符是“；”，即第（3）空中只能出现函数的接口声明。只有接口声明的虚函数，在C++中只能是纯虚拟函数。所以第（3）空应填写“virtualint cost() = 0”。  
如何来确定第（2）空？在类Espresso和DarkRoast中已经找不到相关信息了，我们考查剩余的类。  
类CondimentDecorator是Beverage的子类，那么第（2）和（3）空处的成员函数都会被它继承。而类Mocha和Whip又是CondimentDecorator的子类，第（2）和（3）空处的成员函数同样也会被这两个类继承。观察Mocha和Whip的代码，可以发现在这两个子类中也重置了纯虚拟函数cost。除此之外还可以发现，在这两个子类中都出现了成员函数string getDescription()，并且其在两个类中的实现代码也不相同。这说明，getDescription也应该是父类中所定义的虚拟函数。从子类沿着继承路径追袖到父类，可以确定第（2）空就应该是虚拟函数getDescription最初的定义之处。所以第（2）空应填写 “virtual string getDescription”。  
第（4）空考查的是类CondimentDecorator中定义的数据成员，要求确定其类型和名称。由于声明成了 protected,因此在其子类Mocha和Whip中可以找到答案。在这两个类中都出现了 “this-&gt;beverage”表达式，说明beverage应该是该类的数据成员。但在这两个类中都没有定义数据成员，很显然，这个数据成员应该是从父类继承而来的。所以第（4）空应填 “Beverage\* beverage”。  
第（5）和（6）空考查的是Decorator模式的使用方法。从主函数可知，其基本过程是现制作一杯烘焙咖啡（DarkRoast),然后再向这杯咖啡中加入1份Mocha和1份 Whip,最后这杯咖啡的价格应该是烘焙咖啡的价格+1份Mocha的价格+1份Whip的价格。（5）和（6）处都应该填写“beverage”。  


## 第6题 ##

【问题1】  
1.abstract  
2.String getDescription  
3.abstract int cost()  
4.Beverage beverage  
5.beverage  
6.beverage  
本题考查装饰器（Decorator)模式的概念及应用。  
Decorator模式动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式提供了比继承更有弹性的替代方案。  
Decorator模式的优点是有效避免了使用继承方式扩展对象功能而带来的灵活性差、子类无限制扩展的问题；装饰者与被装饰者之间虽然都是同一类型，但是它们彼此是完全独立并可以独立任意改变的。  
Decorator模式的适用场合是：想透明并且动态地给对象增加新的职责；给对象增加的职责，在未来存在增加或减少的可能。  
Decorator模式的类图如下所示：  
题目利用Decorator模式来计算各种配料组合的咖啡的价格。Beverage相当于抽象的 Component类，最终要计算出Beverage的价钱。Espresso和DarkRoast是4个具体的组件，代k一种咖啡类型。Macha和Whip是配料装饰者，可以添加到不同类型的咖啡中。  
CondimentDecorator相当于Decorator,是装饰者共同实现的接口。在本题中，确定装饰者共同实现的接口是什么，是一个重要的考查点。  
![bd00a792358f4fad9b853f25943a27ba.jpg][]  
下面来分析程序。  
Decorator模式中的Component通常都用抽象类来实现。所以第（1）空应填写 “abstract”。  
第（2）、(3)空要求确定Beverage中提供的公共接口。解答时应全面阅读程序，通过子类的代码来推断父类所提供的接口是什么。  
首先来观察Beverage的两个子类。在Espresso和DarkRoat中都出现的成员函数是cost,其功能是给出咖啡的价格；而在这两个类中，cost的实现代码又不相同。这意味着需要在这两个类的父类中定义一个抽象函数，其函数原型就应该是int cost()。现在回到第(2)、（3）空。第(2)空给出了成员函数的实现体，说明(2)处的成员函数是与description 相关的。也就是说，第（2）空处的成员函数不可能是cost。这样就可以确定第（3）空应该是cost成员函数。所以第（3）空应填写“abstract int cost()’’。  
如何来确定第（2）空？在类Espresso和DarkRoast中已经找不到相关信息了，我们考査剩余的类。  
类CondimentDecorator是Beverage的子类，那么第（2）和（3）空处的成员函数都会被它继承。而类Mocha和Whip又是CondimentDecorator的子类，第（2）和（3）空处的成员函数同样也会被这两个类继承。观察Mocha和Whip的代码，可以发现在这两个子类中也重置了抽象函数cost。除此之外还可以发现，在这两个子类中都出现了成员函数String getDescriptionO。从子类沿着继承路径追溯到父类，可以确定第（2）空就应 该是成员函数getDescription最初的定义之处。所以第（2）空应填写“ String getDescription’’。  



[2d5860e49a4e4f839c3ac57167642c11.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/2d5860e49a4e4f839c3ac57167642c11.jpg
[9f09db56cc46407b9365d3191156591b.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/9f09db56cc46407b9365d3191156591b.jpg
[3274c9b4ef4b421e9407880f747bf566.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第3题/3274c9b4ef4b421e9407880f747bf566.jpg
[6e5649b9c51f4288b63fd39340d21b55.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/6e5649b9c51f4288b63fd39340d21b55.jpg
[7d20158b894f4164a0fe769dacad4f2f.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/7d20158b894f4164a0fe769dacad4f2f.jpg
[a1efda5e07af4e0e9b31f48c3627e339.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/a1efda5e07af4e0e9b31f48c3627e339.jpg
[bd00a792358f4fad9b853f25943a27ba.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/bd00a792358f4fad9b853f25943a27ba.jpg
