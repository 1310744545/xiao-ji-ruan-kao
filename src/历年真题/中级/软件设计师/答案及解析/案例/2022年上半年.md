---  
title: 2022年上半年  
# icon: gears  
order: 975  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1：商户  
E2：外卖平台  
E3：用户  
E4：支付系统  
  
【问题2】  
D1：用户/商户信息  
D2：订餐订单信息  
D3：餐品信息  
D4：评价信息  
  
【问题3】  
![9fb798dbfd2845d58953c22d2e7cba57.jpg][]  
  
【问题4】  
收到订餐请求后，向外卖平台请求配送;  
外卖平台接到请求后发布配送单，由平台骑手接单;  
外卖平台根据是否有骑手接单返回接单状态;  
IF(外卖平台接单成功)THEN\{  
系统给支付系统发送支付请求，接收支付状态;  
IF(支付成功)THEN\{  
更新订单状态为已接单;  
向商户发送订餐请求并由商户打印订单;  
给用户发送订单状态;  
\}ELSE\{  
更新订单状态为下单失败;  
向外卖平台请求取消配送;  
向用户发送下单失败;\}  
ENDIF\}  
ELSE IF(系统接到外卖平台返回接单失败或超时未返回接单状态)THEN\{  
更新订单状态为下单失败;  
向用户发送下单失败;\}ENDIF  
\}ENDIF  
\}ENDIF  


## 第2题 ##

【问题1】  
![447d8cc63291421c81cffde87810ece6.jpg][]  
  
【问题2】  
（a）医院名称  
（b）接种时间  
![91c78d4ab052444aa61a2c8074426e20.jpg][]  
  
【问题3】  
![393cf2c3f9a84d59bafa843c75ef11c4.jpg][]  
新增关系模式  
被检测者（身份证号，姓名，地址，电话）  
检测（被检测者身份证号，医院名称，检测日期，检测结果）  


## 第3题 ##

【问题1】  
U1：按姓氏字典顺序排序；  
U2：按邮政编码排序 U1和U2可互换  
U3:创建地址簿;  
U4:修改地址簿;  
U5:打开地址簿;  
U6:保存地址簿。  
  
【问题2】  
类PersonAddress的主要屋性包括:姓名、住址、城市、省份、邮政编码以及联系电话等。  
类AddressBook的主要屋性包括:部门名/编号，姓名、住址、城市、省份、邮政编码以及联系电话等。类AddressBook的需要包括创建地址簿、打开地址簿、修改地址簿。综上，类AddressBook的方法包括:添加、修改、删除、创建、打开、打印、排序等。  
  
【问题3】  
extend属于用例图的三种关系之一，表示的是扩展关系。  
描述为:如果—个用例明显地混合了两种或两种以上的不同场景，即根据情况可能会发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，关系图示指向为扩展用例指向基本用例。  
如图所示，创建和打开就是一对扩展关系，创建成功之后可以直接保存关闭之后，如果想要进行后续修改工作，就需要打开地址簿，由扩展用例指向基本用例。include属于用例图的三种关系之一，表示的是包含关系。  
描述为:当可以从两个或两个以上用例中提取公共行为的时候，应该使用包含关系来表示它们。其中这个提取出来的公共用例称之为抽象用例，而把原始用例称为基本用例和基础用例。  
如图所示:创建、修改和保存就是一对包含关系，在创建和修改它们都有公共的行为保存，提取出来称之为抽象用例,用包含关系表示它们。  


## 第4题 ##

【问题1】  
（1） j=i+p  
（2） k （3） cost\[i\]\[k\]+cost\[k+1\]\[j\]+seq\[i\]\*seq\[k+1\]\*seq\[j+1\]  
（4） trace\[i\]\[j\] = tempTrace  
  
  
【问题2】  
（5）动态规划算法  
（6）O(n3)  
  
【问题3】  
（7）A1\*((A2\*A3)\*A4)  
（8）5375  


## 第5题 ##

【问题1】  
(1) new Memento(state);  
(2) Memento-&gt;getState();  
(3) add(Memento \* state)  
(4) Memento \* get(int index)  
(5) originator-&gt;saveStateToMemento()  
(6) originator-&gt;saveStateToMemento()  
  


## 第6题 ##

【问题1】  
(1) new Memento(state)  
(2) Memento.getState()  
(3) void add(Memento state)  
(4) Memento get(int index)  
(5) careTaker.add(originator.saveStateToMemento()  
(6) careTaker.add(originator.saveStateToMemento()  



[9fb798dbfd2845d58953c22d2e7cba57.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/补充/9fb798dbfd2845d58953c22d2e7cba57.jpg
[447d8cc63291421c81cffde87810ece6.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/补充/447d8cc63291421c81cffde87810ece6.jpg
[91c78d4ab052444aa61a2c8074426e20.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/补充/91c78d4ab052444aa61a2c8074426e20.jpg
[393cf2c3f9a84d59bafa843c75ef11c4.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/综合知识/补充/393cf2c3f9a84d59bafa843c75ef11c4.jpg
