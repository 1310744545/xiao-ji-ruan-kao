---  
title: 2011年下半年  
# icon: gears  
order: 995  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1为应聘者，E2为部门经理，E3为工资系统  
本问题考査顶层DFD。顶层DFD一般用来确定系统边界，将待开发系统看作一个加工，因此图中只有唯一的一个处理和一些外部实体，以及这两者之间的输入输出数据流。外部实体可以是使用系统的用户，也可以是为系统提供输入或接收系统输出的外部系统。本问题要求根据描述确定图中的外部实体。应仔细分析题目中描述;并结合己经在顶层数据流图中给出的数据流进行分析。从题目的说明中可以看出，与系统的交互者包括应聘者、部门经理和工资系统。分析说明中的描述可知，应聘者提供自身信息，并接收系统验证合格后的致谢信息等。部门经理设置职位要求。对录用者而言，将其录用职位和信息发送给工资系统。对应图1-1中数据流和实体的对应关系，可知E1为应聘者，E2为部门经理，E3为工资系统。  
  
【问题2】  
D1为未录用的应聘者表，D2为评价结果表。  
本问题考查DFD中数据存储的确定。本题中涉及的数据存储只有2个，一个是存储未被录用的应聘者信息，即未录用的应聘者表：另一个是存储对录用的应聘者进行职位安排评价的评价结果，即评价结果表。可以确定图1-2中D1和D2为未录用的应聘者表和评价结果表，因为有一个处理与这两个数据存储相关，需要再对应图1-3,可确认D1为未录用的应聘者表，D2为评价结果表。  
  
【问题3】  
P1为验证信息;  
P2为审查申请;  
P3为职位安排评价。  
本问题考查1层DFD中缺失的处理。从说明（1）中接受申请的描述功能，需先对应聘者信息进行验证，受理验证合格的申请，可知缺失的处理P1为验证信息。说明（2）中，根据职位要求，审查已经受理的申请，对录用者进行职位安排评价，可知缺失的处理P2为审查申请，P3为职位安排评价。  
  
【问题4】  
不平衡。图1-2中加工的输入输出流与其子图1-3中的输入输出流的数量不同。  
![21baaa799eae4e3f8f52538a84880d23.jpg][]  
  
本问题考查绘制分层DFD时的注意事项。在分层DFD中，需要保持父图与子图的平衡。即父图中某加工的输入输出数据流必须与其子图的输入输出数据流在数量和名字上相同，或者父图的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一个数据流。  
本题中，图1-2中加工的输入输出流与其子图1-3中的输入输出流的数量不同。也无需将父图中一条数据流分解成子图中多条数据流，因此，补充子图中缺失的输入或输出数据流：录用职位、已受理的申请、谢绝决策。  


## 第2题 ##

【问题1】  
![372973d4ceed4cdeb91a5cc1eacb8ad7.jpg][]  
两个实体集之间的联系类型分为三类：一对一 (1：1)联系、一对多（1：n)联系 和多对多（m：n)联系。  
根据题意，每名员工只能在一个部门工作，所以部门和员工之间有一个1：n的“所属”联系；由于每个部门有一名经理，只需负责管理本部门的事务和人员，因此部门和经理之间有一个1 : 1的“管理”联系；由于一个业务员可以安排多个托运申请，但一个托运申请只由一个业务员处理，故业务员和托运申请之间有一个1 ：n的“托运”联系； 又由于一个客户可以有多个货物托运申请，但一个托运申请对应唯一的一个客户号，故客户和托运申请之间有一个1：n的“申请”联系。  
  
【问题2】  
![8ece03d13fc245e79acbefa6b315ce5e.jpg][]  
根据题意，部门和员工之间有一个1 : n的“所属”联系需要将一端的码并入多端，故员工关系模式中的空（a）应填写部门号；在客户关系模式中，客户号为主键，故空（b） 应填写客户号；在托运申请关系模式中；申请号、客户号为主键，故空（c）应填写申请号、客户号；又由于一个业务员可以安排多个托运申请，但一个托运申请只由一个业务员处理，因此在安排承运关系模式中，申请号为主键，故空（d）应填写申请号。  
部门关系模式中的部门号为主键，经理为外键；因为经理来自员工关系。员工关系模式中的员工号为主键，部门号为外键，因为部门号来自部门关系。安排承运关系模式中的申请号为主键，业务员为外键，因为业务员来自员工关系。  
  
【问题3】  
![513caf2dae1f44219c157f86add76201.jpg][]  
根据题意，权限的设置人是部门经理，因此，需要建立一个权限关系模式，以及经理到权限之间的1 : n的“设置”联系。  


## 第3题 ##

【问题1】  
U1：使用常规卡行驶  
U2：使用单次卡行驶   
（1）：extend  
  
本问题要求将图3-1所给出的用例图补充完整。用例图的构成要素有：参与者、用例以及用例之间的关系。图中缺少了两个用例，以及一个用例关系。解答此题时，首先应从说明中找到所有的用例。  
用例表示系统的一个单一业务功能。从题目的描述中可以看出，系统的主要功能就是申请行驶卡，以及使用行驶卡行驶。由于行驶卡分为三种，所以在说明中详细描述了三种行驶卡的使用方法。再结合用例图来看，缺少的两个用例与用例“使用季卡行驶”有关联关系，由此可以推断出，需要补充的这两个用例必定与另两种行驶卡相关，分别为“使用常规卡行驶”和“使用单次卡行驶”。  
下面需要解决的问题是这两个用例与U1和U2的对应关系。这就需要仔细考查一下用例图所给出的用例关系。由图3-1可知，U1和“使用季卡行驶”之间是泛化 (generalization)关系。当多个用例共同拥有一种类似的结构和行为时，可以将它们的共性抽象为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。根据说明中的“季卡的使用流程与常规卡类似，但是不需要打印费用单，系统自动从卡中扣除应付费用”可知，U1应该对应着用例“使用常规卡行驶”。由此不难得出U2对应着用例“用单次卡行驶”。  
现在图中只剩下(1)处的用例关系没有确定。用例之间的关系在用例图上只有三种：包含(include)、扩展(extend)和泛化(generalization)。  
包含关系是指当多个用例中存在相同事件流时，可以把这些公共事件流抽象成为公共用例，这个公共用例称为抽象用例，而原始用例称为基础用例。基础用例和抽象用例之间是包含关系。  
如果一个用例明显地混合了两种或两种以上的不同场景，则可以将这个用例分为一个基本用例和多个扩展用例。扩展关系用"《extend》"表示，箭头指向基本用例。  
包含关系和扩展关系的区别在于，抽象用例中的事件流一定要插入到基本用例中去，并且插入点只有一个，通常抽象用例不能脱离基本用例而独立存在。扩展用例的事件流往往可以抽象为基本用例的备选事件流，在扩展关系中，可以根据一定的条件来决定是否将扩展用例的事件流插入到基本用例的事件流中，并且插入点可以有多个。  
根据以上分析可知，（1）处的用例关系选择“《extend》”最为合适。  
  
【问题2】  
C1： RoadSegment  
C2： Trajectory  
C3： Card  
C4： RegularCard  
C5： PrepaidCard  
C6： MinitripCard  
（2）1  
（3）1..3  
  
本问题考查的是类图建模。解题的重点在于根据类图中提供的类及类之间的关联关系，推断出剩余的类。  
可以先观察一下类图。可以看到，需要补充的类基本上集中在两个结构上：聚集结构（类C1和C2）以及继承结构（类C3~C6）。继承结构是比较容易辨识的类之间的关联关系，图上给出了其中的一个子类SeasonCard。以这个类为线索，回到说明中寻找与类SeasonCard相关的其他类。从说明中可知，“系统提供了3种卡”，常规卡、季卡、单次卡，而“季卡和单次卡都是预付卡”。这些描述暗示，“季卡”、“单次卡”与“预付卡” 之间存在着特殊/一般关系，即“is-a”关系，这是继承结构的典型标志。由此可以得出类C5和C6应该分别对应PrepaidCard (预付卡）和MinitripCard (单次卡）。根据C5和C6所对应的类，可以推断出，C4和C3必定也是与行驶卡相关的类。三种卡中，已经有两种卡有了对应的类，还剩下一种卡即“常规卡”。而“常规卡”只能是与“预付卡” 同层次的概念，所以只能对应于C4, C3表示的是能代表所有这几种卡的公共概念。所 以C3和C4应分别对应于Card和RegularCard。确定了 C3之后，就可以识别出（2）和（3）处的多重度。Customer和Card之间是持有和被持有的关系，由于系统中只有3种卡，所以一个客户最多只能有3种卡，所以（3）处应填1..3。而对于任何一张卡来说，只能有唯一地一个所属人，因此（2）处应填1。  
现在还剩下类C1和C2没有确定。由于这两个类之间是聚集关系，所以需要在说明中寻找具有“部分-整体”关系的概念。由说明中的“行程（Trajectory)由一组连续的路段构成”可知，C1和C2应分别对应于RoadSegment和Trajectory。  
  
【问题3】  
RoadSegment 的属性：Distance  
rajectory 的属性：Entry、Exit、DateOfEntry  
Card 的属性：UnitPrice、ValidPeriod  
  
本问题考査类的关键属性的识别。由说明中给出的描述可知，类RoadSegment的属性至少应包括Distance;类Trajectory的属性至少应包括Entry、Exit和DateOfEntry;类Card的属性至少应包括UnitPrice、ValidPeriod。  


## 第4题 ##

【问题1】  
(1) bestX\[j\] = x\[j\]  
(2) j &lt;m  
(3) x\[i\] = j  
(4) cw&lt;bestW  
(5) cp = cp-c\[i\]\[j\]  
  
本题考查算法的设计和分析技术中的回溯法。  
回溯法是一种系统搜索问题解的方法，在包含问题所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法在到达解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。若肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯；否则进入该子树，继续按深度优先的策略进行搜索。回溯法在求问题的最优解时，要回溯到根，且根结点的所有子树都已经被搜索遍才结束。  
根据上述思想和题干说明，对实例：部件数n = 3,厂商数m=3,具体的重量和价格 如表4-1所示  
。![e23ed697ec264ba3b585f2eb5928c931.jpg][]  
构造该实例的解空间树如图4-1所示。  
![b74d1f0d33594e1ebef389d2bac6d82e.jpg][]  
  
图4-1中结点编号表示生成该结点的顺序。边上的编号表示哪个部件选择哪个厂商， 如x(2)=1，表示第2个部件来自厂商1。结点旁边的两个数字表示当前解或部分解对应的重量和价格，如2: 2表示重量为2，价格为2。从图4-1可以看出，最优解是结点20 表示的解，即x(1)=1, x(2)=3, x(3)=1,即第1个部件来自厂商1，第2个部件来自厂商 3,第3个部件来自厂商1,总的价格和重量分别为4和4。当然，本实例的最优解还可 以是 x(1)=1，x(2)=3, x(3)=2 和 x(1)=1, x(2)=3, x(3)=3,分别对应解空间树上的21号和22号结点。  
代码中的空(1)处是得到问题解之后，将搜索过程中产生的重量cw、价格cp和解x放到最终重量bestw、价格bestc和解bestX中，因此空格(1)处填写bestX\[j\] = x\[j\]。空(2)处的for循环是考虑第i个部件选择哪个厂商，因此j从0到m-1依次检查，此处应填j&lt;m。对搜索过程中产生的重量cw、价格cp和解x的值进行设置，因此空(3) 处应填x\[i\]=j，表示第i个部件选择厂商j。空(4)是判断当前结点是否要扩展，若当前获得的价格比目前最优解更优，且重量没有超过当前得到的最优重量，即cp&lt;=cc且 cw&lt;bestw,则扩展当前结点，否则回溯。在回溯过程中，需要把原来选择的部件的价格和重量从搜索过程中产生的重量cw和价格cp中去掉,因此空(5)应填cp = cp - c\[i\]\[j\]。  


## 第5题 ##

【问题1】  
(1)State  
(2)tissueMachine-&gt;getHasQuarterState()  
(3)tissueMachine-&gt;getNoQuarterState()  
(4)tissueMachine-&gt;getNoQuarterState()  
(5)tissueMachine-&gt;getSoldOutState()  
  
本题考查状态（State)模式的概念及应用。  
状态模式是一种对象的行为型模式，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式的类图如下所示：  
![0636796873474553a2f25c58d72d6d10.jpg][]  
状态模式主要解决的是控制一个对象转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。  
题目利用状态模式来实现一个简易的纸巾售卖机。售卖机的状态转换图己经在题目中给出，类SoldState、SoldOutState、NoQuarterState 和HasQuarterState 分别用来表示售卖机的4种不同状态，对应于状态模式中的ConcreteState1，...ConcreteStateN。题目所设置的填空，主要集中在状态转换上。因此解答该题时，要求在理解状态模式内涵的基础上，依据纸巾售卖机的状态转换原则，给出正确的状态设置。  
空(1)出现在类TissueMachine的数据成员定义部分。状态模式封装了状态的转换过程，但是它需要枚举可能的状态，因此需要确定状态种类。因此在类TissueMachine中需定义出所有可能的状态对象。根据所给出的对象名称及说明中的描述，可知(1)处应填入的类名为State。  
空(2)~(5)都是与状态转换相关的，要求填写类TissueMachine中的方法setState 在不同调用处的实际参数。根据方法的名称及调用方式，可以推断出这个方法的功能就是设置自动售卖机的当前状态。要填出这些空，只要对照图5-1的状态转换图，根据状态转换的条件确定出当前状态及下一状态即可。  
空(2)出现在方法insertQuarter内，即给纸巾售卖机投入2元钱。根据状态图，“投入2元钱”之后，售卖机应转换到“有2元钱”的状态。“有2元钱”对应的状态的类为"HasQuarterState”，所以空(2)处应填类HasQuarterState 的对象。由于hasQuarterState是类TissueMachine的私有数据成员，不能直接访问，所以只能通过调用相关的get方法来获取该对象。由此得出(2)应填 tissueMachine-&gt;getHasQuarterState()。  
同理，空(3)表示的状态是从“有2元钱”状态，经历“退回2元钱”事件之后的状态，及“没有投币”状态。所以空(3)处应填tissueMachine-&gt;getNoQuarterStat()。  
空(4)和(5)处分别表示卖出一包纸巾之后，售卖机应该转换到的下一个状态。 这个跟售卖机中的纸巾数有关，如果还有纸巾，则转换到“没有投币”状态，如果没有纸巾了，则转换到“纸巾售完”状态，因此，空(4)处应填tisSUeMachine-&gt;getNoQuarterState(),空(5)处应填 tissueMachine-&gt;getSoldOutState()。  


## 第6题 ##

【问题1】  
(1)State  
(2)tissueMachine.getHasQuarterStat()  
(3)tissueMachine.getNoQuarterState()  
(4)tissueMachine.getNoQuarterState()  
(5)tissueMachine.getSoldOutState()  
本题考查状态(State)模式的概念及应用。  
状态模式是一种对象的行为型模式，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式的类图如下所示：  
![80a3bb427a064cb8ade02f861d1fa54b.jpg][]　　  
状态模式主要解决的是控制一个对象转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。  
题目利用状态模式来实现一个简易的纸巾售卖机。售卖机的状态转换图已经在题目中给出，类SoldState、SoldOutState、NoQuarterState 和 HasQuarterState 分别用来表示售卖机的4种不同状态，对应于状态模式中的ConcreteState1，...ConcreteStateN。题目所  
设置的填空，主要集中在状态转换上。因此解答该题时，要求在理解状态模式内涵的基础上，依据纸巾售卖机的状态转换原则，给出正确的状态设置。  
空(1)出现在类TissueMachine的数据成员定义部分。状态模式封装了状态的转换过程，但是它需要枚举可能的状态，因此需要实现确定状态种类。因此在类TissueMachine 中需定义出所有可能的状态对象。根据所给出的对象名称及说明中的描述，可知(1)处 应填入的类名为State。  
空(2)~(5)要求填写类TissueMachine中的方法setState在不同调用处的实际参数。这里的一个难点在于题目中没有显示地给出方法setState的原型及语义，这要求考生根据面向对象程序设计风格及说明中给出的应用场合来推断setState的内涵及原型，主要是确定其参数列表。  
在面向对象程序设计中，为了做到封装，通常都会把数据成员定义为私有的。私有的数据成员对象不能直接访问，因此在类中都会提供2组访问私有数据成员的方法，分别为get...方法和set...方法（…代表对应的数据成员名称）。get...方法表示获取私有数据成员的值，其返回值类型为对应的数据成员的类型；set...方法表示对数据成员进行赋值，所要赋的值通常通过参数传递进去，方法的返回值类型通常为void。根据面向对象 程序设计的这些特点，以及状态模式的内涵及应用场合，可以推断出setState方法的功能就是设置纸巾售卖机的当前状态。纸巾售卖机在任一时刻只能处于一个唯一的状态， 由状态模式可知，纸巾售卖机的状态都是用状态对象表示的，由此就可以确定出，setState 方法的参数只要一个就可以了，就是表示纸巾售卖机下一状态的状态对象。  
经过以上分析之后，可以明确空(2)~(5)空所填的内容都应与状态转换相关。因此要填充这些空，只要对照图5-1的状态转换图，根据状态转换的条件确定出当前状态及下一状态即可。  
空(2)出现在方法insertQuarter内，即给纸巾售卖机投入2元钱。根据状态图，“投入2元钱”之后，售卖机应转换到“有2元钱”的状态。“有2元钱”对应的状态的类为“HasQuarterState”，所以空(2)处应填写类HasQuarterState的对象。由此得出（2）应填 tissueMachine.getHasQuarterState()。  
同理，空（3）表示的状态是从“有2元钱”状态，经历“退回2元钱”事件之后 的状态，及“没有投币”状态。所以空（3）处应填tissueMachine.getNoQuarterState()。  
空（4）和（5）处分别表示卖出一包纸巾之后，售卖机应该转换到的下一个状态。 这个跟售卖机中的纸巾数有关，如果还有纸巾，则转换到“没有投币”状态，如果没有纸巾了，则转换到“纸巾售完”状态，因此，空(4)处应填tissueMachine.getNoQuarterState()，空（5）处应填tissueMachine.getSoldOutState()。  



[21baaa799eae4e3f8f52538a84880d23.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/21baaa799eae4e3f8f52538a84880d23.jpg
[372973d4ceed4cdeb91a5cc1eacb8ad7.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/372973d4ceed4cdeb91a5cc1eacb8ad7.jpg
[8ece03d13fc245e79acbefa6b315ce5e.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/8ece03d13fc245e79acbefa6b315ce5e.jpg
[513caf2dae1f44219c157f86add76201.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/513caf2dae1f44219c157f86add76201.jpg
[e23ed697ec264ba3b585f2eb5928c931.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/e23ed697ec264ba3b585f2eb5928c931.jpg
[b74d1f0d33594e1ebef389d2bac6d82e.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第4题/b74d1f0d33594e1ebef389d2bac6d82e.jpg
[0636796873474553a2f25c58d72d6d10.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/0636796873474553a2f25c58d72d6d10.jpg
[80a3bb427a064cb8ade02f861d1fa54b.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/80a3bb427a064cb8ade02f861d1fa54b.jpg
