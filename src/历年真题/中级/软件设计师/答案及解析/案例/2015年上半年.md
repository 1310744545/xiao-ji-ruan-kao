---  
title: 2015年上半年  
# icon: gears  
order: 988  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
E1：教师；  
E2：学生。  
  
解析：本题考查采用结构化方法进行系统分析与设计，主要考查数据流图（DFD)的应用， 是比较传统的题目，与往年考点类似，要求考生细心分析题目中所描述的内容。  
DFD是一种便于用户理解、分析系统数据流程的图形化建模工具，是系统逻辑模型的重要组成部分\\上下文DFD (顶层DFD)通常用来确定系统边界，将待开发系统本身看作一个大的加工（处理)，然后根据谁为系统提供数据流，谁使用系统提供的数据流， 来确定外部实体。建模出的上下文DFD中只有唯一的一个加工和一些外部实体，以及这两者之间的输入输出数据流,。在上下文确定的系统外部实体以及与外部实体的输入输出数据流的基础上，建模0层DFD，将上下文DFD中的加工进一步分解成多个加工， 识别这些加工的输入输出数据流，使得所有上下文DFD中的输入数据流，经过这些加工之后变换成上下文DFD的输出数据流。根据0层DFD中加工的复杂程度进一步建模加工的内容。  
在建模分层DFD时，根据需求情况可以将数据存储建模在不同层次的DFD中，注意要在绘制下层数据流图时要保持父图与子图平衡。父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名字上相同，或者父图中的一个输入（或输出） 数据流对应于子图中几个输入（或输出）数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一个数据流。  
本问题考査上下文DFD,要求确定外部实体。考察系统的主要功能，不难发现，针对系统与考试有关的主要功能，涉及到教师和学生，系统管理员不在与考试有关的主要功能中涉及，另外没有提到其他与系统交互的外部实体。根据描述（1）中“教师制定试 题等考试信息”等信息，描述（2）中“根据教师设定的考试信息，在考试有效时间内向学生显示考试说明和题目”，从而即可确定E1为“教师”实体，E2为“学生”实体。  
  
【问题2】  
D1：试题（表）或题目和答案（表）  
D2：学生信息（表）  
D3：考试信息（表）  
D4：解答结果（表）  
  
解析：本问题要求确定0层数据流图中的数据存储。分析说明中和数据存储有关的描述， 说明中（1）中“教师制定试题（题目和答案)，制定考试说明、考试时间和提醒时间等考试信息，录入参加考试的学生信息，并分别进行存储”，可知D1、D2和D3为试题、 学生信息和考试信息，再从图1-2中流入D2的数据流名称“学生信息数据”，确定D2是学生信息，流入D1的数据流名称为“试题”，确定D1为试题，流入D3的数据流名称为考试信息，确定D3为考试信息。说明中（3）根据答案对接收到的解答数据进行处理，然后将解答结果进行存储，确定D4是解答结果。参考其他描述中对数据存储的使用更多说明，进一步确定D1~D4满足上述分析。  
  
【问题3】  
![62bbc0a671f0488f85e624737d257f49.jpg][]  
  
解析：本问题要求补充缺失的数据流及其起点和终点。通过不同层的DFD以及说明中描述和图之间的对应\#系加以确定。首先对照图1-1和图1-2的输入、输出数据流，发现数据流的数量和名称均相同，所以，需进一步考查说明中的功能描述和图1-1中的数据流的对应关系，以确定缺失的是加工之间还是加工与数据存储之间的数据流。  
说明（2）显示并接收解答，需要“根据教师设定的考试信息，在考试有效时间内向学生显示考试说明和题目”，对照图1-2可以看出，加工2缺少所要显示的题目的输入源，即缺失输入流“题目”，题目存储于数据存储“试题”中，因此，缺少的数据流为从题目（D1)到加工2显示并接收解答的题目。说明（3）处理解答，需要“根据答案对 接收到的解答数据进行处理”，对照图1-2可以看出，加工3“处理解答”缺少输入流“答案”，而从说明（1）中可以看出“答案”存储在试题（题目和答案）数据存储中（D1)， 因此确定缺失的一条数据流“答案”，从D1或试题到加工3或处理解答。  
  
【问题4】  
分解为加工：发送通知和加工：创建通知  
![0b09d08c0e854e0baf5ad498ea3e9ec5.jpg][]  
  
解析：  
本问题考查建模分层DFD时的分解粒度。在说明（6）发送通知中，“根据成绩报告数据，创建通知数据并将通知发送给学生;根据成绩单数据，创建通知数据并将通知发送给教师。”说明功能（6）发送通知包含创建通知并发送给学生或老师。在图1-2中建模为一个加工，完成的功能是依据不同的输入数据流创建通知，然后发送给相应的外部实体老师或学生,因此为了进一步清晰每个加工的职责，需对图1-2中原有加工6进 行分解，分解为“创建通知”和“发送通知”。创建通知针对输入数据流“报告数据”和 “成绩单数据”，这两条数据流保持原有的起点，终点即为创建通知。创建通知产生出“通知数据' “通知数据”作为加工“发送通知”的输入流，进一步根据通知数据是针对哪个外部实体而发送“通知”给相应的学生或者教师。至此，对图1-2中原有加工6的分解完成。  


## 第2题 ##

【问题1】  
![906e2e3ad76f4e9cb615420188edb470.jpg][]  
比赛联系应具有的属性包括：比赛编码，比分，日期。  
  
解析：本题考查数据库概念结构设计及向逻辑结构转换的掌握。  
此类题目要求考生认真阅读题目，根据题目的需求描述，给出实体间的联系。  
根据题意由“一名球员只能效力于一支球队”可知球队和球员之间为1:\*联系。由“一场比赛有两支球队参加，一支球队作为主队身份、另一支作为客队身份参与比赛”可知球队分别按照“主队”和“客队”两种角色参与“比赛”的联系。“比赛”应具有的属性：比赛编码，出分和日期。  
  
【问题2】  
（1）球队编号；  
（2）球队编号。  
  
解析：根据问题1分析可知球队和球员之间为1:\*联系，所以在球员关系里应该包括球队的主键，即“球队编号”。根据“每支球队有一名主教练，一名主教练只能受聘于一支球队”可知球队和教练之间为1:1联系，而球队关系已经给定，所以需要在主教练关系中包含球队的主键，即“球队编号”。  
  
【问题3】  
![43d9603f63e84118b5fef2bd01d16fc5.jpg][]  
  
解析：根据题意由“赞助商可以赞助某支球队，一支球队只能有一个赞助商，但赞助商可以赞助多支球队”可知赞助商和球队之间为1:\*联系。由“赞助商也可以单独赞助某些球员，一名球员可以为多个赞助商代言”可知赞助商和球员之间为联系。  


## 第3题 ##

【问题1】  
![7c14ab0c6e024232b9f7f29c87e55197.jpg][]  
  
解析：本题属于经典的考题，主要考查面向对象分析方法与设计的基本概念。在建模方面， 本题中只涉及到了UML类图。类图上的考点也是比较常规的对类的识别以及类中属性及方法的确定，题目难度不大。  
图3-1共需要确定7个类，可以先从图中几个特殊关系处入手，即（1）~(3)和(4)~(6)。  
先来分析(1)~(3),这是一个继承+聚集的结构，而且联系的名称“participants” 是一个比较明显的提示，说明这个层次结构是与【说明】中的功能描述（1）相对应的。 参考表3-1，与之相关的类是C5 (AuctionParticipant)、C7 (OneParticipant)和C9 (CompositeParticipant)。C7、C9是特殊的参与者，所以(1)处应该为C5; (2)处应该 为C9,这个聚集关系针对着【说明】中的“不同的团体也可以组成新的团体参与拍卖活动”需求；(3)处为C7。  
结合【说明】和表3-1,另外一组具有“一般-特殊”关系的类只有C6 (Interchange), C8 (OfflinePay)和C10 (OnlinePay)。显而易见，C8和C10是C6的两种具体方式, 所以（4）处应该为C6, (5)、(6)处分别为C8和C10。  
这样(7)处对应的类只能是Item了。结合【说明】和表3-1可知，(7)处对应的类表达的应该是拍卖中的拍卖品，所以(7)处应该是C2。  
  
【问题2】  
![fb2fedc09377459e8ece8970530104a7.jpg][]  
在图3-1中使用了Composite模式。  
以树形结构表示个人参与者和团体参与者之间的“部分-整体”关系，使得对单个对象和组合对象的使用具有一致性。  
  
【问题3】  
解析：在【说明】部分有一个很明显的提示：“拍卖参与者分为个人参与者和团体参与者两种。不同的团体也可以组成新的团体参与拍卖活动”。这里很清晰地表达了一种“部分-整体”的层次关系，这种关系非常适合于采用Composite （组合）设计模式来表达。  
Composite设计模式将对象组合成树形结构以表示“部分-整体”的层次结构。 Composite使得用户对单个对象和组合对象的使用具有一致性。  


## 第4题 ##

【问题1】  
（1）pos\[i\]==pos\[k\]或其等价形式  
（2）j=1  
（3）!isplace(pos,j)或其等价形式  
（4）j&lt;N或其等价形式  
（5）j=j-1或其等价形式  
  
解析：本题考查算法设计和C程序设计语言的相关知识。  
此类题目要求考生认真阅读题目，理解算法思想，并思考将算法思想转化为具体的程序设计语言的代码。  
根据题干描述。空（1）所在的代码行判断皇后合法放置的约束条件，即不在同一行，这通过把第i个皇后放在第i行实现，条件“fabs(i-k)==fabs(pos\[i\]-pos\[k\])”判断的是当前摆放的皇后是否与之前摆放的皇后在同一对角线上。因此，空（1）判断的是当 前摆放的皇后是否和之前摆放的皇后在同一列上，即应填入“pos\[i\]==pos\[k\]”。  
根据算法思想和主函数上下文，空（2）处应该考虑第1个皇后，即初始化j为1， 空（2）填写“j=1”。空（3）所在的行是判断放置第j个皇后的位置是否合适，“pos\[j\] &lt;=N”表示在该行的合法列上，但还需要进一步判断是否与前面的皇后有冲突，根据满足条件后的语句，尝试放入下一列，因此空（3）处填入“!isplace(pos，j)”。根据前面的注释，空（4）所在的行是考虑下一个皇后，其条件是，当前皇后找到了合适的位置，而且还存在下一个皇后，因此空（4）处应填入“j &lt; N”。根据下面的注释，若当前皇后没有找到合适的位置，则应回溯，即再次考虑上一个皇后的位置，因此空（5）处填入“j=j-1"。  
  
【问题2】  
（6）回溯法  
  
解析：从上述题干的叙述和C代码很容易看出，从第一个皇后开始，对每个皇后总是从第个位置开始尝试，找到可以放置的合法位置；若某个皇后在对应的行上没有合法位置， 则回溯到上一个皇后，尝试将上一个皇后放置另外的位置。这是典型的深度优先的系统搜索方式，即回溯法的思想。  
  
【问题3】  
（7）  
方案1：2 4 1 3；  
方案2：3 1 4 2。  


## 第5题 ##

【问题1】  
（1）virtual void accept(LibraryVisitor\*visitor)=0  
（2）virtual void visit(Book\* p\_book)=0  
（3）virtual void visit(Article\* p\_article)=0  
（4）visitor-&gt;visit(this)  
（5）visitor-&gt;visit(this)  
  
解析：本题考查Visitor (访问者）模式的基本概念和应用。  
访问者模式是行为设计模式中的一种。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻画了在运行时难以跟踪的复杂的控制流。  
访问者模式表示一个作用于某对象结构中的各元素的操作。它使在不改变各元素的类的前提下可以定义作用于这些元素的新操作。此模式的结构图如下图所示。  
![787ad448dda24da9943428363ea207b5.jpg][]  
Visitor(访问者）为该对象结构中ConcreteElement的每一个类声明一个Visit操作。该操作的名字和特征标识了发送Visit请求给该访问者的哪个类。这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。  
Concrete Visitor(具体访问者）实现每个有Visitor声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。   
Element (元素）定义以一个访问者为参数的Accept操作。  
ConcreteElement (具体元素）实现以一个访问者为参数的Accept操作。  
ObjectStructure (对象结构）能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合，如一个列表或一个无序集合。  
本题中类Library对应着上图中的Client，Library Visitor对应着Visitor，LibrarySumPrintVisitor对应着Concrete Visitor。Libraryltemlnterface对应着上图中的元素部分。下面可以结合程序代码来完成程序填空了。  
Libraryltemlnterface在本题中充当着Element的作用,其中应定义以一个访问者为参数的Accept操作。对照其两个子类Article和Book的代码，可以得知该操作的原型是void accept(LibraryVisitor\* visitor)。由于该操作的具体实现在子类Article和Book中，所以这里适用于采用C++中的纯虚拟函数来实现。由此可以得知，（1）处应填写“virtual void accept(LibraryVisitor\* visitor) = 0”。  
(2) 和（3）空与类LibraryVisitor有关。由前文分析已知，Library Visitor对应着访问者模式中的Visitor,其作用是为类LibrarySumPrintVisitor声明Visit操作。类LibrarySumPrintVisitor需要访问两种不同的元素，每种元素应该对应不同的visit操作。 再结合类LibrarySumPrintVisitor的定义部分，可以得知（2）和（3）处应给出分别以Book和Article为参数的visit方法，同样采用纯虚拟函数机制。因此(2)和（3）处分别为“virtual void visit(Book\* p\_book) = 0”、“virtual void visit(Article\* p\_article) = 0”。  
(4)和（5）处考查的是accept接口的实现。由访问者模式的结构图可以看出，在Book和Article中accept方法的实现均为visitor-&gt;visit(this)。  


## 第6题 ##

【问题1】  
（1）void visit(Book p\_book)  
（2）void visit(Article p\_article)  
（3）void accept(LibraryVisitor visitor)  
（4）visitor.visit(this)  
（5）visitor.visit(this)  
  
解析：本题考查Visitor (访问者）模式的基本概念和应用。  
访问者模式是行为设计模式中的一种。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻画了在运行时难以跟踪的复杂的控制流。   
访问者模式表示一个作用于某对象结构中的各元素的操作。它使在不改变各元素的 类的前提下可以定义作用于这些元素的新操作。此模式的结构图如下图所示。  
![ece27cbe731a41dca03476ac06292d4d.jpg][]  
Visitor (访问者）为该对象结构中ConcreteElement的每一个类声明一个Visit操作。该操作的名字和特征标识了发送Visit请求给该访问者的哪个类。这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。  
Concrete Visitor (具体访问者）实现每个有Visitor声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ComcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。  
Element (元素）定义以一个访问者为参数的Accept操作。  
ConcreteElement (具体元素）实现以一个访问者为参数的Accept操作。  
ObjectS-tructure (对象结构）能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合，如一个列表或一个无序集合。  
本题中类Library对应着上图中的Client，Library Visitor对应着Visitor，LibrarySumPrintVisitor对应着Concrete Visitor。Libraryltemlnterface对应着上图中的元素部分。下面可以结合程序代码来完成程序填空了。  
(1)和（2）空与类LibraryVisitor有关。由前文分析已知，LibraryVisitor对应着访问者模式中的Visitor，其作用是为类LibrarySumPrintVisitor声明Visit操作。类LibrarySumPrintVisitor需要访问2种不同的元素，每种元素应该对应不同的visit操作。 再结合类LibrarySumPrintVisitor的定义部分，可以得知（2）和（3）处应给出分别以Book和Article为参数的visit方法。因此（1）和(2)处分别为“void visit(Book p\_book)”、“void visit(Article p\_article)”。  
Libraryltemlnterface在本题中充当着Element的作用，其中应定义以一个访问者为参数的Accept操作。对照实现该接口的两个类Article和Book的代码，可以得知该操作的原型是void accept(LibraryVisitor visitor)。由此可以得知，(3 )处应填写“ void accept(LibraryVisitor visitor) ”。  
(4)和（5）处考查的是accept接口的实现。由访问者模式的结构图可以看出，在Book和Article中accept方法的实现均为visitor.visit(this)。  



[62bbc0a671f0488f85e624737d257f49.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/62bbc0a671f0488f85e624737d257f49.jpg
[0b09d08c0e854e0baf5ad498ea3e9ec5.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第1题/0b09d08c0e854e0baf5ad498ea3e9ec5.jpg
[906e2e3ad76f4e9cb615420188edb470.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/906e2e3ad76f4e9cb615420188edb470.jpg
[43d9603f63e84118b5fef2bd01d16fc5.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第2题/43d9603f63e84118b5fef2bd01d16fc5.jpg
[7c14ab0c6e024232b9f7f29c87e55197.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第3题/7c14ab0c6e024232b9f7f29c87e55197.jpg
[fb2fedc09377459e8ece8970530104a7.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第3题/fb2fedc09377459e8ece8970530104a7.jpg
[787ad448dda24da9943428363ea207b5.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第5题/787ad448dda24da9943428363ea207b5.jpg
[ece27cbe731a41dca03476ac06292d4d.jpg]: https://www.xkxxkx.cn/file/exam/software/软件设计师/案例/第6题/ece27cbe731a41dca03476ac06292d4d.jpg
