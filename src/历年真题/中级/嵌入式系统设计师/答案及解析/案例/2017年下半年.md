---  
title: 2017年下半年  
# icon: gears  
order: 992  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
(1) text段：存放程序代码。  
(2) data段：存放有初值的全局变量和常量。  
(3) bss段：存放未被初始化的全局变量。  
(4) bss段。  
  
本问题考查程序可执行程序基本结构和概念。  
程序经过编译后生成的目标文件至少含有三个段，分别是text段、data段和bss段。bss段(bss segment)通常是指用来存放程序中未初始化的全局变量的一块内存区域，在程序载入时由内核清零。bss段属于静态内存分配。  
data段（data segment)通常是指用来存放程序中已初始化的全局变量的一块内存区域，data段属于静态内存分配。  
text段（code segment/text segment)通常是指用来存放程序执行代码的一块内存区域，这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读（某些架构也允许代码段为可写，即允许修改程序)。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。  
在本题中数组arrMap被定义为无初值的全局变量，所以此数组位于bss段中。  
  
【问题2】  
(1) 可以  
(2) 不需要  
(3) 通过邮箱号间接寻址  
(4) 读/写  
(5) 无  
  
本问题考查RapidIO通讯的基本概念。  
RapidIO规范在2009年发布了2.1版本，向后兼容RapidIO 1.3o在2.1版本中采用了新的高性能物理层，除此之外还增强了数据平面的性能。针对并行传输方式提出了8/16并行LVDS协议，对串行方式提出了lx/4x两种模式。RapidIO协议的I/O操作是基于请求的，在结束时会有响应事务。  
上述串行模式下的RapidIO协议即SRIO通信协议，它构建了3层的协议体系如图1-3所示，分别是物理层、传输层、逻辑层。物理层定义了硬件接口的电器特性，并包括链路控制、初级流量控制和低级错误管理等功能；位于中间的传输层，负责进行寻址和路由信息管理；顶层的逻辑层定义了服务类型和包交换的格式。  
逻辑层定义了数据包的格式，同时支持两种操作方式，分别是直接IO/DMA(Direct IO/Direct Memory Access)方式和消息传递（Message Passing)方式。  
1)直接IO/DMA传输方式  
直接IO/DMA是一种常用的数据传输方式，但是发送端需要知道被访问设各的存储空间地址映射。在直接IO/DMA模式下，被访问端的操作基本由硬件实现。直接I0/DMA下，发起一次传输操作，需要有效数据、目标器件ID、数据长度、数据在被访问设备存储空间的地址以及包优先级等。同时，所有构成的包的长度为32bit的整数倍；若包长度不能满足要求，则添加附加位进行弥补。在直接\[0/DMA传输方式下包含以下几种传输类型：  
（1）NWRITE：可以直接向被访问器件的存储空间写数据。单次操作最多写入256字节数据，且不要求目标器件响应。  
（2）NWRITE R：与NWRITE基本相同，不同的是NWRITE\_R操作要求目标器件响应。  
NWRITE和NWRITE\_R这两种传输类型均属于Rapid协议中定义的第5类事务。  
（3）SWRITE：流写操作。在进行流写操作时数据大小要满足8字节的整数倍，且发送后不要求目的器件进行响应。同时SWRITE操作也是SRIO传输方式中效率最高的。其属于第6类事务，包的开销大大减小，提高了数据传输的效率。  
（4）NREAD：直接从目的器件相应的存储空间读取内容，一次操作可读取数据长度为1~256bit。NREAD属于SRIO协议中第2类事务。  
（5）Atomic：即原子操作，它不包含任何有效载荷。  
（6）Maintenance：即维护包，它的主要作用是器件发现、路由信息维护和交换器件初始化配置等。  
2）消息传递方式  
消息传递方式不要求发送节点知道目的节点的地址空间映射，当数据到达目的节点时，会根据邮箱号确定消息存储位置。在消息传递模式下进行数据传输时，除了有效载荷外还需要提供目的节点的ID、数据长度、包优先级和邮箱号等。除了用户自定义的传输类型外，消息传输方式定义了两种传输类型：  
（1）DOORBELL：门铃消息要求信息传输长度小于等于16bk，适合于处理器间的中断通知。门铃消息属于第10类事务。  
（2）MESSAGE：多事务消息的有效载荷最高可达4096字节，最多可包含16个事务，每个事务最大有效载荷为256字节，且要求有效载荷大小必须为双字的整数倍。MESSAGE是第11类事务。  
以上两种传输方式的差异  
SRIO逻辑层中直接IO/DMA模式和消息传递模式这两种传输方式的主要差异如表1-1所示。  
![a1892aa13d9f4eb0b52ed13f4838538b.jpg][]  
  
【问题3】  
(1) 识别中断源  
(2) 设置新的屏蔽字  
(3) 执行中断服务程序主体  
(4) 关中断  
  
本问题考查中断处理的基本知识。  
中断是指计算机系统运行时，出现来自处理机以外的任何现行程序不知道的事件，CPU暂停现行程序，转去处理这些事件，待处理完毕，再返回原来的程序继线执行，这个过程称为中断，这种控制方式称为中断控制方式。  
请求CPU中断的设备或事件称为中断源，根据中断源的不同类别，可以把中断分为内中断和外中断两种。中断的处理过程一般按如下步骤进行：  
关中断：进入不可再次响应中断的状态，由硬件自动实现；  
保存断点：为了在中断处理结束后能正确地返回到中断点，在响应中断时，必须把当前的程序计数器PC中的内容（即断点）保存起来；  
识别中断源，转向中断服务程序：在多个中断源同时请求中断的情况下，本次实际响应的只能是优先权最高的那个中断源，所以，需要进一步判断中断源，并转入相应的中断服务程序入口；  
保存现场和屏蔽字：进入中断服务程序后，首先要保存现场，现场信息一般指的是程序状态字，中断屏蔽寄存器和CPU中某些寄存器的内容。保存旧的屏蔽字是为了中断返回前恢复屏蔽字，设置新的屏蔽字是为了实现屏蔽字改变中断优先级或控制中断的产生；  
开中断：因为接下去就要执行中断服务程序，开中断将允许更高级中断请求得到响应，实现中断嵌套；  
执行中断服务程序主体：不同中断源的中断服务程序是不同的，实际有效的中断处理工作是在此程序段中实现的；  
关中断：是为了在恢复现场和屏蔽字时不被中断打断；  
恢复现场和屏蔽字：将现场和屏蔽字恢复到进入中断前的状态；  
中断返回：中断返回是用一条IRET指令实现的，它完成恢复断点的功能，从而返回到原程序执行。  
进入中断时执行的关中断、保存断点操作和识别中断源是由硬件实现的，它类似于一条指令，但它与一般的指令不同，不能被编写在程序中。  


## 第2题 ##

【问题1】  
(1)~(4)：A、D、E、G  
  
本问题考查串行总线RS232和RS485的基础知识。  
RS232是现在主流的串行通信接口之一，支持全双工通信，但只允许一对一通信。RS232典型的连接器包括DB9和DB25,仅使用三线也可进行基本通信。简单三线制连接即只连接发送数据线、接收数据线和信号地。在进行嵌入式开发时，常采用F.S232作为调试串口使用。在波特率不高于9600 bit/s的情况下进行串口通信时，RS232通信线路的长度通常要小于15米，否则可能出现数据丢失现象。  
RS485允许在相同传输线上连接多个接收节点，支持一点对多点的双向通信\\RS485可以采用二线与四线方式，常用的二线制可实现真正的一对多半双工通信。RS485采用差分传输方式，具有抑制共模干扰的能力，抗干扰能力强，传输距离可达千米a上。在通信距离为几十米至上千米时，通常采用RS485收发器。在进行嵌入式开发时，常采用RS485作为外设的控制总线来使用。  
  
【问题2】  
(1) 39.0625  
(2) 0x271  
  
本问题考査嵌入式系统设计时基本的寄存器配置。  
根据题干描述，波特率的计算公式为：  
![0c5fb29995434cf49da7a69d9a3a5a49.jpg][]  
已知给外设提供的时钟频率/ae72MHz, GSM/GPRS/GPS三合一模块所需的波特率 为115200，则USARTDIV的值应为：  
![d39e533d8c3d41419ff26cdbd8c69221.jpg][]  
根据图2-3和表2-1对寄存器USART\_BRR的功能描述，寄存器USART桞RR的4~15位对应USARTDIV的整数部分，寄存器USART一BRR的0~3位对应USARTDIV的小数部分。因此，在本题中，USARTDIV的整数部分为39,则寄存器USART\_\_BRR的4~15位的十六进制值应为0x27；USARTDIV的小数部分为0.0625(即1/16),则寄存器USART桞RR的0~3位的十六进制值应为0x1。综合上述分析，USARTDIV的值应为39.0625，USART BRR寄存器的十六进制值应为0x271。  
  
【问题3】  
(1) 64  
  
本问题考查RS485总线一对多通信机制的设计。  
根据题干，RS485总线使用特制的RS485芯片，最大支持节点数可达128个以上。但根据图2-2所示，TS-FTM01传感器地址采用6位拨码开关进行编码，这意味着TS-FTM01传感器的地址编码范围为0~63。在RS485通信机制中采用地址编码来区分不同的RS485设备。因此，尽管RS485总线上最大支持节点数可达128个以上，但TS-FTM01传感器最多只能编码64个地址，最终该系统的RS485总线上最多可L支持的TS-FTM01传感器的数目为64。  
  
【问题4】  
(1)D  
(2)B  
(3)F  
(4)(m)  
(5)(c)  
  
本问题考查考生对RS485总线机制的理解以及对硬件定时器的使用。  
RS485采用二线制进行半双工通信。本题要求用两根GPIO口线来模拟二线制的RS485总线，通过两根GPIO口线上的信号的高低来模拟RS485的差分信号，以便实现RS485信号的传输。本题在用两根GPIO口线模拟RS485总线方面并未全面考查RS485时序，只对RS485半双工通信概念进行考查。因此，在利用模拟的RS485总线进行数据发送时，总线处于写状态，因此要把这两根GPIO口线配置为输出模式；当处理器通过模拟的RS485总线实现了数据发送后，要立即把RS485总线的状态从写状态切换到读状态，以便接收传感器的应答信息，实现半双工通信。因此，此时应把这两根GPIO口线配置为输入模式。对应图2-4所示的软件流程中，在（1）处应把GPI045和（3PI046配置为输出模式，在（2）处应把GPI045和GPI046配置为输入模式。  
根据题干要求，需实现16个TS-FTM01传感器（地址编码为0~15)的温湿度数据读取。图2-4所示的软件流程中采用循环方式依次对每个传感器进行数据读取。根据软件流程，addr地址从0开始处理，因此循环结束的条件应为addr&gt;=16,即软件流程图中  
(3)处的答案应为addr&gt;=16。  
根据题干要求，需要周期性地进行温湿度数据的采集和上报，周期T由硬件定时器来实现。为了实现精确定时，需要在一次定时时刻到后立即触发下一个周期的定时开始。但图2-4所示的软件流程中是一次定时时刻到后，先进行16个传感器的数据读取，然后再触发下一个周期的定时开始，导致实际的采集间隔为预设的周期T加上读取16个传感器温湿度数据所需的时间。为了修正这个问题，需要在定时时间到后立即触发下一个定时周期，然后在进行温湿度数据的读取和上报。因此需要把步骤（m）中的重置定时器操作提到步骤（c）定时超时后立即执行j。因此本题中(4)和（5）处应填入(m)和（c）。  


## 第3题 ##

【问题1】  
在软件测试过程中，测试人员不仅需要熟悉一些基本的测试概念和测试方法，而且需要通过对软件设计和算法的理解，运用测试概念和方法进行基于需求的测试用例设计,不仅需要选择恰当的测试方法，而且需要保证测试用例的充分性。  
此题目要求考生认真阅读题目所给的软件需求和算法信息，结合嵌入式软件测试的基本概念和测试用例设计要求，在此嵌入式软件测试中进行实际应用。  
（1）软件源代码  
（2）黑盒  
  
在嵌入式软件测试过程中，一般采用的测试方法有白盒测试、黑盒测试和灰盒测试方法。  
白盒测试也称为结构测试、逻辑测试或基于程序源代码的测试，这种测试应了解程序的内部构造，并且根据内部构造设计测试用例。  
黑盒测试又称功能测试、数据驱动测试或基于规格说明的测试，这种测试不必了解被测对象的内部情况，而依靠需求规格说明中的功能来设计测试用例。  
灰盒测试是介于白盒测试与黑盒测试之间的一种测试方法，既关注输出对干输入的正确性，同时也关注代码的内部结构，但这种关注不像白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实己经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒测试方法。  
根据本问题的条件，给定的说明为功能说明，故应该采用黑盒测试方法。  
在软件测试过程中，测试人员不仅需要熟悉一些基本的测试概念和测试方法，而且需要通过对软件设计和算法的理解，运用测试概念和方法进行基于需求的测试用例设计,不仅需要选择恰当的测试方法，而且需要保证测试用例的充分性。  
此题目要求考生认真阅读题目所给的软件需求和算法信息，结合嵌入式软件测试的基本概念和测试用例设计要求，在此嵌入式软件测试中进行实际应用。  
  
【问题2】  
（1）1  
（2）2  
（3）3  
  
本问题主要考查对语句覆盖、条件覆盖和MC/DC覆盖概念的掌握以及应用。  
语句覆盖要求设计适当数量的测试用例，运行被测程序，使得程序中每一条语句至少被运行一遍，语句覆盖在测试中主要发现错误语句。  
分支覆盖要求设计适当数量的测试用例，运行被测程序，使得程序中每个真值分支和假值分支至少执行一次，分支覆盖也称判定覆盖。  
修正判定条件覆盖(MC/DC)要求设计适当数量的测试用例，保证在一个程序中每一种输入输出至少得出现一次，在程序中的每一个条件必须产生所有可能的输出结果至少一次，并且每个判断中的每个条件必须能够独立影响一个判断的输出，即在其他条件不变的前提下仅改变这个条件的值，而使判断结果改变。  
按照上述语句覆盖要求，语句覆盖就要使得问题2中的所有语句执行一次，问题2中只有一个语句块，故为了使问题2中的一个语句块执行一次，仅仅需要1个测试用例来覆盖。  
按照上述分支覆盖要求，分支覆盖要使得程序中每个真值分支和假值分支至少执行一次。对问题2中的判断条件进行分析，只有一个判断条件，取真值分支和假值分支即可满足，故最少需要两个测试用例来满足分支覆盖要求。  
按照上述MC/DC覆盖要求，即每个判断中的每个条件必须能够独立影响一个判断的输出。对问题2中的一个判断进行分析，此判断有两个条件，两个条件共有匹种组合，即TT(TRUE和TRUE)、TF(TRUE和FALSE)&gt;FT(FALSE和TRUE)和FF(FALSE和FALSE)。但是由于此判断为逻辑与条件，当前一个条件为FALSE时，其整个判断值为FALSE,后一个条件的真或假均不能独立影响整个判断的输岀，所以只需要TT、TF和FX(X表示后一个条件为TRUE或FALSE都可以)三种情况就可以，故此判断最少需要3个测试用例即可满足MC/DC覆盖要求。  
在软件测试过程中，测试人员不仅需要熟悉一些基本的测试概念和测试方法，而且需要通过对软件设计和算法的理解，运用测试概念和方法进行基于需求的测试用例设计,不仅需要选择恰当的测试方法，而且需要保证测试用例的充分性。  
此题目要求考生认真阅读题目所给的软件需求和算法信息，结合嵌入式软件测试的基本概念和测试用例设计要求，在此嵌入式软件测试中进行实际应用。  
  
【问题3】  
（1）BR  
（2）BL  
（3）BR  
（4）BL  
（5）BL  
（6）BL  
（7）BR  
（8）故障  
（9）特级故障  
  
为了测试某飞行器供油阀控制软件的功能，就要依据题目说明中对某飞行器供油阀控制软件的具体功能描述，进行测试用例的设计。此题考查测试用例的设计，不仅包括输入数据的设计，还包括前置条件（比如剩油量）及预期输出的设计（比如给发动机供油的邮箱和上报故障情况），条件较多，需要综合考虑。  
序号1,前置条件中两个油箱BL、BR剩余油量均为200升，左、右油箱BR与左、右发动机EL、ER均无故障，依据第1条设计说明，输出控制左油箱BL向左发动机EL供油，右油箱BR向右发动机ER供油，不上报故障。  
序号2,前置条件中两个油箱BL、BR剩余油量均为200升，左油箱BL故障，右油箱BR与左、右发动机EL、ER均无故障，依据第2条设计说明，输出控制右油箱BR分别向左、右发动机EL和ER供油，并上报二级故障——左油箱故障。  
序号3,前置条件中两个油箱BL、BR剩余油量均为200升，右油箱BR故障，左油箱BL与左、右发动机EL、ER均无故障，依据第3条设计说明，输出控制左油箱BL分别向左、右发动机EL和ER供油，并上报二级故障——右油箱故障。  
序号4,前置条件中左油箱BL剩余油量为130升，BR剩余油量为120升，左右油箱剩油量之差为10升，左发动机EL故障，左、右油箱BL.BR与右发动机ER均无故障，依据第4条设计说明，输出控制左发动机EL断油，油箱BR向右发动机ER供油，并上报一级故障——左发动机故障。  
序号5,前置条件中左油箱BL剩余油量为150升，BR剩余油量为90升，左右油箱剩油量之差为60升，左发动机EL故障，左、右油箱BL.BR与右发动机ER均无故障，依据第4条设计说明，如果左右油箱剩油量之差大于等于50升，则使用剩油量多的油箱供油，则应输出控制左发动机EL断油，油箱BL向右发动机ER供油，并上报一级故障一左发动机故障。  
序号6,前置条件中两个油箱BL、BR剩余油量均为200升，左右油箱剩油量之差等于0升，右油箱BR与右发动机ER均故障，左油箱BL与左发动机EL均无故障，依据第6条设计说明，输出控制故障发动机（右发动机ER）断油，无故障的油箱（左油箱BL）为无故障发动机（左发动机EL）供油，并上报一级故障——-右发动机ER故障。  
序号7,前置条件中两个油箱BL、BR剩余油量均为200升，左右油箱剩油量之差等于0升，右油箱BR与左发动机EL均故障，左油箱BL与右发动机ER均无故障，依据第6条设计说明，输出控制故障发动机（左发动机EL）断油，无故障的油箱（左油箱BL）为无故障发动机（右发动机ER）供油，并上报一级故障——左发动机EL故障。  
序号8,前置条件中两个油箱BL、BR剩余油量均为200升，左右油箱剩油量之差等于0升，左油箱BL与右发动机ER均故障，右油箱BR与左发动机EL均无故障，依据第6条设计说明，输出控制故障发动机（右发动机ER）断油，无故障的油箱（右油箱BR）为无故障发动机（左发动机EL）供油，并上报一级故障一一-右发动机ER故障。  
序号9,前置条件中两个油箱BL、BR剩余油量均为200升，左右油箱剩油量之差等于0升，左、右油箱BR均故障，左、右发动机EL、ER均无故障，依据第7条设计说明，输出控制左、右发动机EL、ER均断油，并上报特级故障——两侧油箱均故障。  
序号10,前置条件中两个油箱BL、BR剩余油量均为200升，左右油箱剩油量之差等于0升，左、右油箱BL、BR均无故障，左发动机EL故障，右发动机ER未知，但是输出控制左、右发动机EL、ER均断油，并上报特级故障，依据第7条设计说明，只有当两个油箱或两个发动机同时故障或存在更多故障时，才会得到如此的控制，故断定右发动机ER—定故障。  
序号11,前置条件中两个油箱BL、BR剩余油量均为200升，左右油箱剩油量之差等于0升，左油箱BL故障，左、右发动机EL、ER均故障，只有右油箱BR无故障，依据第7条和第8条设计说明，输出控制左、右发动机EL、ER均断油，并上报特级故障——两侧发动机均故障。左油箱故障的二级故障和两侧发动机均故障的特级故障同时发生，只上报特级故障。  


## 第4题 ##

【问题1】  
(1) 0xFF800000或者FF800000H  
(2) 64MB  
(3) 0x0FFFFFFF或者0FFFFFFFH  
  
存储容量是指计算机存储器所能存储的二进制信息的总量，它反映了计算机处理信息时容纳数据量的能力。存储容量以字节为单位，每1024字节称为1KB，每1024KB字节称为1MB，每1024MB字节称为1GB。因此，计算机的内存存储容量的计量单位是字节。  
系统FLASH存储器的存储容量是8MB，二进制表示为0x800000,地址分配在存储空间的高端，地址空间为0XFF800000\_~0xFFFFFFFF。  
用户FLASH存储器的地址空间为0x78000000~0x7BFFFFFF，存储容量是为0x4000000,即64MB。  
SDRAM的存储容量是256MB,二进制表示为0x10000000，地址分配在存储空间的低端，地址空间为0x00000000~0x0FFFFFFF。  
  
【问题2】  
(1) 200  
(2) 0000.0000.0011.1110.1000  
  
ARINC429总线协议是美国航空电子工程委员会（Airlines Engineering Committee)于1977年7月提出的，并于同年同月发表并获得批准使用。它的全称是数字式信息传输系统DITS。协议标准规定了航空电子设备及有关系统间的数字信息传输要求。ARINC429广泛应用在先进的民航客机中，如B-737、B757、B-767,它采用异步双极性归零码进行数据的编码，并通过双绞线传输，具有很强的抗干扰性能。  
ARINC429数据总线协议规定一个数据字由32位组成，一个32位的数据字由五部分组成：  
标志位（LABEL),用于标识传输数据的信息类型；  
源/目的标识码（S/D)，用于判断在一个多系统中的源系统；  
数据区（DATA);  
符号/状态位（SSM),用于标识数据字的特征或数据发生器的状态；  
奇偶校验位（PARITY),ARINC429数字信息传输使用奇校验。  
本题中接收数据帧的D28-D9位是数据区，二进制为0000.0000.0111.1101.0000,即2000。根据系统定义，高度表数据的分辨率为0.1米，即D9为1表示0.1米，则当前的高度是2000\*0.1=200米。  
反之，若当前的高度是100米，则数据帧中数据区的值应为100/0.1=1000,则D28-D9位应为0000.0000.0011.1110.1000。  
  
【问题3】  
(1) 67  
(2) pBuf-&gt;head==pBuf-&gt;tail  
(3) pBuf-&gt;tail==(pBuf-&gt;head+1)%32  
  
在C语言中，结构体（struct)是一种聚合数据类型（aggregate data type)。根据不同编译器以及编译选项的属性，系统为它分配的存储空间会有所不同，在存储该结构体时会按照不同的内存对齐规则进行相关处理。本题中为了避免由于不同的编译环境对数据结构产生不同的编译结果，采用了紧缩属性强迫编译器按照字节对齐方式，在该模式下，SPM\_CHAN\_\_RX429结构体占用的存储空间为1+1+1+32\*2=67。  
环形队列是在工程应用中使用极为广泛的数据结构，它是一个首尾相连的FIFO的数据结构，具有较多优点：数据组织简单，能很快知道队列是否满为空；能以很快速度的来存取数据。因为有简单高效的原因，甚至在硬件都实现了环形队列。内存上没有环形的结构，因此环形队列实际上是用数组的线性空间来实现。并将数组元素fifo\[0\]与fifo\[MAXN-1\]连接，形成一个存放队列的环形空间。为了方便读写，还要用数组下标来指明队列的读写位置，定义Head/tail两个变量，分别指向可以读的位置和可以写的位置。  
环形队列的关键是判断队列为空还是为满。本题中限制写入数据最多为31个，即队尾与队首之间至少保留一个元素的空间，即当读写指计相同时，表示队列为空，当写指针+1等于读指针时，表示队列为满。  
实际使用中，还要考虑当数据到了尾部如何处理，它将转回到0位置来，通过数组下标索引取模操作（Index%MAXN)来实现的。  


## 第5题 ##

【问题1】  
(1) 限定变量，不允许被修改。  
(2) 不正确。因为该数组需要被修改。  
  
在C语言中，const修饰的数据类型是指常类型，常类型的变量或对象的值不能被更新的。  
在本题中bonus数组也使用const修饰，显然是错误的，因为在函数体内bcnus数组的值是被改变的，编译器会报错的。  
  
【问题2】  
(1) sum\_profit += profit\[++i\];  
(2) sum\_profit += profit\[i++|;  
  
根据题意，1月到12月份的利润分别保存在profit\[0\]到profit\[ll\]之中。所以年度总利润应该是profit\[0\]+profit\[l\]+profit\[2\]+…+profit\[ll\]。而语句：  
sum\_profit+=profit\[++i\];  
等价于：  
i=i+l；  
sum\_profit=sum\_profit+profit\[i\];  
在计算年度总利润的代码中就等于profit\[l\]+profit\[2\]+•••+profit\[12\]。这并不符合题意，是错误的。正确的代码应为：  
sum\_profit+=profit\[i++\];  
  
【问题3】  
(1) bonus\[i\]=profit\[i\]\*0.1  
(2) bonus\[i\]=bonus1+(profit\[i\]-100000)\*0.15  
(3) bonus\[i\]=bonus2+(profit\[i\]-200000)\*0.20  
(4) bonus\[i\]=bonus4+(profit\[i\]-400000)\*0.25  
(5) bonus\[i\]=bonus6+(profit\[i\]-600000)\*0.30  
(6) bonus\[i\]=bonus 10+(profit\[i\]-1000000)\*0.35  
  
根据题意，企业员工在1月到12月份创造的利润分别保存在profit\[0\]到profit\[11\]之中，作为计算每个月奖金的输入，用const修饰，在函数执行期间不能改变。而根据利润计算出每的奖金则做为输出数组保存在bcmus\[0\]到bonuS\[11\]中。  
根据说明计算方法，程序calculate\_bonus的前半部分为计算1到12月的奖金。  
当利润低于或等于10万元时，奖金可提10%，故填空（1）应填入bonus\[i\]=profit\[i\]\*0.1；  
当利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成15%;故填空（2）应填入bonus\[i\]=bonus1+(profit\[i\]-100000)\*0.15;  
当利润在20万到40万之间时，高于20万元的部分，可提成20%,故填空（3）应填入bonus\[i\]=bonus2+(profit\[i\]-200000)\*0.20；  
当40万到60万之间时高于40万元的部分，可提成25%,故填空（4.)应填入bonus\[i\]=bonus4+(profit\[i\]-400000)\*0.25；  
当60万到100万之间时，高于60万元的部分，可提成30%，故填空（5）应填入bonus\[i\]=bonus6+(profit\[i\]-600000)\*0.30；  
当高于100万元时，高于100万元的部分可提成35%,故填空（6）应填入bonus\[i\]=bonus10+(profit\[i\]-1000000)\*0.35。  
所以，正确且完整的calculate\_bonus函数如下：  
int calculate\_bonus(const int profit\[\],int bonus\[\])  
\{  
int n=12;  
int i=0;  
int sum\_profit=0;  
int bonus1,bonus2,bonus4,bonus6,bonuslO;  
bonus1=100000\*0.1;  
bonus2=bonus1+100000\*0・15;  
bonus4=bonus2+200000\*0.2;  
bonus6=bonus4+200000\*0.25;bonusl0=bonus6+400000\*0.3;  
for(i=0;i&lt;n;i++)  
\{  
if(profit\[i\]&lt;=100000)  
bonus\[i\]=profit\[i\]\*0.1;  
else if(profit\[i\]&lt;=200000)  
bonus\[i\]=bonusl+(profit\[i\]-100000)\*0.15;  
else if(profit\[i\]&lt;=400000)  
bonus\[i\]=bonus24-(profit\[i\]-200000)\*0.20;  
else if(profit\[i\]&lt;=600000)  
bonus\[i\]=bonus4+(profit\[i\]-400000)\*0.25;else if(profit\[i\]&lt;=1000000)  
bonus\[i\]=bonus6+(profit\[i\]-600000)\*0.30;else  
bonus\[i\]=bonusl0+(profit\[i\]-1000000)\*0.35;  
\}  
/\*以下代码计算年度总利润\*/  
i=0;  
while(i&lt;n)  
sum\_profit+=profit\[i++\];  
return sum\_profit;  
\}  



[a1892aa13d9f4eb0b52ed13f4838538b.jpg]: https://www.xkxxkx.cn/file/exam/software/嵌入式系统设计师/案例/第1题/a1892aa13d9f4eb0b52ed13f4838538b.jpg
[0c5fb29995434cf49da7a69d9a3a5a49.jpg]: https://www.xkxxkx.cn/file/exam/software/嵌入式系统设计师/案例/第2题/0c5fb29995434cf49da7a69d9a3a5a49.jpg
[d39e533d8c3d41419ff26cdbd8c69221.jpg]: https://www.xkxxkx.cn/file/exam/software/嵌入式系统设计师/案例/第2题/d39e533d8c3d41419ff26cdbd8c69221.jpg
