---  
title: 2018年下半年  
# icon: gears  
order: 981  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
(1) A,或A  
(2) ai,或a  
(3) bi,或bi  
(4) A,B  
(5) B  
  
本题考查程序设计——算法流程图的设计。  
为了将区间\[a1b1\],\[a2,b2\],...,\[an,bn\]添加到区间集\[a1,b1\],上，首先需要将A与区间集的各左端点a1，a2，…,an逐个进行比较。如果首次发现A≤ai，显然就应输出A。因此空（1）应填写A或“ A，”。此后，如果发现B≤ai，则说明合并已经完成，随后输出B，ai，bi以及随后的各个区间端点。  
如果发现A&gt;ai如则应输出ai，因此空（2）中应填写ai或“ai,”。随后，需要将A与其右端点bi比较。如果发现A＞bi，则说明合并尚未开始，应先输出bi或“bi，”因此， 空（3）应填写bi或“bi，”。此时，A与第i个E间\[ai，bi\]已比较完毕，接着应与可能有的下一个区间比较。为此，需要执行i+1→i,并判断是否已经与全部区间比较完成，即比较i是否超过了n。如果没有超过，则返回去进行下一轮比较；如果i已超过了n，则说明A比所有区间的端点都大，此时应输出A，B。因此空（4）中应填写A，B或“A B”。  
在A&gt;ai的前提下，如果A≤bi，即A落在区间\[ai,bi\]内，则需要判断是否B也落在该区间内。如果是，则合并完成，输出bi以及随后的各个区间端点；如果B&gt;b,，则需要将B与随后的区间端点进行比较。如果后面没有区间了，则应输出B，结束流程。闪此， 空（5）应填写B。  


## 第2题 ##

【问题1】  
Palindromic number.  
a=-1331 b=1331  
a=795 b=597  
  
本题考查C程序基本结构的理解和应用。  
C代码1中，语句“tmp=a&lt;0? -a: a;”的作用是将所读入整数的绝对值用tmp表示。  
表达式tmp%10的结果为获取tmp所表示整数的个位数字，tmp=tmp/10则去掉该整数的个位数字（从而使整数位数少了1位)，由于tmp为非负整数，重复以上两个表达式的计算，就能逐个得到整数的各位数字。表达式b=b\*10+tmp%10将取出的各位数字再组成一个整数，其值正好是原整数的逆置。  
如果a与其逆置数相同，则a是回文数。  
  
【问题2】 Passed, points=4  
Passed, points=1  
Passed, points=1  
Passed, points=1  
Failed  
  
C代码2主要考查循环结构以及对switch语句的理解和应用。  
字符的内部表示为其ASCII代码，循环语句中grade的初始值为'A'，加1后即得到 'B'的代码，因此for语句的循环控制使得grade依次表示了字符'A"B’'C”D"E’和'F'，在grade表示字符'F’时结束循环。  
执行switch语句时，如果表达式的值匹配上某个case后面的常量，则执行该case后的语句，遇到break时结束switch语句，否则继续执行下面case之后的语句，直到遇到break或者switch语句结束。当grade为'A'时，switch语句中case ’A’后的语句将points赋值为4，再由break结束switch;当grade为'B’时，switch语句中case'B’后的语句先将points赋值为3，之后再赋值为2，然后再赋值为1，再由break结束switch语句。grade的其他取值类推。  


## 第3题 ##

【问题1】  
(1) qt&lt;181或qt&lt;=180或其等效形式  
(2) qt&lt;361或qt&lt;=360或其等效形式  
(3) 180\*0.5+(360-180)\*0.55+(qt-360)\*0.7  
或189+(qt—360)\*0.7  
或-63+qt\*0.7或其等效形式  
(4) qt&lt;minimum或其等效形式  
(5) qt&gt;maximum或其等效形式  
(6) m--或-m或m=m-1或m-=1或其等效形式  
  
本题考查C程序基本结构和函数定义及调用。  
阅读题目说明可确定函数proc中计算电费的处理逻辑，该函数的形参qt表示用电量，在调用该函数之前已经确保传过来的值非负。当空（1）所在的条件满足时，电费为用电量乘以0.5,即每度电0.5元，显然空（1）应填入“qt&lt;=180”或其等效形式。当执行流程到达空（2）时，表明用电量qt不满足条件“qt&lt;=180”，也就是“qt&gt;180度”成立，电费为180\*0.5+ (qt-180) \*0.55，表示用电量不超过360度，因此空(2)应填入“qt&lt;=360”或其等效形式，空（3）是“qt&lt;=360”不成立需要处理的电费情况，也就是满足“qt&gt;360”，需要分段计算不超过180度部分的电费180\*0.5、超过180度但不超过360度部分的电费(360-180)\*0.55以及超过360度部分的电费(qt-360)\*0.7,因此空(3)应填入 “180\*0.5+(360-180)\*0.55+(qt-360)\*0.7”或其等效形式。  
main函数的功能是读入多个用户的月用电量，根据每个用户的用电量qt计算电费，还要找出最大用电量和最小用电量。当空（4）所表示的条件成立时，进行运算“minimum=qt",也就是要更新最小用电量数值，说明发现了更小的用电量，因此空（4）应填入“qt&lt;minimum”或其等效形式。以此类推，可推断出空（5）应填入“qt &gt; maximum”。while循环条件为“m&gt;0”，循环中空（6）的作用就是修改m的值，使得最终m&gt;0不再成立，因此该空应填入“m--”或其等效形式。  


## 第4题 ##

【问题1】  
(1) arr\[n\]或\*(arr+n)或其等效形式  
(2) arr\[i+1\] = arr\[i\]或其等效形式  
(3) arr\[I+1\]或\*(arr+i+1)或其等效形式  
(4) break  
(5) pdata, n, price  
注：pdata可替换为&pdata或&pdata\[0\]  
(6) idx&lt;n或其等效形式  
  
本题考査c程序运算和控制逻辑及函数参数传递机制。  
设初始时数组中的有序序列如下：  
![2628676ed2544d3cbbb5bf443504c6cd.jpg][]  
假设要在该数组中分别插入元素55和35,过程如下：  
(1) 插入55时，由于55大于有序序列的最后一个元素（即elem&gt;arr\[n-1\]，此时n=5),因此将55直接存入arr\[n\]即可，结果如下，因此空（1）出应填入“arr\[n\]”或其等效形式。  
![6b1a193bef3643578b24fee37a96f5c9.jpg][]  
(2) 插入35时，通过比较elem&lt;arr\[4\]成立、elem&lt;arr\[3\]成立、elem&lt;arr\[2\]不成立，找到插入位置为arr\[3\],在此过程中可以将arr\[4\]的50、arr\[3\]的40依次向其后继位置移动，如下表所示。  
![0399a1de6c5b478284baf6ea19f84cd4.jpg][]  
运算开始时，i等于n-1(即air\[4\]的下标)，之后i递减，直到elem&lt;arr\[i\]不成立，需要将满足elem&lt;arr\[i\]的数组元素的值移入I+1下标对应的位置，因此空（2）处应填入“arr\[I+1\] = arr\[i\]”或其等效形式。最后再将elem的值插入空出来的位置，由于查找位置的循环结束时，elem&lt;arr\[i\]不成立，也就是说elem的值应插入arr\[i\]之后的位置，因此空(3)处应填入“arr\[i+1\]”或其等效形式，完成插入运算。  
根据题目描述，输入负数或0时结束，因此空（4）出应填入跳出循环的语句break。  
空（5）是调用函数insertElem时的实参，按照函数调用时对实参和形参类型、数量方面的约定，该空应填写数组空间首地址、数组元素个数和待插入的元素，即“pdata，n，price”或其等效形式。  
根据空（6）所在语句的作用，循环条件为“idx&lt;n”。  


## 第5题 ##

【问题1】  
(1) abstract void play(Note n)  
(2) extends Instrument  
(3) extends Wind  
(4) ArrayList&lt;Instrument&gt;  
(5) Music  
  
本题考査Java语言程序设计的能力，涉及类、对象、方法的定义和相关操作。  
本题目中涉及的部分乐器，音乐类利用各类乐器进行演奏和调音等操作。根据说明进行设计，题目给出了类图（如图5-1所示)。  
图中父类Instrument代表乐器，Java中设计为抽象类。Java中定义抽象类用abstract关键字。Instrument包含表不进行演奏的抽象方法play()和表示调音的抽象方法adjust()，抽象方法没有方法实现，直接用“;”结束，即没有\{\}括起来的实现体。其中play()的参数Note实现为枚举类型（enum)，以枚举各种音调。这两个方法由具体子类完成实现：  
abstract void play(Note n);  
abstract void adjust();  
Wind、Percussion和Stringed是继承Instrument的三个子类，Woodwind和Brass是继承Wind的两个子类，继承用关键字extends。Java中继承抽象类的类必须全部实现抽象类中的抽象方法，才能成为具体类进行实例化，否则未被实现的方法仍然需要保留abstract关键字， 并且相应类也仍然必须为抽象类且保留abstract关键字。Wind、Percussion和Stringed均为具体类，都要实现Instrument的play()方法和adjust()方法，只是各自演奏和调音方式有所不同，所以都包含了 Instrument的play()方法和adjust()方法，并加以实现：  
public void play(Note n) \{ /\*代码略\*/\}  
public void adjust () \{ /\*代码略\*/\}  
图5-1中Woodwind类对应的Woodwind的实现中只有play()方法，覆盖（Override) 了父类中的play()，没有adjust()方法的实现，因此其父类Wind的adjust()方法自动复制并被调用，而Brass中play()和adjust()均有实现，即都覆盖了父类中的方法。  
Music类对各类乐器进行演奏和调音操作。方法tune()为一个乐器的定调，其参数为抽象类Intrument类型；方法adjust()为一个乐器进行调音，其参数也为抽象类Intrunient类型；函数tuneAll()为所有乐器定调，其参数是所有乐器容器。函数tuneAll()方法的调用来自其中main()方法，其中参数为所构造的ArrayList&lt;lnstrument&gt;类型的容器，容器中对象元素类型为Instrument,在源代码开头的导入类型中，import java.util.ArrayList;只导入了ArrayList，所以tuneAll的参数类型为ArrayList&lt;Instrument&gt;，若上下文中List有效，也可用List&lt;Instrument&gt;。并采用for循环获取容器中每一个乐器并进行adjust()和tune()调用，即：  
void tuneAll( ArrayList&lt;Instrument&gt; e ) \{  
for (int j = 0; j &lt; e.size(); j++) \{  
Instrument i = e.get(j);  
adjust(i);  
tune (i);  
\}  
\}  
Music中的tune()和adjust()的参数均为抽象类Instrument类型引用i，再通过i.play()和i.adjnstG的方法调用，其真正执行的方法根据所传实际对象而定，即动态绑定。  
主控逻辑代码在Music类中程序主入口main()方法中实现。在main()方法中，先初始化Music类的对象，引用名称为music，即:  
Music music = new Music ();  
并初始化外类乐器对象容器orchestra，各类乐器用父类Instrument类型，因为向上转型是安全的，可以自动向上转增成为Instrument类型，用父类型表示其外个子类型，即：  
ArrayList&lt;Instrument&gt; orchestra = new ArrayListo();  
然后使用ArrayList中add()方法向容器中加入具体乐器对象,此处以Wind及其子类Woodwind为例：  
Orchestra. add ( new Wind());  
Orchestra. add ( new Woodwind());  
然后调用music的tuneAll()方法：music. tuneAll(orchestra);,实现为orchestra中的每个乐器定调，其参数为orchestra容器。orchestra中元素的类型为Instrument，所以tuneAll()的参数也应该为Instrument类型相应的容器，而非其子类型。在tuneAll()方法体内部，为每个元素调用当前对象的tune()和adjust()。  
综上所述，空（1）需要定义抽象方法play(Note n),题目代码中已经给出用分号结尾，所以空（1）为abstract void play(Note n)；空（2）需要继承抽象类Instrumenl，即extends Instrument；空(3)需要继承Wind，即extends Wind;空（4）需要定调的乐器容器，即ArrayList&lt;Instrument&gt;；空(5)处为创建Music类的对象，即Music。  


## 第6题 ##

【问题1】  
1.Virtual void play(Note n)=0  
2.public Instrument  
3.public Wind  
4.vector  
5.Music\*  



[2628676ed2544d3cbbb5bf443504c6cd.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/2628676ed2544d3cbbb5bf443504c6cd.jpg
[6b1a193bef3643578b24fee37a96f5c9.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/6b1a193bef3643578b24fee37a96f5c9.jpg
[0399a1de6c5b478284baf6ea19f84cd4.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/0399a1de6c5b478284baf6ea19f84cd4.jpg
