---  
title: 2009年下半年  
# icon: gears  
order: 999  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

试题一（15分）  
阅读以下说明和流程图，填写流程图中的空缺，将解答填入答题纸的对应栏内。  
【说明】  
求连续函数f(x)的根（方程f(x)=o的解）的最简单方法是二分法。为此，首先需要在若干点上检查函数值的符号，如果发现f(a)与f(b)符号相反（a&lt;b)，则在区间（a, b)中必然存在f(x)的根。因为当x从a变到b时，连续函数的值将从正变到负（或从负变到正)，必然要经过0。区间（a，b)就是根的初始范围。  
取该区间的中点m，如果f(m)=0，则根就是m。如果f(a)与f(m)符号相反，则根一定在区间(a，m)中；如果f(m)与f(b)符号相反，则根一定在区间(m，b)中。因此，根的范围缩小了一半。  
依此类推，将区间一半一半地分下去，当区间的长度很小（达到根的精度要求，例如0.001)时，或者当区间中点处的函数值几乎接近于0 (即绝对值小于预先规定的微小量，例如0.001)时，近似计算就可以结束了。  
以下流程图描述了用二分法近似计算区间（a, b)中f(x)的根的过程。 【流程图】  
![6f2bce800b214a6b9e1062e569051690.jpg][]  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  


## 第2题 ##

试题二（15分）  
阅读以下说明和C函数，填写程序中的空缺，将解答写入答题纸的对应栏内。  
【说明】  
函数Counter(intn，int w\[\])的功能是计算整数n的二进制表示形式中1的个数，同时用数组w记录该二进制数中1所在位置的权。  
例如，十进制数22的二进制表示为10110。对于该二进制数，1的个数为3,在w\[0\]中存入2 (即21)、w\[1\]中存入4 (即22)、w\[2\]中存入16 (即24)。  
【说明2】  
函数Sm0Ve(int A\[\], int n)的功能是将数组中所有的奇数都放到所有偶数之前。其过程为：设置数组元素下标索引i (初值为0)和j (初值为n-1)，从数组的两端开始检 查元素的奇偶性。若A\[i\]、A\[j\]都是奇数，则从前往后找出一个偶数，再与A\[j\]进行交换; 若A\[i\]、A\[j\]都是偶It则从后往前找出一个奇数，再与A\[i\]进行交换；若A\[i\]是偶数而A\[j\]是奇数，则交换两者，直到将所有的奇数都排在所有偶数之前为止。  
![186c40e3afa44202b77d02636c98296f.jpg][]  
![b4abd3bee3e54e20841f655fb08f5010.jpg][]  
![a447e0e1d5d54b81b37c8776f70a5404.jpg][]  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  
(5):  


## 第3题 ##

试题三（15分）  
阅读以下说明、C函数和问题，将解答写入答题纸的对应栏内。  
【说明】  
函数test\_f1(int m, int n)对整数m、n进行某种运算后返回一个整数值。  
【C函数1】  
![691f01dd17b042deb7b9a6d6d3de693b.jpg][]  
【说明2】 设在某C系统中为每个字符分配1个字节，为每个指针分配4个字节, sizeof(x)计算为x分配的字节数。函数test\_f2()用于测试并输出该C系统为某些数据分配的字节数。  
【C函数2】  
![09_3C-1.png][]  
【说明3】  
函数test\_f3(char s\[\])的功能是:将给定字符串s中的所有空格字符删除后形成的串保存在字符数组tstr中(串s的内容不变)，并返回结果串的首地址。  
【C函数3】  
![09_3C-2.png][]  
  
【问题1】（5分）  
(1)请写出发生函数调用test\_f1(9,6)时，函数的返回值；  
(2)请说明函数test\_f1的功能。  
  
【问题2】（4分）  
请写出函数test\_f2()的运行结果。  
  
【问题3】（6分）  
函数test\_f3()对返回值的处理有缺陷，请指出该缺陷并说明修改方法。  


## 第4题 ##

试题四（15分）  
阅读以下说明和C函数，填写程序中的空缺，将解答写入答题纸的对应栏内。  
【说明】  
函数del\_substr(S，T)的功能是从头至尾扫描字符串S，删除其中与字符串T相同的所有子串，其处理过程为：首先从串S的第一个字符开始查找子串T，若找到，则将后面的字符向前移动将子串T覆盖掉，然后继续查找子串T;否则从串S的第二个字符开始查找，依此类推，重复该过程，直到串S的结尾为止。该函数中字符串的存储类型SString定义如下：  
![cb8dae6b349245c081ddf3be5b5a9ccf.jpg][] ![185d6c7ffa9d432584e8eb9dcb64b886.jpg][]  
![1c2bd7d9afb849509bad69c0f2e312aa.jpg][]  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  
(5):  


## 第5题 ##

试题五（15分）  
阅读以下说明和C++代码，将应填入(n)处的字句写在答题纸的对应栏内。  
【说明】  
已知类LinkedList表示列表类，该类具有四个方法:addElement()、lastElement()、number-OfElement()以及removeLastElement()。四个方法的含义分别为：  
void addElement(Object)：在列表尾部添加一个对象；  
Object lastElement()：返回列表尾部对象；  
int numberOfElement()：返回列表中对象个数；  
void removeLastElement()：删除列表尾部的对象。  
现需要借助LinkedList来实现一个Stack栈类，C++代码1和C++代码2分别采用继承和组合的方式实现。  
![24f3941fbf424184b57d3a38a05a0648.jpg][]  
  
![255daf4606a444418747e0f352597b81.jpg][]  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  
若类LinkedList新增加了一个公有的方法removeElement(int. index),用于删除列表中第index个元素，则在用继承和组合两种实现栈类Stack的方式中，哪种方式下Stack对象可访问方法removeElement(int index)? (5) (A.继承B.组合）  


## 第6题 ##

试题六（15分）  
阅读以下说明和Java代码，填写程序中的空缺，将解答写入答题纸的对应栏内。  
【说明】  
己知类LinkedList表示列表类，该类具有四个方法:addElement()、lastElement()、number-Offilement()以及removeLastElement()。四个方法的含义分别为：  
void addElement(Object)：在列表尾部添加一个对象；  
Object lastElement()：返回列表尾部对象；  
int numberOfElement()：返回列表中对象个数；  
void removeLastElement()：删除列表尾部的对象。  
现需要借助LinkedList来实现一个Stack栈类，Java代码1和Java代码2分别采用继承和组合的方式实现。  
![7213620b8d884eb3ac4a47d181d71722.jpg][]  
![4c79191d9ebc4f319482f8720b8f0d48.jpg][]  
![94f165f231a44470bcd019746c4c67dd.jpg][]  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  
若类LinkedList新增加了一个公有的方法removeElement(int index),用于删除列表中第index个元素，则在用继承和组合两种实现栈类Stack的方式中，哪种方式下Stack对象可访问方法removeElement(intindex)? (5) (A.继承B.组合）  
  


## 答案及解析 ##

  



[6f2bce800b214a6b9e1062e569051690.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第1题/6f2bce800b214a6b9e1062e569051690.jpg
[186c40e3afa44202b77d02636c98296f.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第2题/186c40e3afa44202b77d02636c98296f.jpg
[b4abd3bee3e54e20841f655fb08f5010.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第2题/b4abd3bee3e54e20841f655fb08f5010.jpg
[a447e0e1d5d54b81b37c8776f70a5404.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第2题/a447e0e1d5d54b81b37c8776f70a5404.jpg
[691f01dd17b042deb7b9a6d6d3de693b.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第3题/691f01dd17b042deb7b9a6d6d3de693b.jpg
[09_3C-1.png]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/代码图/09下3C-1.png
[09_3C-2.png]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/代码图/09下3C-2.png
[cb8dae6b349245c081ddf3be5b5a9ccf.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/cb8dae6b349245c081ddf3be5b5a9ccf.jpg
[185d6c7ffa9d432584e8eb9dcb64b886.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/185d6c7ffa9d432584e8eb9dcb64b886.jpg
[1c2bd7d9afb849509bad69c0f2e312aa.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/1c2bd7d9afb849509bad69c0f2e312aa.jpg
[24f3941fbf424184b57d3a38a05a0648.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第5题/24f3941fbf424184b57d3a38a05a0648.jpg
[255daf4606a444418747e0f352597b81.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第5题/255daf4606a444418747e0f352597b81.jpg
[7213620b8d884eb3ac4a47d181d71722.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第6题/7213620b8d884eb3ac4a47d181d71722.jpg
[4c79191d9ebc4f319482f8720b8f0d48.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第6题/4c79191d9ebc4f319482f8720b8f0d48.jpg
[94f165f231a44470bcd019746c4c67dd.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第6题/94f165f231a44470bcd019746c4c67dd.jpg
## 第1题 ##

【问题1】  
(1) (a+b)/2  
(2) f(x),或f((a+b)/2)  
(3) |y|,或abs(y)，其中y 可由f(x)或f((a+b)/2)代替  
(4) b  
  
本题描述了求函数根（0点）的二分法，题中还详细说明了二分法的原理。  
假设a和b是区间两端点值的变量。流程图中，一开始就将函数两端的值分别送y1和y2,接着判断yl与y2符号是否相反（同号时该算法不能往下进行)。若相反，则应将a与b的中点值(a+b)/2送x。此时的函数值f(x)，即f((a+b)/2)应送y。因此，（1）处应填(a+b)/2，(2)处可填f(x)或f((a+b)/2)。  
接着需要判断新的函数值是否已经接近0,因此，（3）处应填丨y丨或abs(y)。  
如果这个新函数值已经接近0,则可以直接输出变量x的值（刚取的中点值）作为函数的近似根;如果该函数值尚未接近0,则需要将该区间进行二分，即需要判断选用左半区间还是右半区间，继续进行迭代计算。  
如果y\*y1&lt;0,则说明新的函数值与原区间的左端函数值符号相反，因此应取左半区间；否则应取右半区间。  
若取左半区间，则原来的区间左端点a没有变化，左端点的函数值yl也没有变化，只要将中点值x送右端点变量b就可以。因此，（4）处填b。  
若取右半区间，则区间的右端点没有变化，右端点的函数值y2也没有变化，这时需要将中点值x送左端点变量a。因此，（5）处应填a。由于每次迭代都需要判断y\*y1的符号，因此y1的改变将影响下次迭代。因此，此时还需要将中点处的函数值y送y1，作为新区间的左端点函数值。  
当新的区间(a，b)长度ha很小时，迭代计算就可以结束，输出已经得到的近似根x就可以了。  


## 第2题 ##

【问题1】  
(1) n!=0,或其等价形式  
(2) k=k\*2，或k\*=2，或k+=k，或k=k+k,或其等价形式  
(3) i++,或++i,或i+=1,或i=i+1，或其等价形式  
(4) j--，或--j，或j-=1，或j=j-1，或其等价形式  
(5) A\[i\]%2=0&&A\[j\]%2!=1，或A\[i\]%2!=0&&A\[j\]%2，或!(A\[i\]%2)&&A\[j\]%2,或其等价形式  
  
本题考查c程序控制结构的应用。  
根据题目描述，函数Counter(int n, int w\[\])的功能是计算整数n的二进制表示形式中1的个数，同时用数组w记录该二进制数中1所在位置的权。要计算n的二进制形式中1的个数，基本方法是计算n的二进制数时进行计数，题中的函数Counter采用的就是此方法。十进制数转换为二进制数的方法是辗转除以2取余数，直到被除数为0时为止。  
例如，十进制数26的二进制形式为11010,计算步骤为：  
①被除数是26,除数是2,商为13,余数为0;  
②被除数是13,除数是2,商为6,余数是1;  
③被除数是6,除数是2,商为3,余数是0;  
④被除数是3,除数是2,商为1,余数是1;  
⑤被除数是1,除数是2,商为0,余数是1。  
计算结束。  
从上例可知，二进制数的各位是从低到高依次计算出来的。  
因此，函数Counter中的空（1）处应填入n或n!=0。显然，代码中用k记录二进制数各位的权值，其初始值为1，每算出1位，其值要改为上一位权值的2倍。因此空（2）处应填入k=k\*2或k\*=2。  
对于函数Smove(intA\[\], int n)，其功能是将数组中所有的奇数都放到所有偶数之前。分析题中给出的处理过程，交换动作发生在A\[i\]为偶数而A\[j\]为奇数时，因此空（5）处应填入“A\[i\]%2=0&&A\[j\]%2!=0”（或其等价表示方式），其他情况下都是修改i和（或）j的值。下面举一例进行说明，设数组A中的元素初始排列为15,20,23,30,77,62,45,68,34,61.  
初始时i=0, j=n-1=9。A\[0\]=15, A\[9\]=61, A\[0\]是奇数，所以其值保持不动，A\[9\]也是奇数，需要将其前移，实质上是要找出前面的一个偶数与其对调，这就需要增加下标i的值，从而向后找偶数。对应的代码是i++,j不变，因此空（3）处应填入i++或等价表示方式。接下来找到的偶数是A\[1\]，将其与A\[9\]对调，数组中的元素排列情况为15,61,23,30,77,62,45,68,34,20。之后i++, j--,对应的数组元素为A\[2\] (值为23,是奇数）和A\[8\](值为34,是偶数），这种情况下显然不需要进行对调，因此将i增1、j减1，找到A\[3\]和A\[7\]。由于A\[3\](值为30)和A\[7\](值为68)都是偶数，因此需要从后面找出一个奇数，将其与A\[3\]对调。因此，空（4）处应填入j--(或等价表示方式）。接下来找到A\[6\]，交换A\[3\]和A\[6\]的值，数组元素的排列情况为15,61,23,45,77,62,30,68,34,20。  
这样，数组中的奇数全部排在偶数之前。  


## 第3题 ##

【问题1】  
(1)18  
(2)求两个整数的最小公倍数  
考生解答含义与最小公倍数相同即可给分。  
  
本题考查C语言基本运算和控制结构的应用。  
对于传入函数test\_f1中的参数m和n，运算“k=m&gt;n?m:n”使得k取m和n中的较大者。此后，“for(;(k%m!=0)||(k%n!=0);k++);”使得k最后的取值正好能同时被m和n整除，因此，本函数的功能是求m和n的最小公倍数。9和6的最小公倍数是18。  
  
【问题2】  
9 4  
1 4  
  
本题考查C程序中的数据定义和存储应用。  
对于定义char str\[\]="NewWorld",数组str由字符串"NewWorld"初始化后，其大小为9 (包括串为结束标志字符'\\0’)，因此sizeof(str)的值为9。  
对于定义“char\*p=str”,ptr指向“NewWorld”的第一个字符“N”（即数组str的起始地址对应存储单元处存放的字符)，ptr是指针变量，因此sizeof(p)的值为4。  
对于定义“char i='\\0'”, i是字符变量，其初始值为ASCII码值为0的字符，因此sizeof(i)的值为1。  
对于定义“void \*ptr=malloc(50)”，ptr是指向50个字节存储区域的指针，因此sizeof(ptr)的值为4。  
  
【问题3】  
缺陷：返回了局部数据（或变量，或数组）的指针（或地址）。 .  
修改方法：用malloc函数申请存储字符串的存储空间，令指针tstr指向该存储空间并返回tstr的值即可。  
  
本题考查C语言数据存储类型的基础知识及常见应用错误和处理知识。  
一般将内存划分为代码去、静态数据区、栈区和堆区，其中，栈区和堆区也称为动态数据区。C程序中的数据（大多以变量和数组表示）可存储在计算机系统内存区域的不同部分。全局变量（全局数组、外部变量等）和静态局部变量的存储单元在静态数据区分配，它们的生存期（即变量与其存储单元之间的绑定关系）较长，在程序运行期间始终存在。而局部变量（自动变量、局部数组等）的存储单元在栈区分配，它们的生存期较短，随着函数被调用而分配空间，函数调用结束后释放分配给它们的存储空间，这是由系统控制的。而堆区的存储空间由程序员根据需要用malloc函数申请，不用时用free函数释放，归还给系统。  
在函数test\_f3中，数组tstr的空间在栈区分配，函数调用结束后该存储空间将由系统自动回收，随着程序的执行再进行分配，所以用“return tstr”返回该数组的首地址将可能使得需要用这个存储区中数据的地方出错。  


## 第4题 ##

【问题1】  
(1)i-j+1,或其等价形式  
(2)j=T.length,或 j&gt;=T.length，或其等价形式  
(3)i-j,或i-T.length  
(4)k-T.length,或k-j,或其等价形式  
(5)S-&gt;length -T.length，或S-&gt;length-j  
  
本题考查c程序设计基本能力，包括指针、结构体类型的应用。  
根据题目部分的描述，首先要在字符串S中查找与T相同的子串，基本方法是逐个字符进行比对，其代码如下所示：  
![b509a7c3d7d44e6891b077c70b57733f.jpg][]  
显然，当S-&gt;ch\[i\]与T.ch\[j\]不相等时，i值需回退至本趟开始位置后再后移一个位置，从而为开始下一趟查找做准备。由于相同的字符个数为j个，因此i需回退至位置i-j+1，即空（1）处填入i-j+1。  
由于在串S中查找与1'相同的子串是以“1&lt;S-&gt;length&&j&lt;T.length”作为条件的，因此查找结束时，该条件必然为假。若在S中找到与T相同的子串，则“j &lt; T.length”必然不成立，即j将等于T.length。因此，空(2)处应填入j==T.length。根据注释，空(3)处需计算S中子串T的起始下标，显然应填入i-j或i-T.length。  
通过覆盖子串T进行删除，也就是将后面的字符前移来实现删除。假设需要删除的子串在S-&gt;ch\[p\]S-&gt;ch\[p+T.length-1\]中，则需要将S-&gt;ch\[p+T.length\]移至S-&gt;ch\[p\]，S-&gt;ch\[p+T.length+1\]移至S-&gt;ch\[p+l\],依此类推，直到将S-&gt;ch\[S-&gt;length-1\]移至S-&gt;ch\[S-&gt;length-T.length\]为止，因此以下代码中的空（4）处应填入k-T.length。  
for(k=i+T.length;k&lt;s-&gt;length;k++)/\*通过搜盖子串T进行删除\*/S~&gt;ch\[(4)\]=S-&gt;ch\[k\]；  
最后，空(5)处很明显是要将S的长度减去子串T的长度值，因为删除了一个相应长度值的子串，因此空(5)处填入S-&gt;length-T.length。  


## 第5题 ##

【问题1】  
(1) lastElement()  
(2) removeLastElement()  
(3) LinkedList list  
(4) lastElement()  
(5) A  
  
本题考查面向对象基本概念和C++语言程序设计能力。  
继承和组合是面向对象程序设计中复用的基本手段。继承的方式是在实现类的过程中指定其父类，则该类将自动拥有父类的属性和方法；组合方式则是将某类的对象作为该类的成员，通过成员使用该类的属性和方法。  
本题中C++代码1采用的是继承方式，因此在Stack类中可以直接使用LinkedList类中定义的方法。空缺（1）要求获得栈顶元素，LinkedList类提供了 lastElementO方法获得列表尾部的元素，因此可使用该方法获得栈顶元素；空缺(2)位于Stack类的pop()方法中，该方法不仅要获得栈顶元素，还要将栈顶元素删除，因此可以直接复用LinkedList类中的removeLastElement()方法。  
本题中C++代码2釆用的是组合方式，因此在Stack类中需要通过LinkedList对象来使用其属性和方法。Stack类中的peek()方法要求获得栈顶元素，list—定是LinkedList类型的对象，因此空缺(3)应该定义link成员变量，空缺（4）应该调用link对象获得队列的尾部元素方法。  
若LinkedList方法新增加了一个公有的removeElement(int index)方法，采用继承方式的子类对象可直接使用该方法，而釆用组合方式则必须通过对象形式进行访问，因此必须在Stack类中增加新的方法，并在该方法中通过list对象调用removeElement(int index)。  


## 第6题 ##

【问题1】  
(1)lastElement()  
(2)removeLastElement()  
(3)LinkedList list  
(4)lastElement()  
(5)A  
  
本题考查面向对象基本概念和Java语言程序设计能力。  
继承和组合是面向对象程序设计中复用的基本手段。继承的方式是在实现类的过程中指定其父类，则该类将自动拥有父类的属性和方法；组合方式则是将某类的对象作为该类的成员，通过成员使用该类的属性和方法。  
本题中Java代码1采用的是继承方式，因此在Stack类中可以直接使用LinkedList类中定义的方法。空缺（1）要求获得栈顶元素，LinkedList类提供了lasffilement()方法获得列表尾部的元素，因此可使用该方法获得栈顶元素；空缺（2）位于Stack类的pop()方法中，该方法不仅要获得栈顶元素，还要将栈顶元素删除，因此可以直接复用LinkedList类中的removeLastElement()方法。  
本题中Java代码2釆用的是组合方式，因此在Stack类中需要通过LinkedList对象来使用其属性和方法。Stack类中的peek()方法要求获得钱顶元素，list—定是LinkedList类型的对象，因此空缺（3）应该定义link成员变量，空缺（4）应该调用link对象获得队列的尾部元素方法。  
若LinkedList方法新增加了一个公有的removeElement(int index)方法，釆用继承方式的子类对象可直接使用该方法，而釆用组合方式则必须通过对象形式进行访问，因此必须在Stack类中增加新的方法，并在该方法中通过list对象调用removeElement(int ind6x)。  



[b509a7c3d7d44e6891b077c70b57733f.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/b509a7c3d7d44e6891b077c70b57733f.jpg
