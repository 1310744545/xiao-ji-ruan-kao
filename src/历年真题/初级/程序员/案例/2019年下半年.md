---  
title: 2019年下半年  
# icon: gears  
order: 979  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

试题一（15分）  
阅读以下说明和流程图，填写流程图中的空缺，将解答填入答题纸的对应栏内。  
【说明】  
某系统中有N个等长的数据记录，其主键值为随机排序且互不相等的正整数编号，表示为K(0), K(1),…，K(N-1)。现采用杂凑法将各数据记录存入区域S(0)，S(1), S(2),…,S(M-1)中（M≥N)，以加快按主键值检索的效率（初始时各区域都是空的）。  
下面流程图中，选用适当的质数P (N≤P≤M),对每个主键值先计算出它除以P的余数j。如果区域S(j)已占用，则考查下一个区域S(j+1),……，直到发现某个区域为空时，则将该主键值相应的数据记录存入该区域（注意，S(M-1)的下一个区域是S(0))。为了标记每个区域是否已占用，采用了M个标记位F(0)，F(1)，…，F(M-1)。初始时所有的标记位都为0,每当一个区域被占用时，将相应的标记位置1。  
例如，设6个记录的主键值分别为31、15、20、35、18、10,取质数P=7,用上述杂凑法将这些记录存入区域S(0)~S(7)后，各区域中记录的主键值依次为35、15、空、31、18、10、20、空。  
【流程图】  
![72bc5d87d2c9410390581ecb34d150b4.jpg][]  
注1: “循环开始”框内给出循环控制变量的初值、终值和增值（默认为1)，格式为：循环控制变量=初值，终值\[，增值\]  
注2:函数int(x)为取x的整数部分，即不超过x的最大整数。  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  
(5):  


## 第2题 ##

试题二（15分）  
阅读以下C代码，回答问题1至问题3，将解答写入答题纸的对应栏内。  
【说明】 ![19_2C.png][]  
  
【问题1】（4分）  
请给出C代码1运行后的输出结果。  
  
【问题2】（6分）  
已知字符'a'的ASCII码值为十进制数97,请给出调用C代码2中函数func('a')后的输出结果。  
  
【问题3】（3分）  
请给出调用C代码3中函数test()后的输出结果。  


## 第3题 ##

试题三（15分）  
阅读以下说明和C代码，填写程序中的空缺，将解答写入答题纸的对应栏内。  
【说明】  
规定整型数组a中的元素取值范围为\[0, N)，函数usrSort(int n, int a\[\])对非负整型数组a的前n个元素进行计数排序。排序时，用temp\_arr\[i\]表示i在数组a中出现的次数，因此可以从0开始按顺序统计每个非负整数在a中的出现次数，然后对这些非负整数按照从小到大的顺序，结合其出现次数依次排列。  
例如，对含有10个元素\{0,8,5,2,0,1,4,2,0,1\}的数组a\[\]排序时,先计算出有3个0、2 个1、2个2、1个4、1个5和1个8,然后可确定排序后a的内容为\{0,0,0,1,1,2,2,4,5,8\}。  
下面代码中用到的memset函数的原型如下，其功能是将p所指内存区的n个字节都设置为ch的值。  
void \* memset(void\*p,int ch, size\_t n);  
![19_3C.png][]  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  
(5):  


## 第4题 ##

试题四（15分）  
阅读以下说明和C代码，填写程序中的空缺，将解答写入答题纸的对应栏内。  
【说明】  
函数strCompress(char \*s)对小写英文字母串进行压缩，其基本思路是：如果串长小于3则不压缩，否则对连续出现的同一字符，用该字符及其个数来表示。例如，字符串  
"abbbcdddddddeeed”压缩后表示为 Mab3cd7e3d"。  
如图4-1所示，在计算连续出现的同一字符个数时，借助字符指针s和计数变量k表示串中的字符，当s所指字符与其后的第k个字符不同时，一个重复字符串的压缩参数即可确定。  
![9675ce61e0ea4e2ba342d142c37a7ccc.jpg][]  
【C代码】  
![19_4C.png][]  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  
(5):  


## 第5题 ##

试题五（15分）  
阅读以下说明和Java代码，填写程序中的空缺，将解答写入答题纸的对应栏内。  
【说明】  
球类比赛记分系统中，每场有两支球队（Team)进行比赛（Game)，分别记录各自的得分。图5-1所示为记分系统的类图。  
![5517eef0fa354db2b6a606b2d9117ddf.jpg][]  
【Java代码】  
![19_java-1.png][]  
![19_java-2.png][]  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  
(5):  


## 第6题 ##

试题六（15分）  
阅读下列说明和C++代码，将应填入(n)处的字句写在答题纸的对应栏内。  
【说明】  
球类比赛记分系统中，每场有两支球队（Team)进行比赛（Game)，分别记录各自的得分。图6-1所示为记分系统的类图。  
![61c28ea704014eb7b5ad2cc87a277b31.jpg][]  
![73020e278c92463a8042c8381c2326ad.jpg][]  
![f9e761a8b6f6425888b282ff8fd612c4.jpg][]  
  
【问题1】（15分）  
(1):  
(2):  
(3):  
(4):  
(5):  
  


## 答案及解析 ##

  



[72bc5d87d2c9410390581ecb34d150b4.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第1题/72bc5d87d2c9410390581ecb34d150b4.jpg
[19_2C.png]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/代码图/19下2C.png
[19_3C.png]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/代码图/19下3C.png
[9675ce61e0ea4e2ba342d142c37a7ccc.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第4题/9675ce61e0ea4e2ba342d142c37a7ccc.jpg
[19_4C.png]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/代码图/19下4C.png
[5517eef0fa354db2b6a606b2d9117ddf.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第5题/5517eef0fa354db2b6a606b2d9117ddf.jpg
[19_java-1.png]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/代码图/19下java-1.png
[19_java-2.png]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/代码图/19下java-2.png
[61c28ea704014eb7b5ad2cc87a277b31.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第6题/61c28ea704014eb7b5ad2cc87a277b31.jpg
[73020e278c92463a8042c8381c2326ad.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第6题/73020e278c92463a8042c8381c2326ad.jpg
[f9e761a8b6f6425888b282ff8fd612c4.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第6题/f9e761a8b6f6425888b282ff8fd612c4.jpg
## 第1题 ##

【问题1】  
(1)K(i)/P或等效形式  
(2)0  
(3)1—&gt;F(j)或F(j)=1或等效形式  
(4)j+1—&gt;j或j=j+1或j++或等效形式  
(5)0—&gt;j或j=0或等效形式  
  
本题旨在考查程序设计（算法流程图设计）的能力。  
杂凑法是大数据处理时常用的数据存储检索方法，其检索效率很高。  
本流程图中，将依靠循环i=0,1,…,N-1,依次将主键值为K(i)的记录存入适当的区域S(j)中。  
首先，需要求出K(i)除以质数P的余数j,采用的方法是计算K(i)-P\*int(K(i)/P)。例如，对于P=7, 31/7的商的整数部分为4,所以31除以7的余数为31-7X4=3。因此流程图中的空（1）应填写K(i)/P或其等效形式。  
然后判断区域S(j)的标志位F(j)是否为0，即空（2）应填写0。  
如果F(j)=0则表示区域S(j)为空，可以将K(i)直接存入区域S(j)中，并将F(j)置1表示已被占用，即空（3）应填写1—&gt;F(j)。  
如果F(j)非0,则表示S(j)已占用，需要考虑下一个区域是否为空。也就是说，需要将j增1,即空（4）应填写j+1—&gt;j。  
如果j增1后已超越最后一个区域，则需要考虑返回区域S(0)。也就是说，当j=M时，需要执行0—&gt;j，即空（5）应填写0—&gt;j。  


## 第2题 ##

【问题1】  
6  
6  
7  
6  
  
本题考查考生对C程序基本语句和控制结构的理解和应用。  
C代码1主要考查前置自增（自减）和后置自增（自减）运算的含义。自增（自减) 运算是C程序中频繁使用的运算，其含义是将变量的值增加1 (减去1)。前置自增时，是将变量的值增加1，增1后变量的值作为表达式的值；后置自增时，是先取变量的值作为表达式的值，然后将变量的值增加1，自减运算同理。本代码段中，num的初始值为5，经过前置自增运算“++num”之后，num的值变为6,该表达式（++num)的值也是num自增后的值，即第一个printf输出6。对于表达式“num++”，是对num进行后置自增，该表达式的值取num自增之前的值（即6，即第二个printf输出6)，而num的值变为7。接下来在printf中进行后置自减运算“num-”，此时表达式的运算结果是num自减之前的值（即7,即第三个printf输出7),而num的值会改变为6,因此第4个printf输出6。  
  
【问题2】  
a: 97  
c: 99  
e: 101  
  
C代码2 .主要考查针对字符运算的单重循环控制。字符数据的内部表示是其编码，例如字符’a’的ASCII码值为97，输出时的格式控制串为n%c:%d"时，要求以字符方式和十进制数值方式输出，因此可看到输出结果为a:97。字符集中对数字、字母的编码都是连续的，因此ch表示字符’a’时，ch+2就表示字符'c'，以此类推。  
  
【问题3】  
BCDEF  
CDEF  
DEF  
EF  
F  
  
C代码3主要考查针对字符运算的双重循环控制。外层循环控制变量raw取值范围为0~5 (等于5时结束循环)，内层循环控制变量ch的取值范围为字符‘B’+row ~‘B’+5 (等于‘B’+5即‘G’时结束内层循环），如下表所示。  
![08e493efa3db47878407260f6ab7ef21.jpg][]  


## 第3题 ##

【问题1】  
(1)usrSort(10，a)或等效形式，a可替换为&a，&a\[0\]。  
(2)temp\_arr, 0, N\*sizeof(int)或等效形式，其中N和sizeof(int)可替换为101、4。  
(3)a\[i\]或\*(a+i)或等效形式。  
(4)cnt=temp\_arr\[i\]或cnt=\*(temp\_arr+i)或等效形式。  
(5)k++或++k或k=k+1或k+=1或等效形式。  
  
本题考查考生对c程序基本结构、函数定义及调用和运算逻辑的理解和应用。  
根据空（1）所在语句的注释，明确是对函数usrSort进行调用。usrSort的原型声明为“void usrSort(int n，int a\[\])”，调用时第一个参数为一般的传值调用，实参需给出需要排序的数组元素个数，为10个，第二个参数是数组参数，需要将数组空间的首地址作为实参，用数组名或下标为0的数组元素取地址都可以，因此空（1）应填入“usrSort(10，a)”或其等效形式。  
空（2）所在语句是调用memset对申请的存储区域进行初始化。根据注释，要求将temp\_arr指向的内存区域清零，根据声明memset时的形参要求，结合调用malloc的实参值N\* sizeof(int),可知函数调用为memset(temp\_arr, 0, N\*sizeof(int))。  
空（3）所在的循环语句遍历数组a\[\]的所有元素，将元素a\[i\]作为temp\_arr的下标，从而使得temp\_arr\[a\[i\]\]表不了a\[i\]表不的值在数组a中出现的次数。  
在数组a中安排最后排序的元素时，for循环控制需要排列的元素i (即出现个数大于0者），根据注释“cnt表示i在数组a中的出现次数”，可知空（4）处应设置cnt的初始值，为“temP\_arr\[i\]”。接下来通过while循环，根据i出现的次数将i逐个放入数组中，每放入1个i，cnt自减，相应地，k需要自增，以给出下一个i要放入的数组元素，因此空（5）处应填入“k++”或其等效形式。  


## 第4题 ##

【问题1】  
(1) strCompress(test)或 strCompress(&test\[0\])或等效形式  
(2) i++  
(3) \*s==\*(s+k)或 s\[0\]==s\[k\]或\*(s+k)&&\*s==\*(s+k)或 s\[k\] &&s\[0\]==s\[k\]或等效形式  
(4) \*p++或等效形式  
(5) buf\[i\]或 buf\[i++\]或 \*(buf+i)或等效形式   
  
本题考查C程序流程控制和字符串处理及指针的应用。  
空（1）处实现对函数strCompress的调用，根据strCompress的声明和定义，要求实参提供字符存储的地址，main函数中的字符数组test保存了需要压缩的字符串，因此空（1）应填入“strCompress(test)”或其等效形式。  
在函数strCompress中，对需要压缩的字符串进行单向扫描，并将压缩结果暂存在 buf\[\]中，最后再从buf复制回原字符串。  
\*s表示待压缩字符串的当前字符，若\*s (即s\[0\])是串的最后一个字符，则\*(s+1) (即S\[1\])是串结束标志字符‘\\0，将\*s放入buf\[\]后，通过s+=k (k=1)使得s指向 ‘\\0’从而结束for循环。若不是串的最后一个字符，则需要判断\*s与\*(s+1)是否相等， 从而对连续出现的同一字符进行计数（k的值为次数)。结合遍历字符串中字符的for循环，可知空（2）处应填入“i++”，空（3）处应填入“\*s==\*(s+k)”或其等效形式。  
设置压缩结果时，先将k的值转换为数字串暂存在tstr中，然后将暂存在tstr中的数字字符逐个写入buf\[\]，因此空（4）应填入“\*p++”或其等效形式。由于每次在buf\[\]中写入字符时都对下标i进行了自增，for循环结束后，buf\[i\]即表示压缩字符串最后一个字符之后的位置，因此空（5）处应填入“buf\[i\]”或其等效形式  


## 第5题 ##

【问题1】  
(1) int goals = 0 或 int goals  
(2) this.name  
(3) goals++或++goals或等价表示  
(4) Team  
(5) newGame(t1,t2)  
  
本题考查考生应用Java语言进行程序设计的能力，涉及类、对象、方法的定义和相关操作。  
本题中涉及比赛和球队。根据说明进行设计，题目给出了类图（图5-1类图所示）。  
图中类Game和Team之间是聚合关系。Game类有两个public的方法：getResults() 和incrementGoal()分别表示获取比赛结果和某支球队进1球后增加比分；private属性是参加比赛的两支球队。Team类中有3个public方法，分别为本球队进1球后增加得分、获得本队得分和获得球队名称；private的属性为球队名称和得分。球队名采用String类型，得分信息从上下文可知是goals，用int类型。  
在Team对象创建时，初始化球队名称和得分。Java中，对象的属性若为基本数据类型int,自动初始化为0,如果有显式初始化执行显式初始化；对象的属性若为引用类型String,自动初始化为null,所以需要在构造器中对球队名称加以显式初始化。其构造器接收球队名称，参数名称与对象的属性名均为name，用this关键字加以区分。其中this关键字用来引用当前对象或类实例，可以用点取属性或行为，即：  
this.name = name;  
注：没有同名时是否有this.都表示名称所表示的对象属性。  
从方法getGoals()中return goals;判断，缺少属性goals来表不得分。再从上下文判断，方法increamentGoal()中，表示在比赛中某球队进1球，即goals的值增加1。  
创建Game对象表示两支球队的一场比赛。构造器参数为两支球队，用以初始化Game对象的两个属性。方法getResults()用于输出当前比分。方法incrementGoal()用于表示一球队进1球，具体是哪支球队由参数给定，所以参数类型为Team。  
主控逻辑代码在Game类中程序主入口 main()方法中实现。在main()方法中，先创建两支球队（用new关键字)，即两个Team类的对象，球队名称分别为“TA”和“TB”，引用名称分别为t1和t2，即：  
Team t1 = new Team("TAM);  
Team t2 = new Team(nTBn);  
以这两个对象引用名称为参数，创建一场比赛对象（用new关键字），引用名称为 football,即:  
Game football = new Game(t1, t2);  
然后用：  
football.incrementGoal(tl); football.incrementGoal(t2);  
分别表示球队TA进一球，球队TB进一球。然后调用getResults()方法输出此时的比分，即：  
football.getResuits();  
然后TB再进一球，再调用getResults()方法输出此时的比分，即：  
football.incrementGoal(t2); football.getResults();  
综上所述，空（1）需要定义表示一支球队的得分goals并初始化为0,题目代码中已经给出用分号结尾，所以空（1）为intgoals或intgoals=0;空（2）需要表示Team对象的name属性，即this.narne;空（3）需要表不当前球队得分加1，因为只有一条语句，只要表示goals加1即可，即goals++或++goals (等价表示)；空（4）需要表示参数类型为球队，即Team;空（5）处为创建Game类的对象football,需要两个Team类型对象的引用，从其后面语句可知，两个引用名称为t1和t2，即newGame(t1，t2)。  


## 第6题 ##

【问题1】  
(1)int goals或 int goals=0  
(2)this-&gt;name  
(3)goals++或++goals或等价表示  
(4)Team \*  
(5)new Game(t1，t2)   
  
本题考查考生应用C++语言进行程序设计的能力，涉及类、对象、函数的定义和相关操作。  
本题中涉及比赛和球队。根据说明进行设计，题目给出了类图（图6-1类图所示）。  
图中类Game和Team之间是聚合关系。Game类有两个public的函数：getResults()和incrementGoal()分别表示获取比赛结果和某支球队进1球后增加比分；private属性就是参加比赛的两支球队。Team类中有3个public函数，分别为本球队进1球后增加得分、获得本队得分和获得球队名称；private的属性为球队名称和得分。球队名采用string类型，得分信息从上下文可知是goals,用int类型。  
在Team对象创建时，初始化球队名称和得分。C++11标准之后，对象的属性定义时才可显式初始化；对象的属性name类型为string,需要在构造器中对球队名称加以显式初始化。其构造器接收球队名称，参数名称与对象的属性名均为name，用this关键字加以区分。其中this关键字用来引用当前对象或类实例，可以用-&gt;取属性或行为，即：  
this-&gt;name=name;  
this-&gt;goals=0;  
注：没有同名时是否有this-&gt;都表示名称所表示的对象属性。  
从函数getGoals()中的return goals判断，缺少属性goals来表不得分。再从上下文判断，函数increamentGoal()中，表示在比赛中某球队进1球，即goals的值增加1。  
创建Game对象表示两支球队的一场比赛。构造器参数为两支球队，用以初始化Game对象的两个属性。函数getResults()用于输出当前比分。函数incrementGoal()用于表示一支球队进1球，具体是哪支球队由参数给定，所以参数类型为Team\*。  
主控逻辑代码在程序主入口函数main()中实现。在main()函数中，先创建两支球队 (用new关键字)，即两个Team类的对象指针，球队名称分别为“TA”和“TB”，指针名称分别为t1和t2,即：  
Team \*t1=new Team("TA");  
Team \*t2=new Team("TB");  
以这两个对象指针名称为参数，创建一场比赛对象（用new关键字），指针名称为football,即:  
Game \*football = new Game(t1, t2);  
然后用：  
football-&gt;incrementGoal(t1);  
football-&gt;incrementGoal (t2);  
表示球队TA进一球，球队TB进一球。然后调用getResults()函数输出此时的比分，即:  
football-&gt;getResuits();  
然后TB再进一球，再调用getResults()函数输出此时的比分，即：  
football-&gt;incrementGoal(t2);  
football-&gt;getResuits();  
综上所述，空（1）需要定义表示一支球队的得分goals，题目代码中已经给出用分号结尾，所以空(1)为int goals (或C++11标准之后int goals=0也支持);空(2)需要表示Team对象指针的name属性，即this\-&gt;name;空（3）需要表示当前球队得分加1，因为只有一条语句，只要表示goals加i即可，即goals++或++goals (等价表示）；空（4） 需要表示参数类型为球队指针，即Team\*;空（5）处为创建Game类的对象football, 需要两个Team类型对象的指针，从其后面语句可知，两个指针名称为t1和t2，即new Game(t1, t2)。  



[08e493efa3db47878407260f6ab7ef21.jpg]: https://www.xkxxkx.cn/file/exam/software/程序员/案例/第2题/08e493efa3db47878407260f6ab7ef21.jpg
