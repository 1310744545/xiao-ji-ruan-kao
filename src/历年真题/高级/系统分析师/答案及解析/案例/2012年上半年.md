---  
title: 2012年上半年  
# icon: gears  
order: 997  
category:  
- 历年真题  
tag:  
- 真题  
  
# navbar: false  
# sidebar: false  
  
# breadcrumb: false  
# pageInfo: false  
# contributors: false  
# editLink: false  
# lastUpdated: false  
# prev: false  
# next: false  
comment: false  
# footer: false  
  
# backtotop: false  
---  
## 第1题 ##

【问题1】  
PERT (项目评估与评审技术）图是一种图形化的网络模型，描述一个项目中任务和任务之间的关系，每个节点表示一个任务，通常包括任务编号、名称、开始和结束时间、持续时间和松弛时间。  
Gantt图是一种简单的水平条形图，它以一个日历为基准描述项目任务，横坐标表示时间，纵坐标表示任务，图中的水平线段表示对一个任务的进度安排，线段的起点和终点对应在横坐标上的时间分别表示该任务的开始时间和结束时间，线段的长度表示完成该任务所需的时间。  
PERT图主要描述不同任务之间的依赖关系；Gantt图主要描述不同任务之间的重叠关系。  
  
解析：PERT (项目评估与评审技术）发展于20世纪50年代后期，用于为美国海军计划和控制大型的武器开发项目。PERT图是一种图形化的网络模型，描述一个项目中任务和任 务之间的关系，每个节点表示一个任务，通常包括任务编号、名称、开始和结束时间、持续时间和松弛时间。PERT图用于在任务被调度之前弄清楚任务之间的依赖关系。  
Gantt图最早由Henry L.Gantt在1917年提出，是最常用的项目调度和进展评估工具。Gantt图是一种简单的水平条形图，它以一个日历为基准描述项目任务，横坐标表示时间，纵坐标表示任务，图中的水平线段表示对一个任务的进度安排，线段的起点和终点对应在横坐标上的时间分别表示该任务的开始时间和结束时间，线段的长度表示完成该任务所需的时间。Gantt图的优点是可以清楚地显示出重叠任务，也就是说可以同时执行的任务。  
PERT图和Gantt图并不是互斥的，在交流项目进度时Gantt图更有效，需要研究任务之间的关系时PERT图更有效。  
  
【问题2】  
(a)0 (b) 1 (c) 0 (d) 6 (e) 0 (f) 2  
  
解析：在制定项目进度表时，需要为任务分配资源，所分配资源如果超过了可以提供的资源，就需要进行资源调配。松弛时间（Slack Time)是指任务在项目实际进展中可以延迟的时间，这个延迟量不会引起整个项目完成时间上的延迟。松弛时间可以提供延迟任务开始时间的机会，可以调配资源而不影响项目的完成时间。  
下图给出了表1-1中任务之间的关系，关键路径上任务的松弛时间为0,非关键路径上的任务D、F、H所对应的松弛时间分别为1、6、2。E是关键路径的节点 .  
![984472dd73734bd2a78acd700b060909.jpg][]  
  
【问题3】  
关键路径：A—B—C—E—G—I—J  
所需工期：26周  
  
解析：关键路径是一个相关任务序列，该序列上任务工期之和最大。图1-1所示PERT图中包括了6条路径：  
(1)路径序列：ABCEGHJ 工期之和：24周  
(2)路径序列：ABCEGU 工期之和：26周  
(3)路径序列：ABCFHJ 工期之和：16周  
(4)路径序列：ABDFHJ 工期之和：20周  
(5)路径序列：ABDGHJ 工期之和：23周  
(6)路径序列：ABDGIJ 工期之和：25周  
经过比较分析，任务工期之和最大值为26周，对应关键路径序列为ABCEGIJ。  
  
【问题4】  
最可能的开发工期=(最优工期+期望工期x4+最差工期)/6=(24+26x4+34)/6=27周  
  
解析：最优工期（OD)是估计完成任务所需的最小时间量；最差工期（PD）是估计完成任务所需的最大时间量；期望工期CED)是估计完成任务所需的时间量。最可能工期（D）的计算公式为：  
![8e1dc4cebb4e429598427ed263af1d05.jpg][]  
其中，1、4和1是用来计算三个估计值的加权平均值的默认权值。  
问题中最优工期OD为24,最差工期PD为34,期望工期ED为26,计算后得到最可能工期 D 为(1x24+4x26+1 x34)/6=27周。  


## 第2题 ##

【问题1】  
从系统业务功能实现来看，采用面向对象技术开发的系统以对象为核心概念，通过对象之间的消息交互完成业务功能；采用面向服务技术开发的系统以服务为核心概念，业务功能需要封装为服务。  
从系统功能集成方式来看，采用面向对象技术开发的系统以对象为单元进行功能集成，通常采用工作流技术定制业务流程；采用面向服务技术开发的系统以服务为单元进行功能集成，采用服务组合技术实现灵活的业务集成与重组。  
根据项目需求，需要对现有业务系统进行升级改造，因此保证升级改造的低成本是一个重要的因素，王工的方案需要现有系统进行功能梳理与重新开发，升级改造成本较高；李工的方案则侧重将现有功能包装为服务，升级改造成本较低。项目还要求提高系统的灵活性，王工的方案以对象技术为基础，当业务发生变化时，需要在代码层次上进行修改并重新部署，因此系统的灵活性相对较差；李工的方案以大粒度的业务服务复用为基础，当业务发生变化时，可以采用服务组合技术实现系统的运行时功能组合，因此灵活性相对较好。  
  
解析：本题从系统业务功能实现和功能集成两个方面对王工和李工的方案进行分析和对比。回答本题时必须紧扣业务功能实现和功能集成这两个方面。  
从系统业务功能实现来看，采用面向对象技术开发的系统以对象为核心概念，通过对象之间的消息交互完成业务功能；釆用面向服务技术开发的系统以服务为核心概念，业务功能需要封装为服务。  
从系统功能集成方式来看，采用面向对象技术开发的系统以对象为单元进行功能集成，通常采用工作流技术定制业务流程；采用面向服务技术开发的系统以服务为单元进行功能集成，采用服务组合技术实现灵活的业务集成与重组。  
  
【问题2】  
(a)服务契约耦合  
(b)服务契约耦合  
(c)服务消费者耦合  
(d)否  
(e)是  
(e)按照SOA的思想，业务逻辑应当与契约耦合，而不应与实现或技术耦合  
(g)服务契约不应该与具体厂商的实现技术相关，而应该基于标准的XML技术与Web服务标准  
  
解析：本题主要考查考生对服务耦合关系的理解，考生需要理解在服务设计时需要注意的一些问题。例如业务逻辑-契约耦合、契约-技术耦合、消费者-实现耦合以及消费者-契约耦合等服务。考生需要对这几种服务耦合进行分析，并结合题目要求描述各种耦合关系的优点或缺点。  
  
【问题3】  
题干中描述的问题产生的原因是在进行服务设计时，将业务逻辑可见的处理过程和不可见的处理过程封装在一起，这样会导致冗余的不可见处理过程在多个服务中存在，降低服务的潜在复用性。  
针对该问题，应该增加客户实体服务、业务实体服务和发票实体服务，形成实体服务中间层。在这种情况下，客户实体服务和业务实体服务不仅能够为客户注册和业务受理服务提供支持，还可以为发票开具服务提供支持，这样就避免了不可见处理过程在多个服务中存在。  
  
解析：本题主要考查考生对系统需求分析的理解以及对服务设计知识的掌握。题干中描述的问题产生的原因是在进行服务设计时，将业务逻辑可见的处理过程和不可见的处理过程封装在一起，这样会导致冗余的不可见处理过程在多个服务中存在，降低服务的潜在复用性。针对该问题，应该增加客户实体服务、业务实体服务和发票实体服务，形成实体服务中间层。在这种情况下，客户实体服务和业务实体服务不仅能够为客户注册和业务受理服务提供支持，还可以为发票开具服务提供支持，这样就避免了不可见处理过程在多个服务中存在。  


## 第3题 ##

【问题1】  
全虚拟化技术能够在硬件辅助虚拟化的支持下，运行任何不需要修改的客户操作系统；半虚拟化技术不需要硬件辅助虚拟化的支持，通过精心修改客户操作系统内核，在只把有限量内核代码替换为相应Hypercall的基础上实现虚拟化的，如图3-2所示。  
![70367805ed5d4c029df418528033b743.jpg][]  
  
【问题2】  
虚拟化操作系统目前仅仅支持单核处理器，不支持多核的主要原因是由于多核存在共享资源访问，虚拟化后会影响分区化的安全性，如表3-2所示。  
![2394ac38debf4295a6f3ffa0c40856fa.jpg][]  
  
解析：本题第一问主要考查嵌入式实时操作系统不支持多核处理器的原因，其主要原因是由于多核存在共享资源访问，虚拟化后会影响分区化的安全性。  
本题第二问主要考查采用虚拟化技术支持多核时，在共享引导逻辑、共享CACHE、共享I/O逻辑、结构的复杂性4个方面可能出现的问题。其中共享引导逻辑的情况下，执行影像的安全性受到潜在威胁；共享CACHE的情况下，潜在的旁路通道遭数据泄漏攻击；共享I/O逻辑的情况下，潜在的隐蔽通道攻击和服务拒绝攻击；结构的复杂性情况下，会存在潜在的故障注入攻击。  


## 第4题 ##

【问题1】  
通过对故障树进行分析，可以得出其所有的最小割集为：K1=\{X3\}，K2=\{X1, X2\}, K3=\{X4, X5, X6\}, K4=\{X5, X6, X7\}。  
  
解析：本题考查应用故障树分析方法来设计和评估软件可靠性。  
故障树分析方法简称为FTA方法（Fault Tree Analysis),是1961年由贝尔电话实验室的H.A. Watson提出的。该方式是一种系统化、形式化的分析方法，可用于系统可靠性分析和安全性分析。其目的是采用演绎方法找出导致系统故障的各种可能的基本原因，从而找到系统的薄弱环节来改进系统的设计。本题考查的是通过故障树分析方法对软件系统的可靠性进行定性和定量分析。  
定性分析的主要目的是找出所有可能的系统故障模式，即求取最小割集，并按照模块的重要性和最小割集的阶数来排列轻重次序。故障树分析方法的定性分析的核心目标是最小割集，可以通过最小割集找出系统的关键功能模块，从而找出导致关键功能模块失效的原因。  
定量分析是在求出最小割集的基础上，通过其他方法获取每一个基本事件的发生概率，从而计算最小割集和顶事件的发生概率，从而可以对系统可靠性和安全性进行进一步分析。  
割集定义：如果C是一个基本事件的集合，C中每个基本事件的发生将引起顶事件的发生，则C称为该故障树的割集。  
最小割集定义：如果C是故障树的一个割集，去掉C的任何一个基本事件，使得C不成为割集，则C为该故障树的最小割集。  
根据题中的故障树和最小割集的定义，即可求出该故障树的最小割集为：K1=\{X3\}, K2=\{X1, X2\}，K3=\{X4, X5, X6\}, K4=\{X5, X6, X7\}。  
  
【问题2】  
通过对故障树进行分析，可以得出其所有的最小割集为：K1=\{X3\}，K2=\{X1, X2\}, K3=\{X4, X5, X6\}, K4=\{X5, X6, X7丨。则对应割集的失效概率分别为：  
F(K1)=0.008  
F(K2)=0.05x0.05=0.0025  
F(K3)=0.07x0.05x0.05=0.000 175  
F(K4)=0.05x0.05x0.08=0.0002  
则整个软件的失效概率近似为：  
P(T)=0.008+0.0025+0.000 175+0.0002=0.010 875  
R=1-0.010 875=0.989 125&lt;0.99  
因此，软件的可靠性没有达到分配的指标要求。  
  
解析：第二问是对该故障树的定量分析，在最小割集的基础上，已知每个基本事件的失效概率，即可计算出每个割集的失效概率，从而计算出整个软件系统的失效概率。即:  
F(K1)=0.008  
F(K2)=0.05\*0.05=0.0025  
F(K3)=0.07\*0.05\*0.05=0.000175  
F(K4)=0.05 \*0.05 \*0.08=0.0002  
则整个软件的失效概率近似为：  
P(T)=0.008+0.0025+0.000 175+0.0002=0.010 875  
根据题干中要求可以看出，此设计方案未能满足要求。  
  
【问题3】  
根据最小割集的定义，最小割集中所含模块数越少，此最小割集中模块的可靠性要求就越高。所以X3模块的可靠性要求最高，为关键功能模块。由于X3模块对应的割集失效概率过高，导致了软件未能达到分配的指标要求。  
改进方法（答出一种即可)：  
（1）采用多轮重复测试的方法，使得模块X3的失效概率收敛，满足可靠性指标要求。  
（2）重新设计模块X3,提高其可靠性，降低其失效概率。  
（3）割集K1为一阶割集，容易出现单点故障。可以在X3模块所在层次或其上级增加“与门”，降低K1割集的失效概率。  
  
解析：最小割集所包含基本事件的数目称为最小割集的阶数。阶数越低的最小割集重要性越大，显然，阶数为1的最小割集最重要，其可靠性要求就越高。所以X3模块的可靠性要求最高，为关键功能模块。由于X3模块对应的割集失效概率过高，导致了软件未能达到分配的指标要求。  
工程中实际的改进方法一般包括：  
（1）采用多轮重复测试的方法，使得模块X3的失效概率收敛，满足可靠性指标要求。  
（2）重新设计模块X3,提高其可靠性，降低其失效概率。  
（3）割集K1为一阶割集，容易出现单点放障。可以在X3模块所在层次或其上级增加“与门”，降低K1割集的失效概率。  


## 第5题 ##

【问题1】  
（a）~（c）: (2)、（3）、（7），以上三个答案顺序可调换。  
（d）~（f）: (1)、（5）、（8），以上三个答案顺序可调换。  
（g）~（i）: (4)、（6）、（9），以上三个答案顺序可调换。  
  
解析：本题主要考查.NET和J2EE平台的区别，考生需要从跨平台可移植性、部署与配置、多程序设计语言支持、Web多层应用开发支持、多厂商外部支持、O/R (对象/关系）映射支持、针对特定平台的优化支持、源代码以外的可定制性支持以及Web服务支持等方面作答。  
  
【问题2】  
在基于EJB的重量级框架中，实现的构件分别为：  
•模型（Model):由EJB构件实现。  
•视图（View):由JSP构件实现。  
•控制器（Controller):由Servlet构件实现。  
在基于Struts等的轻量级框架中，实现的构件分别为：  
•模型（Model):由Java Bean构件实现。  
•视图（View):由JSP构件实现。  
•控制器（Controller):由Servlet构件实现。  
MVP模式与MVC模式的主要区别为：  
（1）在组件耦合度方面：在MVP模式中，视图并不直接使用模型，它们之间的通信通过Presenter进行，从而实现了视图与模型的分离；而在MVC模式中，视图直接与模型交互。  
（2）在组件分工方面：在MVP模式中，视图需要处理鼠标及键盘等触发的界面事件；而在MVC模式中，这通常是由控制器完成的工作。在MVP模式中，系统核心业务逻辑组织集中在Presenter中；而在MVC模式中，相应的控制器通常只完成事件的分发。  
（3）在开发工程化支持方面：MVP模式可更好地支持单元测试；而在MVC模式中，由于模型与视图绑定，因此难以实施相应的单元测试。在MVP模式中，Presenter基于约定接口与视图和模型交互，可更好地支持组件的重用。  
  
解析：本题主要考查MVC和MVP模式的区别。MVC模式是Web应用系统开发中常用的一种软件架构模式，包括基于EJB的重量级框架和基于Struts等的轻量级框架等。MVP模式与MVC模式的主要区别为：  
在组件耦合度方面：在MVP模式中，视图并不直接使用模型，它们之间的通信通过Presenter进行，从而实现了视图与模型的分离；而在MVC模式中，视图直接与模型交互。  
在组件分工方面：在MVP模式中，视图需要处理鼠标及键盘等触发的界面事件；而在MVC模式中这通常是由控制器完成的工作。在MVP模式中，系统核心业务逻辑组织集中在Presenter中；而在MVC模式中，.相应的控制器通常只完成事件的分发。  
在开发工程化支持方面：MVP模式可更好地支持单元测试；而在MVC模式中，由于模型与视图绑定，因此难以实施相应的单元测试。在MVP模式中，Presenter基于约定接口与视图和模型交互，可更好地支持组件的重用。  
  
【问题3】  
事务的基本特征包括：  
•原子性。一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。  
•一致性。在事务开始之前和事务结束以后，数据的完整性限制没有被破坏。  
•隔离性。两个事务的执行是互不干扰的，两个事务时间不会互相影响。  
•持久性。在事务完成以后，该事务对数据所作的更改便持久地保存在数据库之中，并且是完全的。  
EJB规范支持的两种事务控制方法为：  
•容器维护的事务（Container Managed Transaction, CMT)。由EJB容器根据部署描述符或EJB构件注释中指定的事务属性自动控制事务的边界，容器维护的事务是方法级的，即默认将一个方法当作一个事务执行，当方法执行的过程中发生 系统级异常，容器会自动将事务回滚，从而将方法前面执行的结果恢复。  
•Bean维护的事务（Bean Managed Transaction，BMT)。由程序员在EJB的源代码中控制事务执行的边界，事务的边界通过Java事务接口（Java Transaction API,JTA)进行控制，Bean维护的事务可以跨越方法的边界。  
  
本题主要考查事务的基本特征和EJB规范中提供的事务控制的基本方法。事务的基本特征包括：  
•原子性。一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。  
•一致性。在事务开始之前和事务结束以后，数据的完整性限制没有被破坏。  
•隔离性。两个事务的执行是互不干扰的，两个事务时间不会互相影响。  
•持久性。在事务完成以后，该事务对数据所作的更改便持久地保存在数据库之中，并且是完全的。  
EJB规范支持的两种事务控制方法为：  
•容器维护的事务（Container Managed Transaction, CMT)。由EJB容器根据部署描述符或EJB构件注释中指定的事务属性自动控制事务的边界，容器维护的事务是方法级的，即默认将一个方法当作一个事务执行，当方法执行的过程中发生 系统级异常，容器会自动将事务回滚，从而将方法前面执行的结果恢复。  
•Bean维护的事务（Bean Managed Transaction，BMT)。由程序员在EJB的源代码中控制事务执行的边界，事务的边界通过Java事务接口（Java Transaction API，JTA)进行控制，Bean维护的事务可以跨越方法的边界。  



[984472dd73734bd2a78acd700b060909.jpg]: https://www.xkxxkx.cn/file/exam/software/系统分析师/案例/第1题/984472dd73734bd2a78acd700b060909.jpg
[8e1dc4cebb4e429598427ed263af1d05.jpg]: https://www.xkxxkx.cn/file/exam/software/系统分析师/案例/第1题/8e1dc4cebb4e429598427ed263af1d05.jpg
[70367805ed5d4c029df418528033b743.jpg]: https://www.xkxxkx.cn/file/exam/software/系统分析师/案例/第3题/70367805ed5d4c029df418528033b743.jpg
[2394ac38debf4295a6f3ffa0c40856fa.jpg]: https://www.xkxxkx.cn/file/exam/software/系统分析师/案例/第3题/2394ac38debf4295a6f3ffa0c40856fa.jpg
